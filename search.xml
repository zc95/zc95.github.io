<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[js的函数重载]]></title>
      <url>/2018/04/15/overloading/</url>
      <content type="html"><![CDATA[<h2 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h2><p>函数重载，简单说，就是函数有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。</p>
<p>所以说，重载函数需要两点：同样的函数名，不同的函数参数。</p>
<h2 id="js到底有没有函数重载"><a href="#js到底有没有函数重载" class="headerlink" title="js到底有没有函数重载"></a>js到底有没有函数重载</h2><p>如果在我们在一个页面中定义了两个名字相同的函数，则该名字只属于后定义的函数，如下：</p>
<pre><code class="javascript">function add(num){
    return num+1;
}
function add(num){
    return num+2;
}
add(4);  //结果为6
</code></pre>
<p>在上面的例子中，add()函数被定义了两次，然而，当我们调用他的时候，却直接调用了第二个函数，这说明在JavaScript中，后定义的函数会覆盖先定义的函数。</p>
<p>其实，在java或者.net中都是是存在重载的，那么js中呢？可以肯定的说，js中是不存在重载的，但是我们可以通过其他的方式来模拟重载。</p>
<h2 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h2><p>当我们在js中在调用一个函数的时候，我们经常会给这个函数传递一些参数，js把传入到这个函数的全部参数存储在一个叫做arguments的东西里面，<code>arguments</code>对象不是一个<code>Array</code> 。它类似于<code>Array</code>，可以使用[i]或者.length，为了代码的严谨度，我们可以用arguments的length属性来判断当前传入参数的个数是否与我们需要的数量一致。</p>
<pre><code class="javascript">function add(num1, num2){  
  // 根据arguments.length，对不同的值进行不同的操作
　　switch(arguments.length) {
　　　　case 0:
　　　　　　/*没有传入任何参数时*/
　　　　　　break;
　　　　case 1:
　　　　　　/*传入一个参数时*/
　　　　　　break;
　　　　case 2:
　　　　　　/*传入两个参数时*/
             break;
      /*case N.....*/
}
}
</code></pre>
<p>通过这个例子，我们可以看出，通过检查传入函数中参数的数量，JavaScript函数可以做出不同的反应，这可以间接达到重载的目的。</p>
<p>所以，JavaScript是可以模仿函数的重载的。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="arguments-类数组对象转为真正的数组"><a href="#arguments-类数组对象转为真正的数组" class="headerlink" title="arguments 类数组对象转为真正的数组"></a>arguments 类数组对象转为真正的数组</h3><pre><code>Array.prototype.slice.apply(arguments);

Array.from(arguments);

[...arguments];
</code></pre><h3 id="callee"><a href="#callee" class="headerlink" title="callee"></a>callee</h3><p><code>arguments.callee</code> 属性包含当前正在执行的函数。<strong>callee</strong> 是 <code>arguments</code> 对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。这在函数的名称是未知时很有用，例如在没有名称的函数表达式（也称为匿名函数）内。</p>
<p>以一个求阶乘的方法为例：</p>
<pre><code class="javascript">function fact(n) {
 if (n &lt; 2) {
  return n;
 } else {
  return n * fact(n - 1);
 }
}
console.log(fact(5)); //5*4*3*2=120
</code></pre>
<p>匿名函数中：</p>
<pre><code class="javascript">(function (n) {
 if (n &lt; 2) {
  return n;
 } else {
  return n * arguments.callee(n - 1);
 }
})(5);
</code></pre>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 函数重载 </tag>
            
            <tag> arguments对象 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js构建TCP服务器和TCP客户端]]></title>
      <url>/2018/03/20/nodejs-TCP/</url>
      <content type="html"><![CDATA[<p>网络是通信互联网的基础，Node.js提供了net、http、dgram模块、分别用来实现TCP、HTTP、UDP的通信。上次的文章<a href="https://zc95.github.io/2018/03/19/nodejs-HTTP/">《Node.js构建HTTP服务器》</a>实现了HTTP的通信，这篇文章说一说TCP服务器和TCP客户端的构建。</p>
<h2 id="用Node-js创建TCP服务器"><a href="#用Node-js创建TCP服务器" class="headerlink" title="用Node.js创建TCP服务器"></a>用Node.js创建TCP服务器</h2><h3 id="构建TCP服务器"><a href="#构建TCP服务器" class="headerlink" title="构建TCP服务器"></a>构建TCP服务器</h3><p>为了使用Node.js创建TCP服务器，首先要使用require(“net”)来加载net模块，然后使用net模块的createServer方法就可以轻松地创建一个TCP服务器。</p>
<pre><code class="javascript">/**
 * 构建TCP客户端
 */

/* 引入net模块 */
var net = require(&quot;net&quot;);

/* 创建TCP服务器 */
var server = net.createServer(function(socket){
    console.log(&#39;someone connects&#39;);
})

/* 设置连接的服务器 */
server.listen(8000, function(){
    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);
})
</code></pre>
<p>运行这段代码并访问了<a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a>的话会看到控制台打印了”someone connects”，表明已经成功连接到这个创建的TCP服务器。</p>
<hr>
<blockquote>
<p>/<em> 设置连接的服务器 </em>/<br>server.listen(8000, function(){<br>​    console.log(“Creat server on <a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a>“);<br>})</p>
</blockquote>
<p>上面这段代码实际上触发的是server下的listening事件，等同于：</p>
<blockquote>
<p>/<em> 设置监听端口 </em>/</p>
<p>server.listen(8000);</p>
<p>/<em> 设置监听时的回调函数 </em>/</p>
<p>server.on(“listening”, function () {</p>
<p>​    console.log(“Creat server on <a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a>“);</p>
<p>})</p>
</blockquote>
<p>事实上，除了listening事件外，TCP服务器还支持以下事件：</p>
<ol>
<li>connection：当有新的连接创建时触发，回调函数的参数为socket连接对象。</li>
<li>close：TCP服务器关闭的时候触发，回调函数没有参数</li>
<li>error：TCP服务器发生错误的时候触发，回调函数的参数为error对象</li>
</ol>
<p>下列代码通过net.Server类来创建一个TCP服务器，并添加以上事件。</p>
<pre><code class="javascript"> /**
 * 通过net.Server类来创建一个TCP服务器
 */

/* 引入net模块 */
var net = require(&quot;net&quot;);

/* 实例化一个服务器对象 */
var server = new net.Server();

/* 监听 connection 事件 */
server.on(&quot;connection&quot;, function (socket) {
    console.log(&quot;someone connects&quot;);
});

/* 设置监听端口 */
server.listen(8000);

/* 设置监听时的回调函数 */
server.on(&quot;listening&quot;, function () {
    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);
})

/* 设置关闭时的回调函数 */
server.on(&quot;close&quot;, function () {
    console.log(&quot;server closed!&quot;);
})

/* 设置错误时的回调函数 */
server.on(&quot;error&quot;, function (err) {
    console.log(&quot;error!&quot;);
})
</code></pre>
<h3 id="查看服务器监听的地址"><a href="#查看服务器监听的地址" class="headerlink" title="查看服务器监听的地址"></a>查看服务器监听的地址</h3><p>当创建了一个TCP服务器后，可以通过server.address()方法来查看这个TCP服务器监听的地址，并返回一个JSON对象。这个对象的属性有：</p>
<ol>
<li>port：TCP服务器监听的端口号</li>
<li>family：说明TCP服务器监听的地址是 IPv6 还是 IPv4</li>
<li>address：TCP服务器监听的地址</li>
</ol>
<pre><code class="javascript">/**
 * 查看服务器监听的地址
 */

/* 引入net模块 */
var net = require(&quot;net&quot;);

/* 创建TCP服务器 */
var server = net.createServer(function(socket){
    console.log(&#39;someone connects&#39;);
})

/* 获取地址信息 */
server.listen(8000,function(){
    /* 获取地址信息，得到的是一个json { address: &#39;::&#39;, family: &#39;IPv6&#39;, port: 8000 } */
    var address = server.address();

    /* TCP服务器监听的端口号 */
    console.log(&quot;the port of server is&quot;+ address.port);

    /* TCP服务器监听的地址 */
    console.log(&quot;the address of server is&quot;+ address.address);

    /* 说明TCP服务器监听的地址是 IPv6 还是 IPv4 */
    console.log(&quot;the family of server is&quot;+ address.family);
})
</code></pre>
<h3 id="连接服务器的客户端数量"><a href="#连接服务器的客户端数量" class="headerlink" title="连接服务器的客户端数量"></a>连接服务器的客户端数量</h3><p>创建一个TCP服务器后，可以通过server.getConnections()方法获取连接这个TCP服务器的客户端数量。除此之外，也可以通过maxConnections属性来设置这个服务器的最大连接数量，当连接数量超过最大值时，服务器将拒绝新的连接。</p>
<pre><code class="javascript">/**
 * 连接服务器的客户端数量
 */

/* 引入net模块 */
var net = require(&quot;net&quot;);

/* 创建TCP服务器 */
var server = net.createServer(function(socket){
    console.log(&#39;someone connects&#39;);

    /* 设置最大连接数量 */
    server.maxConnections=3;
    server.getConnections(function(err,count){
        console.log(&quot;the count of client is &quot;+count);
    })
})

/* 获取监听端口 */
server.listen(8000,function(){
    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);
})
</code></pre>
<p>你可以打开多个网页输入localhost:8000来测试这段代码，也可以用Telnet命令 <code>telnet localhost 8000</code> 来连接这个TCP服务器（上一篇文章有提到如何用Homebrew安装Telnet：<a href="https://zc95.github.io/2018/03/20/Homebrew/">《Homebrew》</a>）。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fpkqytum6zj31kw0s7toa.jpg" alt=""></p>
<h3 id="服务器和客户端之间的通信"><a href="#服务器和客户端之间的通信" class="headerlink" title="服务器和客户端之间的通信"></a>服务器和客户端之间的通信</h3><p>利用socket.write()可以使TCP服务器发送数据给客户端；</p>
<p>socket对象可以用来获取客户端发出的流数据，每次接收到数据的时候触发data事件，通过监听这个事件就可以在回调函数中获取客户端发送的数据了。</p>
<pre><code class="javascript">/**
 * 发送和获取
 */

/* 引入net模块 */
var net = require(&quot;net&quot;);

/* 创建TCP服务器 */
var server = net.createServer(function(socket){
    /* 获取地址信息 */
    var address = server.address();
    var message = &quot;the server address is&quot;+JSON.stringify(address);

    /* 发送数据 */
    socket.write(message,function(){
        var writeSize = socket.bytesWritten;
        console.log(message + &quot;has send&quot;);
        console.log(&quot;the size of message is&quot;+writeSize);
    })

    /* 监听data事件 */
    socket.on(&#39;data&#39;,function(data){
        console.log(data.toString());
        var readSize = socket.bytesRead;
        console.log(&quot;the size of data is&quot;+readSize);
    })
})

/* 获取地址信息 */
server.listen(8000,function(){
    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);
})
</code></pre>
<p>下图中TCP服务器给客户端发送了字符串：</p>
<blockquote>
<p>the server address is{“address”:”::”,”family”:”IPv6”,”port”:8000}has send</p>
</blockquote>
<p>客户端给TCP服务器发送了字符串 <code>hello TCP!</code> 和字节数。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fpkr5446asj31kw0p5gvz.jpg" alt=""></p>
<h2 id="用Node-js创建TCP客户端"><a href="#用Node-js创建TCP客户端" class="headerlink" title="用Node.js创建TCP客户端"></a>用Node.js创建TCP客户端</h2><h3 id="构建TCP客户端"><a href="#构建TCP客户端" class="headerlink" title="构建TCP客户端"></a>构建TCP客户端</h3><p>上面说到用打开网页或者Telnet来访问TCP服务器，其实我们也可以用Node.js来构建一个TCP客户端，实现TCP客户端和TCP服务器的通信。</p>
<p>为了使用Node.js创建TCP客户端，首先要使用require(“net”)来加载net模块，然后创建一个连接TCP客户端的socket对象即可：</p>
<blockquote>
<p>/<em> 引入net模块 </em>/</p>
<p>var net = require(“net”);</p>
<p>/<em> 创建TCP客户端 </em>/</p>
<p>var client = net.Socket();</p>
</blockquote>
<p>创建完socket对象后，使用socket对象的connect方法就可以连接一个TCP服务器。</p>
<pre><code class="javascript">/**
 * 构建TCP客户端
 */

/* 引入net模块 */
var net = require(&quot;net&quot;);

/* 创建TCP客户端 */
var client = net.Socket();

/* 设置连接的服务器 */
client.connect(8000, &#39;127.0.0.1&#39;, function () {
    console.log(&quot;connect the server&quot;);

    /* 向服务器发送数据 */
    client.write(&quot;message from client&quot;);
})

/* 监听服务器传来的data数据 */
client.on(&quot;data&quot;, function (data) {
    console.log(&quot;the data of server is &quot; + data.toString());
})

/* 监听end事件 */
client.on(&quot;end&quot;, function () {
    console.log(&quot;data end&quot;);
})
</code></pre>
<h3 id="TCP客户端和TCP服务器的通信"><a href="#TCP客户端和TCP服务器的通信" class="headerlink" title="TCP客户端和TCP服务器的通信"></a>TCP客户端和TCP服务器的通信</h3><p>运行 <a href="#服务器和客户端之间的通信">这段代码</a> 之后再运行 <a href="#构建TCP客户端">这段代码</a> ，可以发现服务器已经接收到客户端的数据，客户端也已经接收到服务端的数据。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fpkso73cqdj31kw0o27bv.jpg" alt=""></p>
<h2 id="LINK"><a href="#LINK" class="headerlink" title="LINK"></a>LINK</h2><ol>
<li>本章github源码：<a href="https://github.com/zc95/nodeTest/tree/master/TCP" target="_blank" rel="external">https://github.com/zc95/nodeTest/tree/master/TCP</a></li>
<li>《Node.js构建HTTP服务器》：<a href="https://zc95.github.io/2018/03/19/nodejs-HTTP/">https://zc95.github.io/2018/03/19/nodejs-HTTP/</a></li>
<li>用Homebrew安装Telnet：<a href="https://zc95.github.io/2018/03/20/Homebrew/">https://zc95.github.io/2018/03/20/Homebrew/</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> TCP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Homebrew]]></title>
      <url>/2018/03/20/Homebrew/</url>
      <content type="html"><![CDATA[<p>Homebrew简称brew，OSX上的软件包管理工具，在Mac终端可以通过brew安装、更新、卸载软件。</p>
<h2 id="Homebrew-能干什么"><a href="#Homebrew-能干什么" class="headerlink" title="Homebrew 能干什么?"></a>Homebrew 能干什么?</h2><p><a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew官网</a> 的title是这么说的：macOS 缺失的软件包管理器，意思就是使用 Homebrew 安装 Apple 没有预装但你需要的东西，比如high sierra 10.13中移除了telnet，只需要 <code>brew install telnet</code> 一个命令就行。</p>
<a id="more"></a>
<h2 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h2><p>一、进入<a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew官网</a>，按照官网提示在命令行执行ruby脚本（mac自带ruby），在终端运行以下命令：</p>
<pre><code class="bash">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<p>二、按提示输入电脑密码，一路enter到底，直到出现下面的信息就说明安装成功。</p>
<pre><code class="bash">==&gt; Next steps:
- Run `brew help` to get started
- Further documentation: 
    https://docs.brew.sh
</code></pre>
<p>三、运行命令 <code>brew help</code> 就可以了解一些brew常用的命令：</p>
<pre><code class="bash">Example usage:
  brew search [TEXT|/REGEX/]
  brew (info|home|options) [FORMULA...]
  brew install FORMULA...
  brew update
  brew upgrade [FORMULA...]
  brew uninstall FORMULA...
  brew list [FORMULA...]

Troubleshooting:
  brew config
  brew doctor
  brew install -vd FORMULA

Developers:
  brew create [URL [--no-fetch]]
  brew edit [FORMULA...]
  https://docs.brew.sh/Formula-Cookbook

Further help:
  man brew
  brew help [COMMAND]
  brew home
</code></pre>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Homebrew </tag>
            
            <tag> brew </tag>
            
            <tag> telnet </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js构建HTTP服务器]]></title>
      <url>/2018/03/19/nodejs-HTTP/</url>
      <content type="html"><![CDATA[<p>Node.js® is a JavaScript runtime built on <a href="https://developers.google.com/v8/" target="_blank" rel="external">Chrome’s V8 JavaScript engine</a>. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, <a href="https://www.npmjs.com/" target="_blank" rel="external">npm</a>, is the largest ecosystem of open source libraries in the world.</p>
<h2 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a>Node.js简介</h2><p><code>Node.js</code> 是一个基于 Google Chrome V8 引擎 的 JavaScript 运行环境。Node.js使用后多种先进的技术，其中包括 事件驱动、非阻塞 I/O 模型，使其轻量又高效，受到众多开发者的追捧。</p>
<p>简单的说，Node.js 就是运行在服务端的 JavaScript ，可以稳定地在各种平台下运行，包括Linux、Windows、Mac OS X、Sun Os 和FreeBSD等众多平台。</p>
<a id="more"></a>
<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><ol>
<li>点击 <a href="https://nodejs.org" target="_blank" rel="external">https://nodejs.org</a> 进入nodejs官网</li>
<li>有两个版本：LTS和Current，LTS是长期支持版本，成熟可靠</li>
<li>next到底</li>
<li>打开终端，输入 <code>node -v</code> ，回车，如果出现类似 <code>v6.11.4</code> 的版本号就说明安装成功</li>
</ol>
<h2 id="构建一个HTTP服务器"><a href="#构建一个HTTP服务器" class="headerlink" title="构建一个HTTP服务器"></a>构建一个HTTP服务器</h2><p>在如今web大行其道的时代，支撑无数网页运行的正是HTTP服务器。Node.js之所以受到大量web开发者的青睐，与Node.js有能力自己构建服务器是分不开的。</p>
<ol>
<li><p>在根目录下新建 <code>nodetest</code> 文件夹</p>
</li>
<li><p>在 <code>nodetest</code> 下新建 <code>HTTP</code> 文件夹</p>
</li>
<li><p>在 <code>HTTP</code> 文件夹下新建一个 <code>server.js</code> 的文件</p>
</li>
<li><p>拷贝粘贴这段代码，保存：</p>
<pre><code class="javascript">/**
 * 创建http服务器
 */

/* 引入http模块 */
var http = require(&quot;http&quot;);

/* 创建HTTP服务器 */
var server = http.createServer(function(request, response) {
    /* 设置相应的头部 */
    response.writeHead(200, {
        &quot;content-Type&quot; : &quot;text/plain&quot;
    });

    /* 设置相应的数据 */
    response.write(&quot;Welcome to Nodejs&quot;);
    response.end();
});

/* 设置服务器端口 */
server.listen(8000, function(){
    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);
})
</code></pre>
</li>
<li><p>打开终端 输入 <code>cd nodetest/HTTP</code> </p>
</li>
<li><p>输入 <code>node server.js</code> ，返回 <code>Creat server on http://127.0.0.1:8000/</code></p>
</li>
<li><p>打开浏览器输入 <code>http://127.0.0.1:8000/</code> 或者 <code>http://localhost:8000</code> </p>
</li>
<li><p>Welcome to Nodejs</p>
</li>
</ol>
<h2 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块"></a>文件模块</h2><p>上面说到的HTTP服务器知识实现了将一串字符串发送给服务器。很明显，如果服务器只能发送一些字符串，那几乎是远远不够的，因此我们要做一些扩展，通过文件模块将文件读取并发送给服务器是一个不错的选择，在nodetest文件夹下新建 <code>fsModule.js</code> :</p>
<pre><code class="javascript">/**
 * fs模块
 */

/* 引入http模块 */
var http = require(&quot;http&quot;);

/* 引入fs模块 */
var fs = require(&quot;fs&quot;);

/* 创建HTTP服务器 */
var server = http.createServer(function(request, response) {
    /* 设置响应的头部 */
    response.writeHead(200, {
        &quot;content-Type&quot; : &quot;text/html&quot;
    });

    /* 读取文件数据 */
    var data = fs.readFileSync(&quot;./index.html&quot;);

    /* 设置响应的数据 */
    response.write(data);
    response.end();
});

/* 设置服务器端口 */
server.listen(8000, function(){
    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);
})
</code></pre>
<p>同时在同级目录中创建一个名为 <code>index.html</code> 的文件，写入以下代码：</p>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;title&gt;fs module&lt;/title&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;fs文件模块&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>node fsModule.js 运行，在浏览器中打开 <code>http://localhost:8000</code> ，Node.js已经把index这个文件发送到客户端了；</p>
<p>需要提及的是，这里HTTP服务器在发送给浏览器的头部信息中将 content-type修改为了 <code>text/html</code> 。 content-type的人作用就是用来表示客户端或者服务器传输数据的类型，服务器或者客客户端通过这个值来做相应的解析。如果这个值改为原来的 <code>text/plain</code> ，浏览器将显示index.html的所有源代码，这显然不是我们想要的。</p>
<h2 id="HTTP服务器的路由控制"><a href="#HTTP服务器的路由控制" class="headerlink" title="HTTP服务器的路由控制"></a>HTTP服务器的路由控制</h2><p>上一节中的服务器虽然已经可以通过读取文件数据来发送给客户端了，但你并没有做任何的路由控制，在浏览器中输入任何URL都将返回同样的内容，简单来说，路由就是URL到函数的映射。</p>
<p>要做到路由控制，通过上面的学习可以预想到修改content-type就可以了，这里假定只需要处理html、js、css和图片文件，创建一个名为 <code>mime.js</code> 的文件：</p>
<pre><code class="javascript">module.exports = {
    &quot;.html&quot; : &quot;text/html&quot;,
    &quot;.css&quot; : &quot;text/css&quot;,
    &quot;.js&quot; : &quot;text/javascript&quot;,
    &quot;.gif&quot; : &quot;image/gif&quot;,
    &quot;.ico&quot; : &quot;image/x-icon&quot;,
    &quot;.jpeg&quot; : &quot;image/jpeg&quot;,
    &quot;.jpg&quot; : &quot;image/jpeg&quot;,
    &quot;.png&quot; : &quot;image/png&quot;,
}
</code></pre>
<p>创建一个名为 <code>fsModule2.js</code> 的文件：</p>
<pre><code class="javascript">/**
 * 这里通过路径处理判断来返回不同的资源，从而做到简单的路由控制
 */

/* 引入http模块 */
var http = require(&quot;http&quot;);

/* 引入fs模块 */
var fs = require(&quot;fs&quot;);

/* 引入url模块 */
var url = require(&quot;url&quot;);

/* 引入mime文件 */
var mime = require(&quot;./mime.js&quot;);

/* 引入path模块 */
var path = require(&quot;path&quot;);

/* 创建HTTP服务器 */
var server = http.createServer(function(request, response) {
    var filePath = &quot;.&quot;+url.parse(request.url).pathname;
    if(filePath === &quot;./&quot;){
        filePath = &#39;./index.html&#39;
    }

    /* 判断相应的文件是否存在 */
    fs.exists(filePath,function(exists){
        /* 存在则返回相应文件数据 */
        if(exists){
            var data = fs.readFileSync(filePath);
            var contentType = mime[path.extname(filePath)];
            response.writeHead(200,{
                &quot;content-type&quot;: contentType
            });
            response.write(data);
            response.end();
        }else{
            response.end(&quot;404&quot;);
        }
    })
});

/* 设置服务器端口 */
server.listen(8000, function(){
    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);
})
</code></pre>
<p>这里通过对路径处理判断来返回不同的资源，从而做到简单的路由控制。</p>
<h2 id="LINK"><a href="#LINK" class="headerlink" title="LINK"></a>LINK</h2><ol>
<li>本章github源码：<a href="https://github.com/zc95/nodeTest/tree/master/HTTP" target="_blank" rel="external">https://github.com/zc95/nodeTest/tree/master/HTTP</a></li>
<li>《Node.js构建TCP服务器和TCP客户端》：<a href="https://zc95.github.io/2018/03/20/nodejs-TCP/">https://zc95.github.io/2018/03/20/nodejs-TCP/</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> 本地服务器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6入门]]></title>
      <url>/2018/03/13/es6-webpack/</url>
      <content type="html"><![CDATA[<p>github：<a href="https://github.com/zc95/es6-webpack" target="_blank" rel="external">https://github.com/zc95/es6-webpack</a></p>
<h2 id="webpack搭建ES6环境"><a href="#webpack搭建ES6环境" class="headerlink" title="webpack搭建ES6环境"></a>webpack搭建ES6环境</h2><p>首先下载源码</p>
<pre><code class="shell">git clone https://github.com/zc95/es6-webpack.git
</code></pre>
<p>然后安装</p>
<pre><code class="shell">cd es6-webpack
npm install
npm install webpack -g
npm install webpack-dev-server -g
</code></pre>
<p>最后运行</p>
<pre><code class="shell">cd es6-webpack
npm start
</code></pre>
<a id="more"></a>
<h2 id="es6基础"><a href="#es6基础" class="headerlink" title="es6基础"></a>es6基础</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><pre><code class="javascript">// ES5 中常量的写法

Object.defineProperty(window, &quot;PI2&quot;, {
    value: 3.1415926,
    writable: false,
})
</code></pre>
<pre><code class="javascript">// ES6 的常量写法

const PI = 3.1415926
</code></pre>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><pre><code class="javascript">// ES3,ES5
var evens = [1, 2, 3, 4, 5];
var odds = evens.map(function(v) {
  return v + 1
});
  console.log(evens, odds);
};
</code></pre>
<pre><code class="javascript">// ES6
let evens = [1, 2, 3, 4, 5];
let odds = evens.map(v =&gt; v + 1);
console.log(evens, odds);
</code></pre>
<p><strong>this的指向</strong></p>
<pre><code class="javascript">// ES3,ES5中 this 的指向是 该函数被调用的对象
  var factory = function() {
    this.a = &#39;a&#39;;
    this.b = &#39;b&#39;;
    this.c = {
      a: &#39;a+&#39;,
      b: function() {
        return this.a
      }
    }
  }

  console.log(new factory().c.b());
};
</code></pre>
<pre><code class="javascript">// ES6箭头函数中 this 的指向是 定义时this的指向
var factory = function() {
    this.a = &#39;a&#39;;
    this.b = &#39;b&#39;;
    this.c = {
      a: &#39;a+&#39;,
      b: () =&gt; {
        return this.a
      }
    }
  }
  console.log(new factory().c.b());
</code></pre>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p><strong>默认参数</strong></p>
<pre><code class="javascript">// ES5\ES3 默认参数的写法
  function f(x, y, z) {
    if (y === undefined) {
      y = 7;
    }
    if (z === undefined) {
      z = 42
    }
    return x + y + z
  }
  console.log(f(1, 3));
</code></pre>
<pre><code class="javascript">// ES6 默认参数
  function f(x, y = 7, z = 42) {
    return x + y + z
  }
  console.log(f(1, 3));
</code></pre>
<p><strong>可变参数</strong></p>
<pre><code class="javascript">// ES3,ES5 可变参数
  function f() {
    var a = Array.prototype.slice.call(arguments);
    var sum = 0;
    a.forEach(function(item) {
      sum += item * 1;
    })
    return sum
  }
  console.log(f(1, 2, 3, 6));
</code></pre>
<pre><code class="javascript">// ES6 可变参数
function f(...a) {
    var sum = 0;
    a.forEach(item =&gt; {
      sum += item * 1
    });
    return sum
  }
  console.log(f(1, 2, 3, 6));
</code></pre>
<p><strong>合并数组</strong></p>
<pre><code class="javascript">// ES5 合并数组
  var params = [&#39;hello&#39;, true, 7];
  var other = [1, 2].concat(params);
  console.log(other);
</code></pre>
<pre><code class="javascript">// ES6 利用扩展运算符合并数组
  var params = [&#39;hello&#39;, true, 7];
  var other = [
    1, 2, ...params
  ];
  console.log(other);
</code></pre>
<h3 id="对象代理"><a href="#对象代理" class="headerlink" title="对象代理"></a>对象代理</h3><pre><code class="javascript">// ES3,ES5 数据保护
  var Person = function() {
    var data = {
      name: &#39;es3&#39;,
      sex: &#39;male&#39;,
      age: 15
    }
    this.get = function(key) {
      return data[key]
    }
    this.set = function(key, value) {
      if (key !== &#39;sex&#39;) {
        data[key] = value
      }
    }
  }

  // 声明一个实例
  var person = new Person();
  // 读取
  console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)});
  // 修改
  person.set(&#39;name&#39;, &#39;es3-cname&#39;);
  console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)});
  person.set(&#39;sex&#39;, &#39;female&#39;);
  console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)});
</code></pre>
<pre><code class="javascript">// ES5
  var Person = {
    name: &#39;es5&#39;,
    age: 15
  };

  Object.defineProperty(Person, &#39;sex&#39;, {
    writable: false,
    value: &#39;male&#39;
  });

  console.table({name: Person.name, age: Person.age, sex: Person.sex});
  Person.name = &#39;es5-cname&#39;;
  console.table({name: Person.name, age: Person.age, sex: Person.sex});
  try {
    Person.sex = &#39;female&#39;;
    console.table({name: Person.name, age: Person.age, sex: Person.sex});
  } catch (e) {
    console.log(e);
  }
</code></pre>
<pre><code class="javascript">// ES6
  let Person = {
    name: &#39;es6&#39;,
    sex: &#39;male&#39;,
    age: 15
  };

  let person = new Proxy(Person, {
    get(target, key) {
      return target[key]
    },
    set(target,key,value){
      if(key!==&#39;sex&#39;){
        target[key]=value;
      }
    }
  });

  console.table({
    name:person.name,
    sex:person.sex,
    age:person.age
  });

  try {
    person.sex=&#39;female&#39;;
  } catch (e) {
    console.log(e);
  } finally {

  }
</code></pre>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[撸了一个canvas手写板]]></title>
      <url>/2018/03/08/canvasPalette/</url>
      <content type="html"><![CDATA[<p>用 canvas 写了一个手写板，功能：画笔粗细、橡皮擦大小、画笔颜色、清空画布、历史操作等</p>
<h2 id="canvas手写板"><a href="#canvas手写板" class="headerlink" title="canvas手写板"></a>canvas手写板</h2><ul>
<li><a href="https://zc95.github.io/demo/canvas.html">demo</a></li>
<li><a href="https://github.com/zc95/canvas" target="_blank" rel="external">github</a><a id="more"></a>
<h2 id="扫一扫"><a href="#扫一扫" class="headerlink" title="扫一扫"></a>扫一扫</h2></li>
</ul>
<p><img width="150" src="https://ws4.sinaimg.cn/large/006tNc79gy1fp5r4kgijtj307s07st9m.jpg"></p>
<hr>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp5tb8a00yj31401z40vt.jpg" height="600"></p>
<hr>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp5tb8s4tgj31401z4wjo.jpg" height="600"></p>
<hr>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp5tbmm3ytj31401z4wj1.jpg" height="600"></p>
]]></content>
      
        <categories>
            
            <category> demo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> canvas </tag>
            
            <tag> material design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自己写了个音乐播放器]]></title>
      <url>/2018/02/21/musicPlayer/</url>
      <content type="html"><![CDATA[<h2 id="material-design风格的音乐播放器"><a href="#material-design风格的音乐播放器" class="headerlink" title="material design风格的音乐播放器"></a>material design风格的音乐播放器</h2><ul>
<li><a href="https://zc95.github.io/demo/music.html">demo</a></li>
<li><a href="https://github.com/zc95/music" target="_blank" rel="external">github</a><a id="more"></a>
<h2 id="扫一扫"><a href="#扫一扫" class="headerlink" title="扫一扫"></a>扫一扫</h2></li>
</ul>
<p><img width="150" src="https://ws3.sinaimg.cn/large/006tNc79gy1fonxkcugj3j307s07sq2p.jpg"></p>
<hr>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fony99p9rfj30u01hcmzd.jpg" height="600"></p>
<hr>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fony8j721lj30u01hcwhv.jpg" height="600"></p>
<h2 id="HTML-5-audio标签"><a href="#HTML-5-audio标签" class="headerlink" title="HTML 5 audio标签"></a>HTML 5 audio标签</h2><h3 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h3><p> 标签定义声音，比如音乐或其他音频流，是 HTML 5 的新标签。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre><code class="html">&lt;audio src=&quot;https://music.163.com/song/media/outer/url?id=451703096.mp3&quot;&gt;
您的浏览器不支持 audio 标签。
&lt;/audio&gt;
</code></pre>
<h3 id="提示和注释"><a href="#提示和注释" class="headerlink" title="提示和注释"></a>提示和注释</h3><p>可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.w3school.com.cn/html5/att_audio_autoplay.asp" target="_blank" rel="external">autoplay</a></td>
<td>autoplay</td>
<td>如果出现该属性，则音频在就绪后马上播放。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/html5/att_audio_controls.asp" target="_blank" rel="external">controls</a></td>
<td>controls</td>
<td>如果出现该属性，则向用户显示控件，比如播放按钮。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/html5/att_audio_loop.asp" target="_blank" rel="external">loop</a></td>
<td>loop</td>
<td>如果出现该属性，则每当音频结束时重新开始播放。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/html5/att_audio_preload.asp" target="_blank" rel="external">preload</a></td>
<td>preload</td>
<td>如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/html5/att_audio_src.asp" target="_blank" rel="external">src</a></td>
<td><em>url</em></td>
<td>要播放的音频的 URL。</td>
</tr>
</tbody>
</table>
<h2 id="Javascript控制html5-Audio标签"><a href="#Javascript控制html5-Audio标签" class="headerlink" title="Javascript控制html5 Audio标签"></a>Javascript控制html5 Audio标签</h2><h3 id="javascript动态创建audio标签"><a href="#javascript动态创建audio标签" class="headerlink" title="javascript动态创建audio标签"></a>javascript动态创建audio标签</h3><pre><code class="javascript">var audio=document.creatElement(&quot;audio&quot;);
audio.src=&quot;audio/source.ogg&quot;;//路径
audio.play();
</code></pre>
<p>or</p>
<pre><code class="javascript">audio=new Audio(&quot;audio/source.ogg&quot;);//路径
audio.play();
</code></pre>
<h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>我们可以通过preload=”auto”来实现音频的自动加载，但是我们无法知道音频加载的进度</p>
<p>这时候可以用canplaythrough来完成</p>
<pre><code class="javascript">var audio = document.createElement(&quot;audio&quot;);
audio.src = &quot;https://music.163.com/song/media/outer/url?id=451703096.mp3&quot;;
audio.addEventListener(&quot;canplaythrough&quot;, function () {
    alert(&#39;音频文件已经准备好，随时待命&#39;);
}, false);
</code></pre>
<p>第一次运行时间会长一些，第二次运行由于文件已经缓存到本地，所以会直接弹出提示框。</p>
<h3 id="javascript控制audio的播放，暂停，停止"><a href="#javascript控制audio的播放，暂停，停止" class="headerlink" title="javascript控制audio的播放，暂停，停止"></a>javascript控制audio的播放，暂停，停止</h3><pre><code class="javascript">function aPlay() {
    audio.play();
}
function aPause() {
    audio.pause();
}
function aStop() {
    audio.currentTime = 0;
    audio.pause();
}
function aSkip() {
    audio.currentTime = 50;
    audio.play();
 }
</code></pre>
<pre><code class="javascript">&lt;input type=&quot;button&quot; onclick=&quot;aPlay();&quot; value=&quot;播放音频&quot;&gt;
&lt;input type=&quot;button&quot; onclick=&quot;aPause();&quot; value=&quot;暂停音频&quot;&gt;
&lt;input type=&quot;button&quot; onclick=&quot;aStop();&quot; value=&quot;停止音频&quot;&gt;
&lt;input type=&quot;button&quot; onclick=&quot;aSkip();&quot; value=&quot;跳到第50秒&quot;&gt;
</code></pre>
<h3 id="javascript控制audio的声音大小"><a href="#javascript控制audio的声音大小" class="headerlink" title="javascript控制audio的声音大小"></a>javascript控制audio的声音大小</h3><blockquote>
<p>audio.volume = 0;//表示静音  </p>
<p>audio.volume = 1; //表示声音最大</p>
<p>audio.volume //返回当前音量，声音值在0-1之间</p>
</blockquote>
<h3 id="javascript控制audio的快进，快退，以及显示进度与时长"><a href="#javascript控制audio的快进，快退，以及显示进度与时长" class="headerlink" title="javascript控制audio的快进，快退，以及显示进度与时长"></a>javascript控制audio的快进，快退，以及显示进度与时长</h3><blockquote>
<p>audio.currentTime //控制audio的进度</p>
<p>audio.duration //返回当前音量的总时长</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> demo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> material design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[教你下载会员歌曲]]></title>
      <url>/2018/02/19/musicLink/</url>
      <content type="html"><![CDATA[<p>教你找歌曲的外链（要会员的歌曲都能下载🤪）</p>
<h2 id="什么是歌曲的外链？"><a href="#什么是歌曲的外链？" class="headerlink" title="什么是歌曲的外链？"></a>什么是歌曲的外链？</h2><p>我们手机里的歌曲都是下载好的mp3文件，比如说散就散.mp3，</p>
<p>而外链就比如 <a href="https://music.163.com/song/media/outer/url?id=523251118.mp3" target="_blank" rel="external">https://music.163.com/song/media/outer/url?id=523251118.mp3</a> 这样链接的形式。</p>
<a id="more"></a>
<h2 id="怎么免费下载会员歌曲？"><a href="#怎么免费下载会员歌曲？" class="headerlink" title="怎么免费下载会员歌曲？"></a>怎么免费下载会员歌曲？</h2><p>你应该注意到了《说散就散》在qq音乐和网易云都是要vip才能下载</p>
<p><img style="height:400px; display:inline-block;" src="https://ws4.sinaimg.cn/large/006tNc79gy1fom4irp01wj30nq1600x0.jpg"></p>
<p><img style="height:400px; display:inline-block;" src="https://ws1.sinaimg.cn/large/006tNc79gy1fom4m03u1bj30no15y77v.jpg"></p>
<p>这里以网易云音乐的网页版为例说一下”破解“的方法</p>
<p>这个外链下载会员歌曲的方法也是最近撸一个播放器的时候发现的 <a href="https://zc95.github.io/demo/music">https://zc95.github.io/demo/music</a> （还在改进，下次再说吧 ，逃。。。）</p>
<h2 id="废话少说，开始了"><a href="#废话少说，开始了" class="headerlink" title="废话少说，开始了"></a>废话少说，开始了</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>打开你电脑上的浏览器，输入 <a href="http://music.163.com" target="_blank" rel="external">http://music.163.com</a> ，网易云音乐官网，输入 “说散就散” 搜索，点第一个要钱的原唱！</p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>到了 <a href="http://music.163.com/#/song?id=523251118" target="_blank" rel="external">http://music.163.com/#/song?id=523251118</a> 这个页面</p>
<ol>
<li>这个什么 <code>生成外链播放器</code> 不用管，就是个iframe（一般用来博客里），点了提示没版权，放弃。。。</li>
<li>还有下载按钮，点了提示下载PC端和app，肯定还是要会员。。。放弃</li>
<li><strong>重点是url，有个?id = xxxxx ，原来百度云网页版的每首歌都有自己的id标识</strong></li>
</ol>
<p><img style="height:400px;" src="https://ws2.sinaimg.cn/large/006tNc79gy1fom543cxz3j317i0tgq8q.jpg"></p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>从url得到这首歌的id是 <code>523251118</code></p>
<p>所以这首歌的外链就是 <a href="https://music.163.com/song/media/outer/url?id=523251118.mp3" target="_blank" rel="external">https://music.163.com/song/media/outer/url?id=523251118.mp3</a> ，之后找到别的歌，把这个链接的id替换了就行，除了那种网易云没播放版权的，所有的都可以。</p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>打开电脑里的浏览器，输入 <a href="https://music.163.com/song/media/outer/url?id=523251118.mp3" target="_blank" rel="external">https://music.163.com/song/media/outer/url?id=523251118.mp3</a> 回车，这时候url被解析成好长的一段，不用管它，有上面的链接就足够了，点html5 video标签上的下载按钮就行啦（如下），移动端和Safari的video应该是没有下载按钮的。。。</p>
<video controls name="media"><source src="https://music.163.com/song/media/outer/url?id=523251118.mp3" type="audio/mpeg"></video>

<h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>如果是安卓机的就直接把这首歌导入到手机里去，qq音乐、网易云都会自动加到列表里去。</p>
<p>如果是iphone，，，那就没啥吊用了。。。。</p>
<hr>
<p>最后说一下，有很多方法下载这种会员歌曲，，发现这种方法是因为最近在手撸一个音乐播放器，需要用到这样的链接<a href="https://zc95.github.io/demo/music">https://zc95.github.io/demo/music</a> </p>
<p>不然才不费这么大劲。。毕竟我有破解版😂😂😂</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fom5ymxc3aj31ik11egs4.jpg" alt="https://ws1.sinaimg.cn/large/006tNc79gy1fom5ymxc3aj31ik11egs4.jpg"></p>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 歌曲 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Rich Text Format]]></title>
      <url>/2018/02/06/RTF/</url>
      <content type="html"><![CDATA[<p>自己写的一个移动端的富文本编辑器</p>
<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><ul>
<li><a href="https://htmlpreview.github.io/?https://github.com/zc95/RTF/blob/master/index.html" target="_blank" rel="external">demo</a></li>
<li><a href="https://github.com/zc95/RTF" target="_blank" rel="external">github</a><a id="more"></a>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fo74tsp0mij31401z4aeo.jpg" style="height:500px;"></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fo74ugdi9qj31401z4q72.jpg" style="height:500px;"><br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo74v4k9udj31401z40wu.jpg" style="height:500px;"></p>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> html </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一行代码实现星级评分]]></title>
      <url>/2018/01/23/star-rating/</url>
      <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fnqvphubb8j30lu0dodhh.jpg" alt=""></p>
<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><ul>
<li><a href="https://htmlpreview.github.io/?https://github.com/zc95/star-rating/blob/master/index.html" target="_blank" rel="external">demo</a></li>
<li><a href="https://github.com/zc95/star-rating" target="_blank" rel="external">github</a></li>
</ul>
<a id="more"></a>
<h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><pre><code class="css">.score_wrapper {
      display:inline-block;
      font-size: 45px;
      cursor: pointer;
      color: #dc2020;
      -webkit-user-select:none;
      -moz-user-select:none;
      -ms-user-select:none;
      user-select:none;
    }
</code></pre>
<h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><pre><code class="html">&lt;div class=&quot;score_wrapper&quot;&gt;&lt;/div&gt;
</code></pre>
<h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><pre><code class="javascript">    $(function () {
      ScoreInit(3); //初始化，参数是0～5的数字，代表星数，传空默认0颗星
    })
    //点击
    function ScoreInit(e) {
      Score((e == null) ? 0 : e); //传空默认0颗星
      $(&quot;.score_wrapper&quot;).bind(&#39;click&#39;, function (e) {
        var eachWidth = $(&quot;.score_wrapper&quot;).width() / 5; //计算出每个星星的长度
        var X = e.pageX - $(this).offset().left; //距离父容器的偏移距离
        var score = Math.floor(X / eachWidth) + 1; //分数
        Score((getScore() == score) ? 0 : score); //取消评分
      })
    }
    //评分
    function Score(rate) {
      $(&quot;.score_wrapper&quot;).html(&quot;★★★★★☆☆☆☆☆&quot;.slice(5 - rate, 10 - rate));
    }
    //获取评分
    function getScore() {
      var str = $(&quot;.score_wrapper&quot;).html(), num = 0;
      for (var i = 0; i &lt; str.length; i++) {
        if (str[i] == &quot;★&quot;) {
          num++
        }
      }
      return num;
    }
</code></pre>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> html </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[水平垂直居中]]></title>
      <url>/2018/01/10/centerAndmiddle/</url>
      <content type="html"><![CDATA[<h2 id="水平垂直居中（已知宽高）"><a href="#水平垂直居中（已知宽高）" class="headerlink" title="水平垂直居中（已知宽高）"></a>水平垂直居中（已知宽高）</h2><p>方法很多，这里就说一个不常见的</p>
<pre><code class="Html">&lt;div class=&quot;father&quot;&gt;
  &lt;div class=&quot;son&quot;&gt;
    &lt;p&gt;zc95.github.io&lt;/p&gt;
    &lt;p&gt;zc95.github.io&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="css">.father {
  position: relative;
  width: 300px;
  height: 300px;
  border: 1px solid black;
}

.son {
  position: absolute;
  width: 60px;
  height: 60px;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  margin: auto;
  border: 1px solid gray;
}
</code></pre>
<a id="more"></a>
<hr>
<h2 id="水平垂直居中（宽高不确定-伪元素）"><a href="#水平垂直居中（宽高不确定-伪元素）" class="headerlink" title="水平垂直居中（宽高不确定/伪元素）"></a>水平垂直居中（宽高不确定/伪元素）</h2><p>用伪元素和 inline-block / vertical-align 可以实现水平垂直居中</p>
<pre><code class="html">&lt;div class=&quot;father&quot;&gt;
  &lt;div class=&quot;son&quot;&gt;
    &lt;p&gt;zc95.github.io&lt;/p&gt;
    &lt;p&gt;zc95.github.io&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="css">.father {
  position:fixed;
  top:0;
  right:0;
  left:0;
  bottom:0;
  text-align: center;
  border: 1px solid black;
}

.father:before {
  content: &#39;&#39;;
  display: inline-block;
  height: 100%;
  vertical-align: middle;
  margin-right: -0.25em; /*去空隙*/
}

.son {
  display: inline-block;
  vertical-align: middle;
  border: 1px solid gray;
}
</code></pre>
<hr>
<h2 id="水平垂直居中（宽高不确定-flex）"><a href="#水平垂直居中（宽高不确定-flex）" class="headerlink" title="水平垂直居中（宽高不确定/flex）"></a>水平垂直居中（宽高不确定/flex）</h2><p>css弹性布局（flex）</p>
<pre><code class="html">&lt;div class=&quot;father&quot;&gt;
  &lt;div class=&quot;son&quot; style=&quot;display:inline-block;&quot;&gt;
    &lt;p&gt;zc95.github.io&lt;/p&gt;
    &lt;p&gt;zc95.github.io&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="css">.father {
  height: 300px;
  width: 100%;
  display: flex;
  align-items: center; /*定义body的元素垂直居中*/
  justify-content: center; /*定义body的里的元素水平居中*/
}
.son{
  border:1px solid gray;
}
</code></pre>
<hr>
<h2 id="水平垂直居中（宽高不确定-transform）"><a href="#水平垂直居中（宽高不确定-transform）" class="headerlink" title="水平垂直居中（宽高不确定/transform）"></a>水平垂直居中（宽高不确定/transform）</h2><p>CSS3的transform，通过设置div的transform: translate(-50%,-50%)，使得div向上平移（translate）自身高度的一半(50%)、自身宽度的一半(50%)</p>
<pre><code class="html">&lt;div class=&quot;son&quot;&gt;
  &lt;p&gt;zc95.github.io&lt;/p&gt;
  &lt;p&gt;zc95.github.io&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="css">.son {
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%,-50%);
  -moz-transform: translate(-50%,-50%);
  -ms-transform: translate(-50%,-50%);
  transform: translate(-50%,-50%);
  border: 1px solid gray;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 水平垂直居中 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ToDo 待办事宜app]]></title>
      <url>/2018/01/07/ToDo/</url>
      <content type="html"><![CDATA[<h2 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo"></a>ToDo</h2><p>最近做事情总是丢三落四，老忘记一些重要的事情，就突发奇想写了这个 <code>ToDo</code> 待办事宜的app。</p>
<ol>
<li><a href="https://htmlpreview.github.io/?https://github.com/zc95/ToDo/blob/master/index.html#" target="_blank" rel="external">项目地址</a></li>
<li><a href="https://github.com/zc95/ToDo" target="_blank" rel="external">github地址</a></li>
</ol>
<p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;display:inline-block;" src="https://ws2.sinaimg.cn/large/006tNc79gy1fn8bgdbyhbj30xr1o04b6.jpg" height="500px;"><br><img style="box-shadow:1px 1px 10px #888888;display:inline-block;" src="https://ws4.sinaimg.cn/large/006tNc79gy1fn8bo7m0uqj30xr1o0tgz.jpg" height="500px;"><br></p>


<a id="more"></a>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ol>
<li>可以添加待办事项到首页中，数据都是保存在本地localStorage的，只要不是手动删除或者换了设备，数据是永久保存的</li>
<li>点击事项可以将待办事项的状态改为 <code>选中</code> 和 <code>未选中</code> ，每次改变状态都会保存到localStorage，每天的开始都可以点 <code>重置所有状态</code> 的按钮来设置所有的待办事项为未选中</li>
<li>可以删除已添加的待办事项或者彻底删除所有本地localStorage数据</li>
</ol>
<p>可以复制项目链接在自己的浏览器中打开，然后添加到桌面，方便使用；<br><a href="https://htmlpreview.github.io/?https://github.com/zc95/ToDo/blob/master/index.html" target="_blank" rel="external">https://htmlpreview.github.io/?https://github.com/zc95/ToDo/blob/master/index.html</a></p>
]]></content>
      
        <categories>
            
            <category> demo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> localStorage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VMware服务器虚拟化]]></title>
      <url>/2017/12/26/VMware/</url>
      <content type="html"><![CDATA[<p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="https://ws2.sinaimg.cn/large/006tNc79gy1fmucwl7r2aj31hc0u0dng.jpg" width="90%;"><br></p>

<p>今天去机房打了一天酱油，听到了看到了一些没接触过的东西，做个简单的整理。</p>
<h2 id="VMware服务器虚拟化"><a href="#VMware服务器虚拟化" class="headerlink" title="VMware服务器虚拟化"></a>VMware服务器虚拟化</h2><p><a href="https://www.vmware.com/cn/solutions/virtualization.html" target="_blank" rel="external">VMware官网</a></p>
<p>大多数服务器的容量利用率不足 15%，这不仅导致了服务器数量剧增，还增加了复杂性。实现服务器虚拟化后，多个操作系统可以作为虚拟机在单台物理服务器上运行，并且每个操作系统都可以访问底层服务器的计算资源，从而解决效率低下问题。接下来将服务器集群聚合为一项整合资源，这可以提高整体效率并降低成本。服务器虚拟化还可以加快工作负载部署速度、提高应用性能以及改善可用性。</p>
<a id="more"></a>
<h3 id="虚拟化的优势"><a href="#虚拟化的优势" class="headerlink" title="虚拟化的优势"></a>虚拟化的优势</h3><p>虚拟化可以提高 IT 部门的敏捷性、灵活性和可扩展性，同时大幅节约成本。工作负载的部署速度更快、性能和可用性得到提升、运维实现自动化，所有这一切不仅简化了 IT 管理，还降低了拥有成本和运维成本。其他优势包括：</p>
<ol>
<li>降低资金成本和运维成本。</li>
<li>最大限度地减少或消除停机。</li>
<li>提高 IT 部门的工作效率、效益、敏捷性和响应能力。</li>
<li>更快地调配应用和资源。</li>
<li>支持业务连续性与灾难恢复。</li>
<li>简化数据中心管理。</li>
<li>构建真正的软件定义的数据中心</li>
</ol>
<h3 id="VMware-vSphere-client"><a href="#VMware-vSphere-client" class="headerlink" title="VMware vSphere client"></a>VMware vSphere client</h3><p>用来连接<a href="https://www.baidu.com/s?wd=VMware&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3rARvrjnvm19bPHfsnA790ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHT4P16dPHm3rjcdnW0drHnsPs" target="_blank" rel="external">VMware</a> ESXi主机和vCenter server，业内最完整、 最强健的虚拟化平台。创建资源池来管理计算、 网络和存储容量与易用性，并提供最高水平的服务，每个应用程序工作负载以最低的总成本。VSphere — — 取决于世界上要求最苛刻的数据中心虚拟化您业务关键型应用程序为空前的灵活性和可靠性。</p>
<h2 id="UPS电源"><a href="#UPS电源" class="headerlink" title="UPS电源"></a>UPS电源</h2><p><a href="https://baike.baidu.com/item/不间断电源" target="_blank" rel="external">百度百科</a></p>
<p>UPS电源一般指不间断电源。</p>
<p><a href="https://baike.baidu.com/item/UPS" target="_blank" rel="external">UPS</a>（Uninterruptible Power System/Uninterruptible Power Supply），即不间断<a href="https://baike.baidu.com/item/%E7%94%B5%E6%BA%90" target="_blank" rel="external">电源</a>，是将<a href="https://baike.baidu.com/item/%E8%93%84%E7%94%B5%E6%B1%A0" target="_blank" rel="external">蓄电池</a>（多为铅酸免维护蓄电池）与主机相连接，通过主机逆变器等模块电路将直流电转换成市电的系统设备。主要用于给单台<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="external">计算机</a>、计算机网络系统或其它<a href="https://baike.baidu.com/item/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E8%AE%BE%E5%A4%87" target="_blank" rel="external">电力电子设备</a>如电磁阀、压力变送器等提供稳定、不间断的电力供应。当市电输入正常时，UPS 将市电稳压后供应给<a href="https://baike.baidu.com/item/%E8%B4%9F%E8%BD%BD" target="_blank" rel="external">负载</a>使用，此时的UPS就是一台交流式电<a href="https://baike.baidu.com/item/%E7%A8%B3%E5%8E%8B%E5%99%A8" target="_blank" rel="external">稳压器</a>，同时它还向机内电池充电；当市电中断（事故停电）时， UPS 立即将电池的直流电能，通过逆变器切换转换的<a href="https://baike.baidu.com/item/%E6%96%B9%E6%B3%95" target="_blank" rel="external">方法</a>向负载继续供应220V<a href="https://baike.baidu.com/item/%E4%BA%A4%E6%B5%81%E7%94%B5" target="_blank" rel="external">交流电</a>，使负载维持正常工作并保护负载软、<a href="https://baike.baidu.com/item/%E7%A1%AC%E4%BB%B6" target="_blank" rel="external">硬件</a>不受损坏。UPS 设备通常对电压过高或电压过低都能提供保护。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><strong>UPS</strong>是针对中国电网环境和<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7" target="_blank" rel="external">网络监控</a>及<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="external">网络系统</a>、<a href="https://baike.baidu.com/item/%E5%8C%BB%E7%96%97" target="_blank" rel="external">医疗</a>系统等对<a href="https://baike.baidu.com/item/%E7%94%B5%E6%BA%90" target="_blank" rel="external">电源</a>的可靠性要求，克服中、大型<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="external">计算机</a>网络系统集中供电所造成的供电电网环境日益恶劣的问题，以全新的数字技术研制出的第三代工频纯在线式智能型UPS。直流电源，是维持电路中形成稳恒电流的装置。如干电池、蓄电池、<a href="https://baike.baidu.com/item/%E7%9B%B4%E6%B5%81%E5%8F%91%E7%94%B5%E6%9C%BA" target="_blank" rel="external">直流发电机</a>等。</li>
<li><strong>UPS</strong>和<a href="https://baike.baidu.com/item/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%BA%90" target="_blank" rel="external">直流电源</a>是企业重要的供电保障设备，传统的维护管理包括：①日常巡检外观，定期更换电池、<a href="https://baike.baidu.com/item/%E6%BB%A4%E6%B3%A2%E7%94%B5%E5%AE%B9" target="_blank" rel="external">滤波电容</a>、<a href="https://baike.baidu.com/item/%E9%A3%8E%E6%9C%BA" target="_blank" rel="external">风机</a>等易损件，大修时做电池活化等；②改造或采用换代设备，使用高级工具测试电池性能。这种管理方式企业投入成本高，维护人员工作量大，不易实时掌握设备运行状态和关键数据，设备事故预防能力低。实施在线维护管理可避免传统方式的不足之处，获得良好效益。</li>
<li><strong>UPS</strong>的中文意思为“不间断电源”，是英语“Uninterruptible Power System/Uninterruptible Power Supply”的缩写，它可以保障计算机系统在停电之后继续工作一段时间以使用户能够紧急<a href="https://baike.baidu.com/item/%E5%AD%98%E7%9B%98" target="_blank" rel="external">存盘</a>，使用户不致因停电而影响工作或丢失<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE" target="_blank" rel="external">数据</a>。</li>
</ol>
<hr>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p><a href="https://baike.baidu.com/item/cisco交换机" target="_blank" rel="external">百度百科</a></p>
<p>交换机（Switch）意为“<a href="https://baike.baidu.com/item/%E5%BC%80%E5%85%B3/2275072" target="_blank" rel="external">开关</a>”是一种用于电（光）信号转发的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87" target="_blank" rel="external">网络设备</a>。它可以为接入交换机的任意两个<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E8%8A%82%E7%82%B9" target="_blank" rel="external">网络节点</a>提供独享的电信号通路。最常见的交换机是<a href="https://baike.baidu.com/item/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA" target="_blank" rel="external">以太网交换机</a>。其他常见的还有电话语音交换机、<a href="https://baike.baidu.com/item/%E5%85%89%E7%BA%A4%E4%BA%A4%E6%8D%A2%E6%9C%BA" target="_blank" rel="external">光纤交换机</a>等。</p>
<p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="https://ws1.sinaimg.cn/large/006tNc79gy1fmudmq5dhvj31hc1han99.jpg" width="90%;"><br></p>

<p>图片上是 <code>Cisco Catalyst 4500-E Series</code> ，<a href="https://www.cisco.com/c/zh_cn/products/switches/catalyst-4500-x-series-switches/index.html?POSITION=SEM&amp;COUNTRY_SITE=cn&amp;CAMPAIGN=EN-04+Switches&amp;CREATIVE=APJC_GMP_EN-04_CN-Switches%2bSwitches%7cModel-45E&amp;REFERRING_SITE=Baidu&amp;KEYWORD=catalyst+4500E&amp;CCID=cc000010&amp;DTID=psebdu000360&amp;gclid=CMD8q-zEp9gCFVLZvAodLsEBXg&amp;gclsrc=ds" target="_blank" rel="external">Cisco Catalyst 4500-X 系列交换机</a></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>交换（switching）</strong>是按照通信两端传输信息的需要，用人工或设备自动完成的方法，把要传输的信息送到符合要求的相应路由上的技术的统称。根据工作位置的不同，可以分为<a href="https://baike.baidu.com/item/%E5%B9%BF%E5%9F%9F%E7%BD%91" target="_blank" rel="external">广域网</a>交换机和<a href="https://baike.baidu.com/item/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA" target="_blank" rel="external">局域网交换机</a>。广义的<strong>交换机（switch）</strong>就是一种在通信系统中完成信息交换功能的设备。</p>
<p>在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="external">计算机网络系统</a>中，交换概念的提出改进了共享工作模式。我们以前介绍过的HUB集线器就是一种共享设备，HUB本身不能识别目的地址，当同一局域网内的A主机给B主机传输数据时，<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85" target="_blank" rel="external">数据包</a>在以HUB为架构的网络上是以广播方式传输的，由每一台终端通过验证数据包头的地址信息来确定是否接收。也就是说，在这种工作方式下，同一时刻网络上只能传输一组<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%B8%A7" target="_blank" rel="external">数据帧</a>的通讯，如果发生碰撞还得重试。这种方式就是共享<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%B8%A6%E5%AE%BD" target="_blank" rel="external">网络带宽</a>。</p>
<hr>
<h2 id="hub"><a href="#hub" class="headerlink" title="hub"></a>hub</h2><p><a href="https://baike.baidu.com/item/HUB" target="_blank" rel="external">百度百科</a></p>
<p>HUB是一个多端口的<a href="https://baike.baidu.com/item/%E8%BD%AC%E5%8F%91%E5%99%A8" target="_blank" rel="external">转发器</a>，在以HUB为中心设备时，即使网络中某条线路产生了故障，并不影响其它线路的工作。所以HUB在<a href="https://baike.baidu.com/item/%E5%B1%80%E5%9F%9F%E7%BD%91" target="_blank" rel="external">局域网</a>中得到了广泛的应用。大多数的时候它用在星型与<a href="https://baike.baidu.com/item/%E6%A0%91%E5%9E%8B%E7%BD%91%E7%BB%9C" target="_blank" rel="external">树型网络</a>拓扑结构中，以RJ45接口与各主机相连（也有<a href="https://baike.baidu.com/item/BNC%E6%8E%A5%E5%8F%A3" target="_blank" rel="external">BNC接口</a>），HUB按照不同的说法有很多种类。 HUB按照对输入信号的处理方式上，可以分为无源HUB、有源HUB、智能HUB。</p>
<hr>
<h2 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h2><p><a href="https://baike.baidu.com/item/磁盘阵列" target="_blank" rel="external">百度百科</a></p>
<p>磁盘阵列（Redundant Arrays of Independent Disks，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。</p>
<p>磁盘阵列是由很多价格较便宜的<a href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98" target="_blank" rel="external">磁盘</a>，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。利用这项技术，将数据切割成许多区段，分别存放在各个硬盘上。</p>
<p>磁盘阵列还能利用同位检查（Parity Check）的观念，在<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84" target="_blank" rel="external">数组</a>中任意一个<a href="https://baike.baidu.com/item/%E7%A1%AC%E7%9B%98%E6%95%85%E9%9A%9C" target="_blank" rel="external">硬盘故障</a>时，仍可读出数据，在数据重构时，将数据经计算后重新置入新硬盘中。</p>
<hr>
<h2 id="堡垒机"><a href="#堡垒机" class="headerlink" title="堡垒机"></a>堡垒机</h2><p><a href="https://baike.baidu.com/item/堡垒机" target="_blank" rel="external">百度百科</a></p>
<p>堡垒机，即在一个特定的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83" target="_blank" rel="external">网络环境</a>下，为了保障网络和数据不受来自外部和内部用户的入侵和破坏，而运用各种技术手段实时收集和监控网络环境中每一个组成部分的系统状态、安全事件、网络活动，以便集中<a href="https://baike.baidu.com/item/%E6%8A%A5%E8%AD%A6" target="_blank" rel="external">报警</a>、及时处理及<a href="https://baike.baidu.com/item/%E5%AE%A1%E8%AE%A1/2140835" target="_blank" rel="external">审计</a>定责。</p>
<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>随着企事业单位IT系统的不断发展，网络规模和设备数量迅速扩大，日趋复杂的IT系统与不同背景的运维人员的行为给信息系统安全带来较大风险，主要表现在：</p>
<ol>
<li>多个用户使用同一个账号。这种情况主要出现在同一工作组中，由于工作需要，同时系统管理账号唯一，因此只能多用户共享同一账号。如果发生安全事故，不仅难以定位账号的实际使用者和责任人，而且无法对账号的使用范围进行有效控制，存在较大安全风险和隐患。</li>
</ol>
<ol>
<li><p>一个用户使用多个账号。目前，一个维护人员使用多个账号是较为普遍的情况，用户需要记忆多套口令同时在多套主机系统、网络设备之间切换，降低工作效率，增加工作复杂度。如下图所示：</p>
<p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="https://ws2.sinaimg.cn/large/006tNc79gy1fmuei2zoarj306405faa3.jpg" width="50%;"><br></p>
</li>
<li><p>缺少统一的权限管理平台，权限管理日趋繁重和无序；而且维护人员的权限大多是粗放管理，无法基于最小权限分配原则的用户权限管理，难以实现更细粒度的命令级权限控制，系统安全性无法充分保证。</p>
</li>
<li>无法制定统一的访问审计策略，审计粒度粗。各网络设备、主机系统、数据库是分别单独审计记录访问行为，由于没有统一审计策略，并且各系统自身审计日志内容深浅不一，难以及时通过系统自身审计发现违规操作行为和追查取证。</li>
<li>传统的网络安全审计系统无法对维护人员经常使用的SSH、RDP等加密、图形操作协议进行内容审计。</li>
</ol>
<h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><h4 id="单点登录功能"><a href="#单点登录功能" class="headerlink" title="单点登录功能"></a>单点登录功能</h4><p>支持对X11、linux、unix、数据库、网络设备、安全设备等一系列授权账号进行密码的自动化周期更改，简化密码管理，让使用者无需记忆众多系统密码，即可实现自动登录目标设备，便捷安全。[1]<a href=""> </a></p>
<h4 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h4><p>设备支持统一账户管理策略，能够实现对所有服务器、网络设备、安全设备等账号进行集中管理，完成对账号整个生命周期的监控，并且可以对设备进行特殊角色设置如：<a href="https://baike.baidu.com/item/%E5%AE%A1%E8%AE%A1/2140835" target="_blank" rel="external">审计</a>巡检员、<a href="https://baike.baidu.com/item/%E8%BF%90%E7%BB%B4" target="_blank" rel="external">运维</a>操作员、<a href="https://baike.baidu.com/item/%E8%AE%BE%E5%A4%87" target="_blank" rel="external">设备</a>管理员等自定义设置，以满足审计需求</p>
<h4 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h4><p>设备提供统一的认证接口，对用户进行认证，支持身份认证模式包括 动态口令、静态密码、硬件key 、生物特征等多种认证方式，设备具有灵活的定制接口，可以与其他第三方认证服务器之间结合；安全的认证模式，有效提高了认证的安全性和可靠性。</p>
<h4 id="资源授权"><a href="#资源授权" class="headerlink" title="资源授权"></a>资源授权</h4><p>设备提供基于用户、目标设备、时间、协议类型<a href="https://baike.baidu.com/item/IP/224599" target="_blank" rel="external">IP</a>、行为等要素实现细粒度的操作授权，最大限度保护用户资源的安全</p>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>设备支持对不同用户进行不同策略的制定，细粒度的访问控制能够最大限度的保护用户资源的安全，严防非法、越权访问事件的发生。</p>
<h4 id="操作审计"><a href="#操作审计" class="headerlink" title="操作审计"></a>操作审计</h4><p>设备能够对<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="external">字符串</a>、<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2/773307" target="_blank" rel="external">图形</a>、<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93" target="_blank" rel="external">文件传输</a>、<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="external">数据库</a>等全程操作行为审计；通过设备录像方式实时监控运维人员对操作系统、安全设备、网络设备、数据库等进行的各种操作，对违规行为进行事中控制。对终端指令信息能够进行精确搜索，进行录像精确定位。[2]<a href=""> </a></p>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VMware </tag>
            
            <tag> 服务器虚拟化 </tag>
            
            <tag> 堡垒机 </tag>
            
            <tag> 磁盘阵列 </tag>
            
            <tag> 交换机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript闭包]]></title>
      <url>/2017/12/21/javascriptClosure/</url>
      <content type="html"><![CDATA[<p>对于JavaScript的程序员来说，闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="external">MDN Closures</a></p>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>变量的作用域无非就是两种：全局变量和局部变量。当在函数中声明一个变量的时候，如果用关键字<code>var</code>来声明此变量，那么它就是局部变量，如果没有<code>var</code>那么就会成为全局变量。一般不建议用这种方式定义全局变量。而是用<code>var</code>将变量声明在函数的外面。</p>
<pre><code class="javascript">var name = &#39;小张&#39;;  // 全局变量
function func() {
    var name = &#39;小明&#39;;  // 局部变量
    age = 12;  // 全局变量，建议少用这种全局变量的定义方式
}
</code></pre>
<a id="more"></a>
<p>在JavaScript中，函数可以用来创造函数作用域。函数内部可以看到外面的变量，而外面看不到函数里的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，直到搜索到全局变量为止。</p>
<pre><code class="javascript">var a = 1;
var func1 = function(){
    var b = 2;
    var func2 = function(){
        var c = 3;
        console.log( b );  // 2
        console.log( a );  // 1
    } 
    func2();
    console.log( c );  // 报错：c is not defined
};
func1();
</code></pre>
<p>那么能不能从函数外部来访问局部变量呢？答案是可以。</p>
<pre><code class="javascript">var func = function() {
    var number = 6;
    return function() {
        return number;
    } 
};
console.log( func()() );  // 6
</code></pre>
<h2 id="变量的生存周期"><a href="#变量的生存周期" class="headerlink" title="变量的生存周期"></a>变量的生存周期</h2><p>全局变量的生存周期是永久的，除非我们主动的销毁这个全局变量。而对于局部变量来说，当退出函数时，这些局部变量就失去了生存的环境，所以会随着函数调用的结束而被销毁。<br>那么是否可以让局部变量在函数调用结束的时候不被销毁呢？来看下面这个例子：</p>
<pre><code class="javascript">var func = function() {
    var a = 1;
    return function() {
        a++;
        console.log( a );
    }  
};
var f = func();
f();  // 2
f();  // 3
f();  // 4
</code></pre>
<p>从上面这个输出结果，我们可以看到局部变量a并没有随着f()的调用而被销毁。这是因为全局变量f保存着对func里面匿名函数的引用。而这个匿名函数是可以访问到局部变量a的，所以自然a也被保存下来了。所以这种情况下局部变量的生存周期就得以延续。上面这个匿名函数其实就是一个闭包。再来看一个闭包的经典应用。</p>
<pre><code class="javascript">// 假设有5个div
var nodes = document.getElementsByTagName( &#39;div&#39; );
for ( var i = 0, l = nodes.length; i &lt; l; i++ ) {
    nodes[i].onclick = function() {
        console.log( i );
    }
}
</code></pre>
<p>当真正执行这段代码的时候，发现无论点击那个div，最后打印的结果都是4。这是因为onclick事件是异步触发的，当事件触发的时候，for循环早已经结束，此时变量i的值已经是4。解决方案可以是用闭包把每次的i都保存起来：</p>
<pre><code class="javascript">for ( var i = 0, l = nodes.length; i &lt; l; i++ ) {
    (function( i ) {
        nodes[i].onclick = function() {
            console.log( i );
        }
    })( i );
}
</code></pre>
<p>同理，我们编写一段代码用来判断对象类型：</p>
<pre><code class="javascript">var Type = {};
for ( var i = 0, type; type = [ &#39;String&#39;, &#39;Array&#39;, &#39;Number&#39; ][ i++ ]; ) {
    (function( type ) {
        Type[ &#39;is&#39; + type ] = function( obj ) {
            return Object.prototype.toString.call( obj ) === &#39;[object &#39; + type + &#39;]&#39;;
        }
    })( type );
}
Type.isArray( [] );  // true
Type.isString( &#39;str&#39; );  // true
</code></pre>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>官方的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因为这些变量也是该表达式的一部分。这个概念不好理解，我们可以简单得理解成闭包就是能够访问函数内部变量的函数。</p>
<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ul>
<li><p>可以在函数外部访问在函数内部定义的局部变量</p>
</li>
<li><p>延续局部变量的生存周期</p>
</li>
<li><p>封装变量<br>闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。假设有一个计算乘积的函数：</p>
<pre><code class="javascript">var mult = function() {
    var  a = 1;
    for ( var i = 0, l = arguments.length; i &lt; l; i++ ) {
        a = a * arguments[i];
    }
    return a;
};
mult(2, 3, 4);  // 24
</code></pre>
<p>mult函数接受一些<code>Number</code>类型的参数，并且返回他们的乘积。现再我们觉得对于那些相同参数来说，每次再进行计算是一种浪费，所以我们决定加入缓存机制来提高函数性能：</p>
<pre><code class="javascript">var cache = {};
var mult = function() {
    var args = Array.prototype.join.call( arguments, &#39;&#39; );
    if ( cache[ args ] ) {
        return cache[ args ];
    }
    var  a = 1;
    for ( var i = 0, l = arguments.length; i &lt; l; i++ ) {
        a = a * arguments[i];
    }
    return cache[ args ] = a;
};
</code></pre>
<p>我们看到cache这个变量仅仅在mult函数中被使用，所以为了避免cache污染全局变量，我们将它放到mult函数里面</p>
<pre><code class="javascript">var mult = (function() {
    var cache = {};
    return function() {
        var args = Array.prototype.join.call( arguments, &#39;&#39; );
        if ( cache[ args ] ) {
            return cache[ args ];
        }
        var  a = 1;
        for ( var i = 0, l = arguments.length; i &lt; l; i++ ) {
           a = a * arguments[i];
        }
        return cache[ args ] = a;
    }
})();
</code></pre>
<p>提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有利于代码的复用，如果这些小函数有一个良好的命名，那么它们本身就起到了一个很好的注释作用。</p>
<pre><code class="javascript">var mult = (function() {
    var cache = {};
    var calculate = function() {
        var  a = 1;
        for ( var i = 0, l = arguments.length; i &lt; l; i++ ) {
           a = a * arguments[i];
        }
        return a;
    };
    return function() {
        var args = Array.prototype.join.call( arguments, &#39;&#39; );
        if ( cache[ args ] ) {
            return cache[ args ];
        }
        return cache[ args ] = calculate.apply( null, arguments );
    }
})();
</code></pre>
</li>
</ul>
<h2 id="闭包与内存管理"><a href="#闭包与内存管理" class="headerlink" title="闭包与内存管理"></a>闭包与内存管理</h2><p>局部变量本来应该在函数退出的时候就被结束引用，但如果局部变量被封装在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上来看，闭包确实会使一些数据无法被及时销毁。如果将来需要回收这些变量，我们可以手动把这些变量设为<code>null</code>。<br>跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域中保存着一些DOM节点，这个时候就有可能造成内存泄露。在IE9之前的浏览器中，由于BOM和DOM中的对象是使用C++对象以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是引用计数策略。在基于引用计数的垃圾收集机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。但我们只要把循环引用中的对象设为<code>null</code>即可解决这个问题。</p>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>/2017/12/20/RegularExpression/</url>
      <content type="html"><![CDATA[<h2 id="PART-1-为什么使用正则表达式？"><a href="#PART-1-为什么使用正则表达式？" class="headerlink" title="PART 1-为什么使用正则表达式？"></a>PART 1-为什么使用正则表达式？</h2><ul>
<li><p>测试字符串内的模式</p>
<p>例如，可以测试输入字符串，以查看字符串内是否出现电话号码或信用卡号码模式。这称为数据验证</p>
</li>
<li><p>替换文本</p>
<p>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它</p>
</li>
<li><p>基于模式匹配从字符串中提取子字符串</p>
<p>可以查找文档内或输入域内特定的文本</p>
<a id="more"></a>
</li>
</ul>
<h2 id="PART-2-练习正则表达式"><a href="#PART-2-练习正则表达式" class="headerlink" title="PART 2-练习正则表达式"></a>PART 2-练习正则表达式</h2><p>我们可以在console控制台，regexper 或者 <code>IDE</code> 去练习正则表达式</p>
<ul>
<li><p>推荐一个JS正则可视化的在线工具，简单易懂：<a href="https://regexper.com" target="_blank" rel="external">regexper.com</a></p>
<p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="/img/regexper.png" width="90%;"><br></p>
</li>
<li><p>现在大部分IDE都会支持正则表达式匹配，如sublime：</p>
<p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="/img/sublimeRegexper.png" width="90%;"><br></p>


</li>
</ul>
<hr>
<h2 id="PART-3-举个🌰"><a href="#PART-3-举个🌰" class="headerlink" title="PART 3-举个🌰"></a>PART 3-举个🌰</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><blockquote>
<p>^[0-9]+abc$</p>
</blockquote>
<ul>
<li><code>^</code> 为匹配输入字符串的开始位置</li>
<li><code>[0-9]+</code> 匹配单个数字，<code>+</code> 匹配一个或者多个</li>
<li><code>abc$</code> 匹配字母 <code>abc</code> 结尾</li>
<li><code>$</code> 为匹配输入字符串的结束位置</li>
</ul>
<p>匹配以数字开头，并以abc结尾的字符串：</p>
<pre><code class="javascript">var str = &quot;123abc&quot;;
var patt1 = /^[0-9]+abc$/;
document.write(str.match(patt1));

==&gt; 123ABC
</code></pre>
<hr>
<h2 id="PART-4-基本正则字符"><a href="#PART-4-基本正则字符" class="headerlink" title="PART 4-基本正则字符"></a>PART 4-基本正则字符</h2><h3 id="基础字符含义"><a href="#基础字符含义" class="headerlink" title="基础字符含义"></a>基础字符含义</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="external">MDN Regular Expressions</a></p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\</td>
<td>转意，即通常在”\”后面的字符不按原来意义解释，如/b/匹配字符”b”，当b前面加了反斜杠后/\b/，转意为匹配一个单词的边界。</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td>匹配输入的开始<br><br> 例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。 当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#note" target="_blank" rel="external">补充字符集合</a>一节有详细介绍和示例。</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td>匹配输入的结束。 例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td>匹配前面元字符0次或多次，<strong>/ba*/</strong> 将匹配b,ba,baa,baaa ，相当于{0, } <br><br> 例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西。</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td>匹配前面元字符1次或多次，/ba+/将匹配ba,baa,baaa，相当于{1, } <br><br>例如，/a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td>匹配前面元字符0次或1次，相当于 {0,1}<br><br> 例如，/e?le?/ 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’<br><br> 如果<strong>紧跟在任何量词 *、 +、? 或 {} 的后面</strong>，将会使量词变为<strong>非贪婪</strong>的（匹配尽量少的字符），和缺省使用的<strong>贪婪模式</strong>（匹配尽可能多的字符）正好相反。<br><br> 例如，对 “123abc” 应用 /\d+/ 将会返回 “123”，如果使用 /\d+?/,那么就只会匹配到 “1”。<br> 还可以运用于先行断言，如本表的 <code>x(?=y)</code> 和 <code>x(?!y)</code> 条目中所述。</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td>匹配除换行符之外的任何单个字符<br><br> 例如，/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。</td>
</tr>
<tr>
<td style="text-align:center">x&#124;y</td>
<td>匹配x或y</td>
</tr>
<tr>
<td style="text-align:center">{n}</td>
<td>精确匹配n次</td>
</tr>
<tr>
<td style="text-align:center">{n,}</td>
<td>匹配n次以上</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td>匹配n-m次</td>
</tr>
<tr>
<td style="text-align:center"><strong>[^xyz ]</strong></td>
<td>字符集(character set)，匹配这个集合中的任一一个字符(或元字符)</td>
</tr>
<tr>
<td style="text-align:center">[\b]</td>
<td>匹配一个退格符</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td>匹配一个单词的边界</td>
</tr>
<tr>
<td style="text-align:center">\B</td>
<td>匹配一个非单词边界</td>
</tr>
<tr>
<td style="text-align:center">\cX</td>
<td>这儿，X是一个控制符，/\cM/匹配Ctrl-M</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td>匹配一个数字，/\d/ = /[0-9]/</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td>匹配一个非字数字符，/\D/ = /[ ^0-9]/</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td>匹配一个换页符</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td>匹配一个空白字符，包括\n,\r,\f,\t,\v等</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td>匹配一个非空白字符，等于 /[ ^\n\f\r\t\v]/</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td>匹配一个重直制表符</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td>匹配字母或数字或下划线，等于[a-zA-Z_0-9] ( 能不能匹配汉字要视你的操作系统和你的应用环境而定</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td>匹配一个不可以组成单词的字符，如[\W]匹配”5.98”中的，等于 [ ^a-zA-Z0-9]</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="PART-5-使用正则表达式"><a href="#PART-5-使用正则表达式" class="headerlink" title="PART 5-使用正则表达式"></a>PART 5-使用正则表达式</h2><p>正则表达式可以被用于<code>RegExp</code>的<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/RegExp/exec" target="_blank" rel="external"><code>exec</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/RegExp/test" target="_blank" rel="external"><code>test</code></a>方法以及 <a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String" target="_blank" rel="external"><code>String</code></a>的<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/match" target="_blank" rel="external"><code>match</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="external"><code>replace</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/search" target="_blank" rel="external"><code>search</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="external"><code>split</code></a>方法。这些方法在<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference" target="_blank" rel="external">JavaScript 手册</a>中有详细的解释。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>exec</code></td>
<td>一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。</td>
</tr>
<tr>
<td><code>test</code></td>
<td>一个在字符串中测试是否匹配的RegExp方法，它返回true或false。</td>
</tr>
<tr>
<td><code>match</code></td>
<td>一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。</td>
</tr>
<tr>
<td><code>search</code></td>
<td>一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。</td>
</tr>
<tr>
<td><code>replace</code></td>
<td>一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。</td>
</tr>
<tr>
<td><code>split</code></td>
<td>一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用最简单的代码实现点击查看大图]]></title>
      <url>/2017/11/29/enlargeImg/</url>
      <content type="html"><![CDATA[<p>今天做了个点击查看大图的功能，只需要给img加一个class，不用写额外的html代码</p>
<p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="/img/enlargeImg.png" width="90%;"><br></p>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><a href="https://htmlpreview.github.io/?https://github.com/zc95/enlargeImg/blob/master/index.html" target="_blank" rel="external">demo地址</a></li>
<li><a href="https://github.com/zc95/enlargeImg" target="_blank" rel="external">github地址</a><a id="more"></a>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2></li>
</ul>
<h3 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h3><pre><code class="html">&lt;img class=&quot;enlargeImg&quot; width=&quot;80&quot; src=&quot;https://zc95.github.io/img/avatar.png&quot;
title=&quot;点击查看大图&quot; /&gt;
</code></pre>
<p>重点：</p>
<ul>
<li>img标签</li>
<li>class=”enlargeImg”</li>
<li>限制图片宽度或高度为”小图片”，width=”80”</li>
<li>src有值</li>
<li>title=”点击查看大图”</li>
</ul>
<h3 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h3><pre><code class="css">.enlargeImg_wrapper {
  display: none;
  position: fixed;
  z-index: 999;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-repeat: no-repeat;
  background-attachment: fixed;
  background-position: center;
  background-color: rgba(52, 52, 52, 0.8);
  background-size: 50%;
}

img:hover,
.enlargeImg_wrapper:hover {
  cursor: pointer;
}
</code></pre>
<p>重点：</p>
<ul>
<li>半透明遮罩层 background-color: rgba(52, 52, 52, 0.8);</li>
<li>水平垂直居中 background-position: center;</li>
<li>放大后的图片大小 background-size: 50%;</li>
<li>如果受页面中别的定位元素的z-index影响，改z-index的值就行</li>
</ul>
<h3 id="js部分"><a href="#js部分" class="headerlink" title="js部分"></a>js部分</h3><pre><code class="javascript">$(function() {
  enlargeImg();
})
//查看大图
function enlargeImg() {
  $(&quot;.enlargeImg&quot;).click(function() {
    $(this).after(&quot;&lt;div onclick=&#39;closeImg()&#39; class=&#39;enlargeImg_wrapper&#39;&gt;&lt;/div&gt;&quot;);
    var imgSrc = $(this).attr(&#39;src&#39;);
    $(&quot;.enlargeImg_wrapper&quot;).css(&quot;background-image&quot;, &quot;url(&quot; + imgSrc + &quot;)&quot;);
    $(&#39;.enlargeImg_wrapper&#39;).fadeIn(200);
  })
}
//关闭并移除图层
function closeImg() {
  $(&#39;.enlargeImg_wrapper&#39;).fadeOut(200).remove();
}
</code></pre>
<p>重点：</p>
<ul>
<li>点击class为 <code>enlargeImg</code> 的图片时获取它的路径，var imgSrc = $(this).attr(‘src’);</li>
<li>创建遮罩层，$(this).after(“<div onclick="closeImg()" class="enlargeImg_wrapper"></div>“);</li>
<li>赋值给 <code>enlargeImg_wrapper</code> ，$(“.enlargeImg_wrapper”).css(“background-image”, “url(“ + imgSrc + “)”);</li>
<li>关闭遮罩层时移除遮罩层，$(‘.enlargeImg_wrapper’).fadeOut(200).remove();</li>
</ul>
]]></content>
      
        <categories>
            
            <category> demo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[更改hosts文件来更好地使用github]]></title>
      <url>/2017/11/28/hostsChange/</url>
      <content type="html"><![CDATA[<p>最近可能是网不太好，hexo d的时候总是提交不了，很苦恼，试了n多种方法。。。</p>
<h2 id="hexo-d时报错"><a href="#hexo-d时报错" class="headerlink" title="hexo d时报错"></a>hexo d时报错</h2><pre><code class="bash">fatal: unable to access&#39;https://github.com/zc95/zc95.github.io.git/ &#39;: Could not
resolve host: github.com
FATAL Something&#39;s wrong.Maybe you can find the solution here:http:hexo.io/docs/troubleshooting.html
...
</code></pre>
<h2 id="命令行终端-ping-github-com"><a href="#命令行终端-ping-github-com" class="headerlink" title="命令行终端 ping github.com"></a>命令行终端 ping github.com</h2><p>打开命令行终端，输入 <code>ping github.com</code> 并回车</p>
<blockquote>
<p>ping github.com</p>
</blockquote>
<a id="more"></a>
<p>如果像下面这样ping不出，就继续往下看吧</p>
<pre><code class="bash">ping github.com
PING github.com (192.30.255.113): 56 data bytes
Request timeout
Request timeout for icmp_seq 0
Request timeout for icmp_seq 1
Request timeout for icmp_seq 2
Request timeout for icmp_seq 3
Request timeout for icmp_seq 4
Request timeout for icmp_seq 5
...
</code></pre>
<h2 id="Ping-github-com"><a href="#Ping-github-com" class="headerlink" title="Ping github.com"></a>Ping github.com</h2><ol>
<li>打开链接 <a href="http://ping.chinaz.com" target="_blank" rel="external">http://ping.chinaz.com</a> 输入 <code>github.com</code> ,点击Ping检测</li>
<li>选择一条TTL值最小的ip地址，例如：<code>192.30.255.113</code> </li>
</ol>
<h2 id="修改hosts"><a href="#修改hosts" class="headerlink" title="修改hosts"></a>修改hosts</h2><ol>
<li>点击Finder - 前往 - 前往文件夹… - 输入 <code>/etc/hosts</code> 点击前往</li>
<li>找到hosts文件，修改hosts文件需要管理员权限，所以不能单纯修改，先按住hosts文件拖到桌面，双击打开桌面上的hosts文件</li>
<li>在 <code>127.0.0.1 localhost</code> 下面另起一行输入 <code>192.30.255.113 github.com</code> ，保存并退出</li>
<li>将桌面的hosts文件拖回直原来的位置，他会提示你 <strong>修改”etc”需要管理员密码</strong> ，点击”鉴定”，会提示你是否覆盖原文件，点击”是”，输入密码或指纹，ok了</li>
<li>再次在命令行终端  <code>ping github.com</code>  就能看到ping成功了</li>
<li>可以愉快的deploy了</li>
</ol>
<hr>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="什么是hosts？"><a href="#什么是hosts？" class="headerlink" title="什么是hosts？"></a>什么是hosts？</h3><blockquote>
<p>Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D" target="_blank" rel="external">域名</a>与其对应的<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80" target="_blank" rel="external">IP地址</a>建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从<a href="https://baike.baidu.com/item/Hosts%E6%96%87%E4%BB%B6" target="_blank" rel="external">Hosts文件</a>中寻找对应的<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80" target="_blank" rel="external">IP地址</a>，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90" target="_blank" rel="external">域名解析</a>服务器进行IP地址的解析。</p>
</blockquote>
<h3 id="每次改完配置需要重启机器吗？"><a href="#每次改完配置需要重启机器吗？" class="headerlink" title="每次改完配置需要重启机器吗？"></a>每次改完配置需要重启机器吗？</h3><blockquote>
<p>不需要，它实质上是个文本文件，当计算机需要解析地址时，会首先检查此文件，读取后再确定是本地解析还是要发送到DNS服务器来解析。<br>改后，只要再上网，就会生效。</p>
</blockquote>
<h3 id="hosts文件在哪里"><a href="#hosts文件在哪里" class="headerlink" title="hosts文件在哪里?"></a>hosts文件在哪里?</h3><pre><code>Linux:/etc/hosts
Mac OS X:/etc/hosts
Android:/etc/hosts
Windows:C:/windows/System32/drivers/etc/hosts
</code></pre><h3 id="hosts文件规则"><a href="#hosts文件规则" class="headerlink" title="hosts文件规则?"></a>hosts文件规则?</h3><pre><code>#ip地址           域名
127.0.0.1         localhost
192.30.255.113   github.com
255.255.255.255     broadcasthost
::1              localhost
</code></pre>]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> github </tag>
            
            <tag> hosts </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于float清除浮动和inline-block出现空隙的问题]]></title>
      <url>/2017/11/26/floatAndInlineBlock/</url>
      <content type="html"><![CDATA[<p>最近在写项目的时候手写了一个简单选项卡，遇到这类布局，最常见、最快速的布局方式就是display:inline-block;和float:left; </p>
<p></p><p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="/img/inlineBlockKX.png" width="90%;"><br></p><br>但我们都知道 <code>display:inline-block</code> 布局会出现空隙的问题，<code>float:left</code>  又要清除浮动，本文就这两个问题整理出解决方案。<br><a id="more"></a><p></p>
<h2 id="display-inline-block去掉空隙"><a href="#display-inline-block去掉空隙" class="headerlink" title="display:inline-block去掉空隙"></a>display:inline-block去掉空隙</h2><h3 id="移除标签间的空格"><a href="#移除标签间的空格" class="headerlink" title="移除标签间的空格"></a>移除标签间的空格</h3><pre><code class="html">&lt;ul class=&quot;tab-wrapper&quot;&gt;
  &lt;li class=&quot;tab-item active&quot;&gt;项目一&lt;/li&gt;&lt;li class=&quot;tab-item&quot;&gt;项目二&lt;/li&gt;&lt;li class=&quot;tab-item&quot;&gt;项目三&lt;/li&gt;&lt;li class=&quot;tab-item&quot;&gt;项目四&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>这个方法是我最初学html时知道的方法，当时觉得挺方便的，现在工作了觉得这个方法好蠢😂，一个代码格式化就能毁了它，这样不易维护的代码太脆弱了；</p>
<h3 id="去掉闭合标签"><a href="#去掉闭合标签" class="headerlink" title="去掉闭合标签"></a>去掉闭合标签</h3><pre><code class="html">&lt;ul class=&quot;tab-wrapper&quot;&gt;
  &lt;li class=&quot;tab-item active&quot;&gt;项目一
  &lt;li class=&quot;tab-item&quot;&gt;项目二
  &lt;li class=&quot;tab-item&quot;&gt;项目三
  &lt;li class=&quot;tab-item&quot;&gt;项目四
&lt;/ul&gt;
</code></pre>
<p>这个方法算是种好方法，最后一个li的闭合标签可有可无，也能很好的解决空隙问题，但依然还是代码不易维护的问题。</p>
<h3 id="font-size-0"><a href="#font-size-0" class="headerlink" title="font-size:0;"></a>font-size:0;</h3><pre><code class="html">&lt;ul class=&quot;tab-wrapper&quot;&gt;
  &lt;li class=&quot;tab-item active&quot;&gt;项目一&lt;/li&gt;
  &lt;li class=&quot;tab-item&quot;&gt;项目二&lt;/li&gt;
  &lt;li class=&quot;tab-item&quot;&gt;项目三&lt;/li&gt;
  &lt;li class=&quot;tab-item&quot;&gt;项目四&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<pre><code class="css">.tab-wrapper{
  font-size:0; /*父容器font-size为0*/
  -webkit-text-size-adjust:none; /*Chrome有最小字体大小限制，考虑到兼容性需要取消字体大小限制*/
}
.tab-wrapper .tab-item{
  display:inline-block;
  font-size:13px; /*这里比较重要，因为子元素会继承父元素的字体大小，这里要恢复正常font-size*/
  padding:5px 12px;
}
</code></pre>
<p>这个方法方法好理解，比较主流的解决方案；</p>
<h2 id="float-清除浮动"><a href="#float-清除浮动" class="headerlink" title="float 清除浮动"></a>float 清除浮动</h2><h3 id="空标签"><a href="#空标签" class="headerlink" title="空标签 "></a>空标签 <div style="clear:both;"></div></h3><pre><code class="css">&lt;div class=&quot;box-wrapper&quot;&gt;
    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
    &lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="最佳方法"><a href="#最佳方法" class="headerlink" title="最佳方法"></a>最佳方法</h3><pre><code class="css">/* 全浏览器通用的clearfix方案【推荐 */
/* 引入了zoom以支持IE6/7 */
/* 同时加入:before以解决现代浏览器上边距折叠的问题 */
.clearfix:before,
.clearfix:after {
    display: table;
    content: &quot; &quot;;
}
.clearfix:after {
    clear: both;
}
.clearfix{
    *zoom: 1;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于 GitHub Issues 的评论系统：gitment]]></title>
      <url>/2017/11/23/gitment/</url>
      <content type="html"><![CDATA[<h2 id="如何为hexo博客添加评论功能"><a href="#如何为hexo博客添加评论功能" class="headerlink" title="如何为hexo博客添加评论功能"></a>如何为<a href="https://zc95.github.io/2017/10/20/hexoBlog/">hexo</a>博客添加评论功能</h2><p>多说、友言、Disqus、livere(来比力)、gitment、畅言、valine基本都可以实现，但有些已经关闭，有些需要翻墙</p>
<p>本文讲的是一款基于 GitHub Issues 的评论系统：gitment 。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown语法 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h2 id="gitment"><a href="#gitment" class="headerlink" title="gitment"></a>gitment</h2><h3 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h3><p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="/img/gitmentPC.png" width="90%;"><br></p>        



<hr>
<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="/img/gitmentYD.png" width="90%;"><br></p>

<hr>
<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>打开博客主题文件夹下的 <code>_config.yml</code> 文件，以我的为例：</p>
<pre><code>comment:
  type: gitment  # 启用哪种评论系统
  gitment:
    githubID: zc95  # 你的GitHub名称
    repo: zc95.github.io  # 你的GitHub名称.github.io
    ClientID: *********
    ClientSecret: *********
    lazy: false   # 这个我也不清楚 大概是懒加载的意思吧
</code></pre><p><code>githubID</code> 和 <code>repo</code> 都有了，就剩 <code>ClientID</code> 和 <code>ClientSecret</code> 了</p>
<hr>
<h2 id="注册OAuth-Application"><a href="#注册OAuth-Application" class="headerlink" title="注册OAuth Application"></a>注册OAuth Application</h2><p>通过地址<a href="https://github.com/settings/applications/new" target="_blank" rel="external">OAuth Application注册传送门</a>申请配置，注册一个新的 OAuth Application，其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 <a href="https://zc95.github.io">https://zc95.github.io</a>）</p>
<p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="/img/OAuthApplication.png" width="90%;"><br></p>

<hr>
<h2 id="获取ClientID与ClientSecret"><a href="#获取ClientID与ClientSecret" class="headerlink" title="获取ClientID与ClientSecret"></a>获取ClientID与ClientSecret</h2><p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="/img/OAuthApplicationId.png" width="90%;"><br></p>


<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>优点<ul>
<li>界面​简洁</li>
<li>与github绑定，方便注册，不用依赖脚本或插件</li>
<li>评论会出现在github项目中的Issues里，方便管理</li>
<li>支持Markdown全部语法和html标签（这个很厉害）</li>
</ul>
</li>
<li>缺点<ul>
<li>​每篇文章都需要手动点击initialize comments按钮来初始化评论，否则不能评论；</li>
<li>不支持图片（可以尝试用markdown或者img标签来实现）和表情（emoji可以用）</li>
<li>只能支持github登陆</li>
</ul>
</li>
</ul>
<hr>
<h2 id="最后更新"><a href="#最后更新" class="headerlink" title="最后更新"></a>最后更新</h2><p>最后还是选择了<a href="https://livere.com" target="_blank" rel="external">livere 来必力</a>，注册登陆需要翻墙（或许因为我网不好。。），一旦注册之后评论之类的就不需翻墙了，支持QQ、微信、微博、百度等登陆方式，本页拉到最底下就是来必力了，体验还是可以的。</p>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> gitment </tag>
            
            <tag> Issues </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的收藏]]></title>
      <url>/2017/11/21/Collection/</url>
      <content type="html"><![CDATA[<h2 id="我的博客"><a href="#我的博客" class="headerlink" title="我的博客"></a>我的博客</h2><h3 id="https-zc95-github-io"><a href="#https-zc95-github-io" class="headerlink" title="https://zc95.github.io"></a><a href="https://zc95.github.io">https://zc95.github.io</a></h3><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="jsrun在线代码编辑"><a href="#jsrun在线代码编辑" class="headerlink" title="jsrun在线代码编辑"></a><a href="http://jsrun.net" target="_blank" rel="external">jsrun在线代码编辑</a></h3><h3 id="tinypng压缩图片"><a href="#tinypng压缩图片" class="headerlink" title="tinypng压缩图片"></a><a href="https://tinypng.com" target="_blank" rel="external">tinypng压缩图片</a></h3><h3 id="Google翻译"><a href="#Google翻译" class="headerlink" title="Google翻译"></a><a href="https://translate.google.cn" target="_blank" rel="external">Google翻译</a></h3><h3 id="msdn-itellyou"><a href="#msdn-itellyou" class="headerlink" title="msdn.itellyou"></a><a href="https://msdn.itellyou.cn" target="_blank" rel="external">msdn.itellyou</a></h3><h3 id="MDN文档"><a href="#MDN文档" class="headerlink" title="MDN文档"></a><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">MDN文档</a></h3><a id="more"></a>
<h2 id="前端插件-amp-框架"><a href="#前端插件-amp-框架" class="headerlink" title="前端插件&amp;框架"></a>前端插件&amp;框架</h2><h3 id="echarts"><a href="#echarts" class="headerlink" title="echarts"></a><a href="hhttp://www.echartsjs.com" target="_blank" rel="external">echarts</a></h3><h3 id="layui"><a href="#layui" class="headerlink" title="layui"></a><a href="http://www.layui.com" target="_blank" rel="external">layui</a></h3><h3 id="阿里巴巴矢量图标图"><a href="#阿里巴巴矢量图标图" class="headerlink" title="阿里巴巴矢量图标图"></a><a href="http://www.iconfont.cn" target="_blank" rel="external">阿里巴巴矢量图标图</a></h3><h2 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h2><h3 id="freecodecamp"><a href="#freecodecamp" class="headerlink" title="freecodecamp"></a><a href="https://www.freecodecamp.cn" target="_blank" rel="external">freecodecamp</a></h3><h3 id="慕课网"><a href="#慕课网" class="headerlink" title="慕课网"></a><a href="https://www.imooc.com" target="_blank" rel="external">慕课网</a></h3><h3 id="前端菜鸟教程"><a href="#前端菜鸟教程" class="headerlink" title="前端菜鸟教程"></a><a href="http://www.runoob.com" target="_blank" rel="external">前端菜鸟教程</a></h3>]]></content>
      
        <categories>
            
            <category> 汇总篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 前端必备 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数组复习]]></title>
      <url>/2017/11/21/arrayReview/</url>
      <content type="html"><![CDATA[<h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><pre><code class="javascript">var ary = [1,23,4];
console.log(typeof ary); //输出结果是Object
</code></pre>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><pre><code class="javascript">var ary = [1,23,4];
console.log(ary instanceof Array)//true;
</code></pre>
<a id="more"></a>
<h3 id="原型链方法"><a href="#原型链方法" class="headerlink" title="原型链方法"></a>原型链方法</h3><pre><code class="javascript">var ary = [1,23,4];
console.log(ary.__proto__.constructor==Array);//true
console.log(ary.constructor==Array)//true 这两段代码是一样的
</code></pre>
<blockquote>
<p>以上三种方法都不太好，<code>instanceof</code> 和 <code>constructor</code> 判断的变量，必须在当前页面声明的，比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个arr，并将其赋值给父页面的一个变量，这时判断该变量，Array == object.constructor;会返回false；</p>
</blockquote>
<h3 id="正确方法"><a href="#正确方法" class="headerlink" title="正确方法"></a>正确方法</h3><pre><code class="javascript">var ary = [1,2,3,4];
function isArray(e){
return Object.prototype.toString.call(e)==&#39;[object Array]&#39;;
}
console.log(isArray(ary));
</code></pre>
<h3 id="自己封装的基本数据类型验证"><a href="#自己封装的基本数据类型验证" class="headerlink" title="自己封装的基本数据类型验证"></a>自己封装的基本数据类型验证</h3><pre><code class="javascript">var type = {
  isObj: function(o) {
    return Object.prototype.toString.call(o) == &quot;[object Object]&quot;;
  },
  isArray: function(o) {
    return Object.prototype.toString.call(o) == &quot;[object Array]&quot;;
  },
  isNull: function(o) {
    return Object.prototype.toString.call(o) == &quot;[object Null]&quot;;
  },
  isUndefined: function(o) {
    return Object.prototype.toString.call(o) == &quot;[object Undefined]&quot;;
  },
  isBoolean: function(o) {
    return Object.prototype.toString.call(o) == &quot;[object Boolean]&quot;;
  },
  isString: function(o) {
    return Object.prototype.toString.call(o) == &quot;[object String]&quot;;
  },
  isNumber: function(o) {
    return Object.prototype.toString.call(o) == &quot;[object Number]&quot;;
  },
  isDocument: function() {
    return Object.prototype.toString.call(o) == &quot;[object Document]&quot; || &quot;[object HTMLDocument]&quot;;
  }
}

------------------------------
&gt;console.log(type.isArray([1,2,3]));
&gt;true
</code></pre>
<h2 id="push-和pop"><a href="#push-和pop" class="headerlink" title="push()和pop()"></a>push()和pop()</h2><ul>
<li><code>push()</code> 向数组末尾添加任意个项并返回新数组的长度</li>
<li><code>pop()</code> 从数组末尾移除最后一项，减少数组的length值 （返回的是移除的项）</li>
</ul>
<h2 id="shift-和unshift"><a href="#shift-和unshift" class="headerlink" title="shift()和unshift()"></a>shift()和unshift()</h2><ul>
<li><p><code>unshift()</code> 向数组前端添加任意个项并返回新数组的长度</p>
</li>
<li><p><code>shift()</code> 从数组前端移除第一项，减少数组的length值 （返回的是移除的项）</p>
</li>
</ul>
<h2 id="重排序-sort-reverse"><a href="#重排序-sort-reverse" class="headerlink" title="重排序 sort() reverse()"></a>重排序 sort() reverse()</h2><pre><code class="javascript">function compare(a,b){
  return a-b;//升序
  //return b-a; 或者在升序方法之后使用reverse()反转数组
}
arr.sort(compare);
</code></pre>
<h2 id="操作方法-concat-slice-splice"><a href="#操作方法-concat-slice-splice" class="headerlink" title="操作方法 concat() slice() splice()"></a>操作方法 concat() slice() splice()</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p><code>concat()</code> 方法用于连接两个或多个数组，不会改变原始数组。</p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p><code>slice()</code> 方法可从已有的数组中返回选定的元素，不会改变原始数组。</p>
<blockquote>
<p>arrayObject.slice(start,end)</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>start</td>
<td>必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</td>
</tr>
<tr>
<td>end</td>
<td>可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</td>
</tr>
</tbody>
</table>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p><code>splice()</code> 方法向/从数组中添加/删除项目，然后返回被删除的项目，会改变原始数组。</p>
<blockquote>
<p>arrayObject.splice(index,howmany,item1,…..,itemX)</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</td>
</tr>
<tr>
<td>howmany</td>
<td>必需。要删除的项目数量。如果设置为 0，则不会删除项目。</td>
</tr>
<tr>
<td>item1, …, itemX</td>
<td>可选。向数组添加的新项目。</td>
</tr>
</tbody>
</table>
<h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><blockquote>
<p>indexOF() 从前往后查找，返回首次出现的位置（没有返回-1）</p>
</blockquote>
<h3 id="lastindexOf"><a href="#lastindexOf" class="headerlink" title="lastindexOf()"></a>lastindexOf()</h3><blockquote>
<p>lastindexOf() 从后往前查找，返回首次出现的位置（没有返回-1）</p>
</blockquote>
<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><blockquote>
<p>迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。</p>
</blockquote>
<ol>
<li>every(): 对数组中的每一项运行给定的函数，如果该函数对每一项都返回true，则结果返回true。</li>
<li>filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</li>
<li>forEach(): 对数组中的每一项运行给定函数，这个方法没有返回值。</li>
<li>map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li>some(): 对数组中的每一项运行给定函数，如果该函数任意一项返回true，则返回true。</li>
</ol>
<h3 id="every-和some"><a href="#every-和some" class="headerlink" title="every()和some()"></a>every()和some()</h3><pre><code class="javascript">var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
var everyResult = numbers.every(function(item, index, array) {
    return (item &gt; 2);
});
var someResult = numbers.some(function(item) {
    return (item &gt; 2);
});
console.log(everyResult);      //false
console.log(someResult);        //true
</code></pre>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><pre><code class="javascript">var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
var filterResult = numbers.filter(function(item) {
    return (item &gt; 2);
});

console.log(filterResult);  \\[3, 4, 5, 4, 3]
</code></pre>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><pre><code class="javascript">var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
var mapResult = numbers.map(function(item) {
    return (item * 2);
});

console.log(mapResult);     //[2, 4, 6, 8, 10, 8, 6, 4, 2]
</code></pre>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><pre><code class="javascript">var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
numbers.forEach(function(item, index, arr) {
    //这里执行一些操作
});
</code></pre>
]]></content>
      
        <categories>
            
            <category> 汇总篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[column]]></title>
      <url>/2017/11/11/column/</url>
      <content type="html"><![CDATA[<h2 id="CSS3多列"><a href="#CSS3多列" class="headerlink" title="CSS3多列"></a>CSS3多列</h2><p>CSS3 可以将文本内容设计成像报纸一样的多列布局，如下实例：</p>
<p><img src="http://sandbox.runjs.cn/uploads/rs/234/bxxwrmn8/fo2zxn7p.png" alt="示例"></p>
<h2 id="CSS3-多列属性"><a href="#CSS3-多列属性" class="headerlink" title="CSS3 多列属性"></a>CSS3 多列属性</h2><ul>
<li><code>column-count</code></li>
<li><code>column-gap</code></li>
<li><code>column-rule-style</code></li>
<li><code>column-rule-width</code></li>
<li><code>column-rule-color</code></li>
<li><code>column-rule</code></li>
<li><code>column-span</code></li>
<li><code>column-width</code></li>
</ul>
<a id="more"></a>
<h2 id="CSS3-创建多列"><a href="#CSS3-创建多列" class="headerlink" title="CSS3 创建多列"></a>CSS3 创建多列</h2><p><code>column-count</code> 属性指定了需要分割的列数</p>
<p>以下实例将 <code>&lt;div&gt;</code> 元素中的文本分为 3 列：</p>
<pre><code class="css">.newspaper
{
    -moz-column-count:3; /* Firefox */
    -webkit-column-count:3; /* Safari and Chrome */
    column-count:3;
}
</code></pre>
<pre><code class="html">&lt;div class=&quot;newspaper&quot;&gt;....................&lt;/div&gt;
</code></pre>
<p><a href="http://www.runoob.com/try/try.php?filename=trycss3_column-count" target="_blank" rel="external">尝试一下 »</a></p>
<h2 id="CSS3-多列中列与列间的间隙"><a href="#CSS3-多列中列与列间的间隙" class="headerlink" title="CSS3 多列中列与列间的间隙"></a>CSS3 多列中列与列间的间隙</h2><p><code>column-gap</code> 属性指定了列与列间的间隙</p>
<p>以下实例指定了列与列间的间隙为 40 像素：</p>
<pre><code class="css">.newspaper
{
    -moz-column-count:3; /* Firefox */
    -webkit-column-count:3; /* Safari and Chrome */
    column-count:3;

    -moz-column-gap:40px; /* Firefox */
    -webkit-column-gap:40px; /* Safari and Chrome */
    column-gap:40px;
}
</code></pre>
<pre><code class="html">&lt;div class=&quot;newspaper&quot;&gt;....................&lt;/div&gt;
</code></pre>
<p><a href="http://www.runoob.com/try/try.php?filename=trycss3_column-gap" target="_blank" rel="external">尝试一下 »</a></p>
<h2 id="CSS3-列边框"><a href="#CSS3-列边框" class="headerlink" title="CSS3 列边框"></a>CSS3 列边框</h2><p><code>column-rule-style</code> 属性指定了列与列间的边框样式：</p>
<pre><code class="css">.newspaper
{
    -webkit-column-rule-style: solid; /* Chrome, Safari, Opera */
    -moz-column-rule-style: solid; /* Firefox */
    column-rule-style: solid;
}
</code></pre>
<p><a href="http://www.runoob.com/try/try.php?filename=trycss3_column-rule-style" target="_blank" rel="external">尝试一下 »</a></p>
<p><code>column-rule-width</code> 属性指定了两列的边框厚度：</p>
<pre><code class="css">div {
    -webkit-column-rule-width: 1px; /* Chrome, Safari, Opera */
    -moz-column-rule-width: 1px; /* Firefox */
    column-rule-width: 1px;
}
</code></pre>
<p><a href="http://www.runoob.com/try/try.php?filename=trycss3_column-rule-width" target="_blank" rel="external">尝试一下 »</a></p>
<p><code>column-rule-color</code> 属性指定了两列的边框颜色：</p>
<pre><code class="css">div {
    -webkit-column-rule-color: lightblue; /* Chrome, Safari, Opera */
    -moz-column-rule-color: lightblue; /* Firefox */
    column-rule-color: lightblue;
}
</code></pre>
<p><a href="http://www.runoob.com/try/try.php?filename=trycss3_column-rule-color" target="_blank" rel="external">尝试一下 »</a></p>
<p><code>column-rule</code> 属性是 column-rule-* 所有属性的简写。</p>
<p>以下实例设置了列直接的边框的厚度，样式及颜色：</p>
<pre><code class="css">div {
    -webkit-column-rule: 1px solid lightblue; /* Chrome, Safari, Opera */
    -moz-column-rule: 1px solid lightblue; /* Firefox */
    column-rule: 1px solid lightblue;
}
</code></pre>
<p><a href="http://www.runoob.com/try/try.php?filename=trycss3_column-rule" target="_blank" rel="external">尝试一下 »</a></p>
<h2 id="指定元素跨越多少列"><a href="#指定元素跨越多少列" class="headerlink" title="指定元素跨越多少列"></a>指定元素跨越多少列</h2><p>以下实例指定 <code>&lt;h2&gt;</code> 元素跨越所有列：</p>
<pre><code class="css">h2 {
    -webkit-column-span: all; /* Chrome, Safari, Opera */
    column-span: all;
}
</code></pre>
<p><a href="http://www.runoob.com/try/try.php?filename=trycss3_column-span" target="_blank" rel="external">尝试一下 »</a></p>
<h2 id="指定列的宽度"><a href="#指定列的宽度" class="headerlink" title="指定列的宽度"></a>指定列的宽度</h2><p><code>column-width</code> 属性指定了列的宽度。</p>
<pre><code class="css">div {
    -webkit-column-width: 100px; /* Chrome, Safari, Opera */
    column-width: 100px;
}
</code></pre>
<p><a href="http://www.runoob.com/try/try.php?filename=trycss3_column-width" target="_blank" rel="external">尝试一下 »</a></p>
<h2 id="CSS3-多列属性-1"><a href="#CSS3-多列属性-1" class="headerlink" title="CSS3 多列属性"></a>CSS3 多列属性</h2><p>下表列出了所有 CSS3 的多列属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/cssref/css3-pr-column-count.html" target="_blank" rel="external">column-count</a></td>
<td>指定元素应该被分割的列数。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/cssref/css3-pr-column-fill.html" target="_blank" rel="external">column-fill</a></td>
<td>指定如何填充列</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/cssref/css3-pr-column-gap.html" target="_blank" rel="external">column-gap</a></td>
<td>指定列与列之间的间隙</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/cssref/css3-pr-column-rule.html" target="_blank" rel="external">column-rule</a></td>
<td>所有 column-rule-* 属性的简写</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/cssref/css3-pr-column-rule-color.html" target="_blank" rel="external">column-rule-color</a></td>
<td>指定两列间边框的颜色</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/cssref/css3-pr-column-rule-style.html" target="_blank" rel="external">column-rule-style</a></td>
<td>指定两列间边框的样式</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/cssref/css3-pr-column-rule-width.html" target="_blank" rel="external">column-rule-width</a></td>
<td>指定两列间边框的厚度</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/cssref/css3-pr-column-span.html" target="_blank" rel="external">column-span</a></td>
<td>指定元素要跨越多少列</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/cssref/css3-pr-column-width.html" target="_blank" rel="external">column-width</a></td>
<td>指定列的宽度</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/cssref/css3-pr-columns.html" target="_blank" rel="external">columns</a></td>
<td>设置 column-width 和 column-count 的简写</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css3 </tag>
            
            <tag> 布局 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[类似Windows文件的布局问题]]></title>
      <url>/2017/11/03/AdaptiveLayout/</url>
      <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如何做到类似windows文件的布局：无论如何改变窗口（屏幕）的大小，文件或者文件夹的大小都是固定的，不同的是一行显示的数目会有所变化；</p>
<h2 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h2><p>首先这类布局，肯定会先想到百分比的方法（最快的方法），在不同手机上看的话当然没区别，比如一行显示4个的话，那么一个就是25%，但如果放到ipad或者电脑上来看的话，就大的有些恐怖了</p>
<h2 id="百分比加-media布局"><a href="#百分比加-media布局" class="headerlink" title="百分比加@media布局"></a>百分比加@media布局</h2><p>同上，我们可以用@media的方法来解决不同类型设备的差异问题，也就是多写几行css的问题<br><a id="more"></a></p>
<h2 id="我的方法"><a href="#我的方法" class="headerlink" title="我的方法"></a>我的方法</h2><p><code>var eachWidth = $(document).width() / Math.floor($(document).width() / 80);</code></p>
<p>假如我想每个div都在80px左右，那么一行就可以放 <code>$(document).width() / 80</code> 个，用 <code>Math.floor</code> 向下取整之后可以去掉不满一个的零头，再用屏幕宽度除以这个取整后的个数，就能得到长度在80±10的eachWidth值了</p>
<p>下面是在控制台的不同手机屏幕大小下console出来的数据：</p>
<pre><code class="javascript">$(document).width() / Math.floor($(document).width() / 80) //iPad
--&gt; 85.33333333333333

$(document).width() / Math.floor($(document).width() / 80) //iPhone 6 Plus
--&gt; 82.8

$(document).width() / Math.floor($(document).width() / 80) //iPhone 6
--&gt; 93.75

$(document).width() / Math.floor($(document).width() / 80) //iPhone 5
--&gt; 80

$(document).width() / Math.floor($(document).width() / 80) //Nexus 6P
--&gt; 82.4
</code></pre>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><ul>
<li><p>移动端</p>
<p><img src="http://sandbox.runjs.cn/uploads/rs/234/bxxwrmn8/buju1.png" alt="iPhone"></p>
</li>
</ul>
<ul>
<li><p>iPad</p>
<p><img src="http://sandbox.runjs.cn/uploads/rs/234/bxxwrmn8/buju2.png" alt="iPad"></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> 页面布局 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[css换行问题]]></title>
      <url>/2017/10/25/wordBreak/</url>
      <content type="html"><![CDATA[<p>css实现强制不换行/自动换行/强制换行</p>
<h2 id="强制换行"><a href="#强制换行" class="headerlink" title="强制换行"></a>强制换行</h2><p><strong>按单词自动换行</strong></p>
<blockquote>
<p>p { word-wrap:break-word; }</p>
</blockquote>
<p><strong>强制按英文字母断行</strong> <code>需要将行内元素设置为块级元素</code> </p>
<blockquote>
<p>p { word-break:break-all; }</p>
</blockquote>
<a id="more"></a>
<h2 id="强制不换行"><a href="#强制不换行" class="headerlink" title="强制不换行"></a>强制不换行</h2><p><strong>强制不换行</strong></p>
<blockquote>
<p>p { white-space:nowrap; }</p>
</blockquote>
<p><strong>超出显示省略号</strong></p>
<blockquote>
<p>p { white-space:nowrap; text-overflow:ellipsis; overflow:hidden; }</p>
<p>一定要给文字的父容器</p>
<p>如果父容器是行级，一定要转成块级（一定要是 block，设置为 inline-block 无效）</p>
</blockquote>
<p><strong>white-space: <code>normal</code> <code>pre</code> <code>nowrap</code> <code>pre-wrap</code> <code>pre-line</code> <code>inherit</code> ;</strong> </p>
<blockquote>
<p>white-space 属性设置如何处理元素内的空白 </p>
</blockquote>
<ul>
<li>normal 默认。多个空白或者多个换行将被当一个空白或一个换行处理- pre 空白和换行会被浏览器保留。其行为方式类似 HTML 中的 pre 标签- nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止- pre-wrap 保留空白符序列，但是正常地进行换行 - pre-line 合并空白符序列，但是保留换行符- inherit 规定应该从父元素继承 white-space 属性的值<br><strong>word-break: <code>normal</code> <code>break-all</code> <code>keep-all</code> ;</strong> <blockquote>
<p>word-break 属性用来标明怎么样进行单词内的断句</p>
</blockquote>
</li>
<li>normal：使用浏览器默认的换行规则- break-all:允许再单词内换行 - keep-all:只能在半角空格或连字符处换行</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> html </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[表头固定]]></title>
      <url>/2017/10/24/amazingTable/</url>
      <content type="html"><![CDATA[<p>table的表头固定 ——— 上下滚动表头固定，左右滚动表头跟随滚动</p>
<h2 id="关于表格固定"><a href="#关于表格固定" class="headerlink" title="关于表格固定"></a>关于表格固定</h2><p>如果数据不是很多，一般都是用两个表格，一个放thead，另一个放tbody，这个没难度就不再赘述了</p>
<p>如果数据很多就要考虑左右滚动的情况了<br><a id="more"></a></p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>demo: <a href="http://jsrun.net/biiKp/show" target="_blank" rel="external">http://jsrun.net/biiKp/show</a></p>
<p>同样是两个table，一个放thead，另一个放tbody，用两个div分别包裹起来</p>
<p>这两个div依赖于他们的的父容器进行absolute定位</p>
<blockquote>
<p>theadDiv {</p>
<p> position: absolute;<br> left: 0;<br> right: 0;<br> overflow: hidden; //这里hidden是用于隐藏滚动条<br>}</p>
<p>tbodyDiv {</p>
<p> position: absolute;<br> top: 35px;<br> left: 0;<br> right: 0;<br> bottom: 0;<br> overflow: auto;<br>}</p>
</blockquote>
<p>给放置thead的div添加样式 <code>overflow: hidden;</code> ，表头不需要看到滚动条</p>
<p>给放置tbody的div添加样式 <code>overflow: auto;</code> ，表的主体需要滚动条</p>
<p>这时只需要在滚动下面的tbody时，同样滚动上面的thead就行</p>
<blockquote>
<p>$(‘#tbodyDiv’).on(‘scroll’, function () {</p>
<p>  $(“#theadDiv”).scrollLeft($(‘#tbodyDiv’).scrollLeft());</p>
<p>  });</p>
<p>})</p>
</blockquote>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>demo: <a href="http://jsrun.net/2iiKp/show" target="_blank" rel="external">http://jsrun.net/2iiKp/show</a></p>
<ol>
<li>大概思路就是  <code>容器A</code> 下面有 <code>容器1（放置thead）</code> 和 <code>容器2（放置tbody）</code></li>
<li>x轴滚动条属于 <code>容器A</code> ，滚动 <code>容器1（放置thead）</code> 和 <code>容器2（放置tbody）</code></li>
<li>y轴属于 <code>容器2</code> ，滚动 <code>tbody</code></li>
</ol>
<p>这个方法有缺陷，就是y轴的滚动条必须要当x轴滚到最右边才看得到，当然Mac下无差（Mac下的滚动条不滚动的时候是隐藏的，而win系统下就会影响美观，但都不影响操作，毕竟我们有鼠标滚轮）</p>
]]></content>
      
        <categories>
            
            <category> demo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DOM]]></title>
      <url>/2017/10/21/DOM/</url>
      <content type="html"><![CDATA[<p>为什么我们要尽量少的去操作DOM结构？</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前端开发的过程中，javascript极为重要的一个功能就是对DOM对象的操作，无论增删改查在前端页面操作这一范围内都是比较消耗性能的。如何高效率的，便捷的操作DOM，这就是本文要讲述的，希望看完全文，你能知道如何更高效的通过原生js以及jQuery操作DOM元素。</p>
<h2 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h2><ol>
<li>DOM修改导致的页面重绘<code>repaint</code>、重构<code>reflow</code>，重新排版是用户阻塞的操作，同时，如果频繁重排，CPU使用率也会猛涨</li>
<li>repaint意味着样式的改变比如div调整了背景色等，但是位置不变，只改变我们操作的元素</li>
<li>reflow意味着结构的改变，比如一堆元素堆叠，改变其中一个的宽高，那么相应的所有元素的位置都要改变</li>
<li>所以通常来看repaint的代价要远小于reflow，速度也更快<a id="more"></a>
<h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2></li>
</ol>
<h3 id="能放到DOM操作之外的操作就放到外面，DOM操作要尽量少"><a href="#能放到DOM操作之外的操作就放到外面，DOM操作要尽量少" class="headerlink" title="能放到DOM操作之外的操作就放到外面，DOM操作要尽量少"></a>能放到DOM操作之外的操作就放到外面，DOM操作要尽量少</h3><p>这是一个不好的事例：</p>
<pre><code class="javascript">var $obj = $(&quot;#obj&quot;);
var data = [{&quot;id&quot;:0,&quot;name&quot;:&quot;a&quot;},{&quot;id&quot;:1,&quot;name&quot;:&quot;b&quot;}];
for (var i = 0; i &lt; data.length; i++) {
    $obj.append(&#39;&lt;option value=&quot;&#39;+data[i].id+&#39;&quot;&gt;&#39;+data[i].name+&#39;&lt;/option&gt;&#39;);
};
</code></pre>
<p>更好的做法，使用容器存放临时变更，最后再一次性更新DOM：</p>
<pre><code class="javascript">var $obj = $(&quot;#obj&quot;);
var data = [{&quot;id&quot;:0,&quot;name&quot;:&quot;a&quot;},{&quot;id&quot;:1,&quot;name&quot;:&quot;b&quot;}];
var tempStr = &quot;&quot;;
for (var i = 0; i &lt; data.length; i++) {
    tempStr +=(&#39;&lt;option value=&quot;&#39;+data[i].id+&#39;&quot;&gt;&#39;+data[i].name+&#39;&lt;/option&gt;&#39;);
};
$obj.html(tempStr);
</code></pre>
<h3 id="大范围操作先把容器隐藏，在其中操作完成后再显示"><a href="#大范围操作先把容器隐藏，在其中操作完成后再显示" class="headerlink" title="大范围操作先把容器隐藏，在其中操作完成后再显示"></a>大范围操作先把容器隐藏，在其中操作完成后再显示</h3><p>这个也算是优化的一种，这原理涉及到浏览器加载和渲染的原理,简单说就是隐藏的元素其中不会产生reflow</p>
<h3 id="样式操作不要注意修改属性，直接替换class"><a href="#样式操作不要注意修改属性，直接替换class" class="headerlink" title="样式操作不要注意修改属性，直接替换class"></a>样式操作不要注意修改属性，直接替换class</h3><p>这个还是比较容易理解的，你逐一修改要访问很多次，而替换class就相当于批量操作了，访问一次DOM就可以了,当然性能提高了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于性能方面，平时应注意积累。</p>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> html </tag>
            
            <tag> javascript </tag>
            
            <tag> jquery </tag>
            
            <tag> DOM操作 </tag>
            
            <tag> 循环 </tag>
            
            <tag> 渲染 </tag>
            
            <tag> 性能 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[文本框模糊查询]]></title>
      <url>/2017/10/21/input/</url>
      <content type="html"><![CDATA[<p>文本框模糊匹配(纯html+css+jquery简单实现) ，自己写的一个小组件。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><a href="https://htmlpreview.github.io/?https://github.com/zc95/Fuzzy-Query/blob/master/index.html" target="_blank" rel="external">demo地址</a></li>
<li><a href="https://github.com/zc95/Fuzzy-Query" target="_blank" rel="external">github地址</a></li>
</ul>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><ol>
<li>引入<code>css</code>、<code>jQuery</code> 和 <code>js</code>（github里面有）</li>
<li><pre><code class="javascript">$(&#39;#id&#39;).FuzzyQuery({
     &#39;msg&#39;: msg
   });
</code></pre>
<a id="more"></a>
</li>
</ol>
<h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p><code>msg</code> 是json数据（必须），<code>fontSize</code> 是模糊查询项的字体大小，<code>height</code> 是模糊查询项的高度</p>
<pre><code class="javascript">$(&#39;#Name&#39;).FuzzyQuery({
        &#39;msg&#39;: msg,
        &#39;fontSize&#39;: &#39;13px&#39;,
        &#39;height&#39;: &#39;30px&#39;
      });
</code></pre>
<h2 id="msg格式示例"><a href="#msg格式示例" class="headerlink" title="msg格式示例"></a>msg格式示例</h2><p><code>name</code> 是文本，<code>id</code> 是标识</p>
<pre><code class="javascript">msg = [{ &quot;name&quot;: &quot;苏州大学&quot;, &quot;id&quot;: &quot;szdx&quot; }, { &quot;name&quot;: &quot;北京大学&quot;, &quot;id&quot;: &quot;bjdx&quot; }, { &quot;name&quot;: &quot;南京大学&quot;, &quot;id&quot;: &quot;njdx&quot; }, { &quot;name&quot;: &quot;清华大学&quot;, &quot;id&quot;: &quot;qhdx&quot; }, { &quot;name&quot;: &quot;复旦大学&quot;, &quot;id&quot;: &quot;fddx&quot; }, { &quot;name&quot;: &quot;浙江大学&quot;, &quot;id&quot;: &quot;zjdx&quot; }, { &quot;name&quot;: &quot;上海交通大学&quot;, &quot;id&quot;: &quot;shjtdx&quot; }, { &quot;name&quot;: &quot;武汉大学&quot;, &quot;id&quot;: &quot;whdx&quot; }, { &quot;name&quot;: &quot;中国人民大学&quot;, &quot;id&quot;: &quot;zgrmdx&quot; }, { &quot;name&quot;: &quot;中国科学技术大学&quot;, &quot;id&quot;: &quot;zgkxjsdx&quot; }, { &quot;name&quot;: &quot;北京师范大学&quot;, &quot;id&quot;: &quot;bjsfdx&quot; }];
</code></pre>
<h2 id="html和CSS部分的一些细节"><a href="#html和CSS部分的一些细节" class="headerlink" title="html和CSS部分的一些细节"></a>html和CSS部分的一些细节</h2><ol>
<li><blockquote>
<p>outline: none;  </p>
<p>outline （轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，为了美观应该去掉</p>
</blockquote>
</li>
<li><blockquote>
<p>box-sizing:border-box;</p>
<p>这可令浏览器呈现出带有指定宽度和高度的框，并把边框和内边距放入框中。</p>
</blockquote>
</li>
<li><blockquote>
<p>autocomplete=”off”</p>
<p>autocomplete是form表单的属性，默认为on，其含义代表是否让浏览器自动记录之前输入的值，应该关闭记录</p>
</blockquote>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> demo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> html </tag>
            
            <tag> javascript </tag>
            
            <tag> jquery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Mac下通过Hexo在Github上搭建博客（入门篇）]]></title>
      <url>/2017/10/20/hexoBlog/</url>
      <content type="html"><![CDATA[<p>Hexo 快速，简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。Hexo支持Github Flavored Markdown的所有功能，甚至可以整合Octopress的大多数插件，并自己也拥有强大的插件系统。</p>
<p><code>Hexo</code> <code>github</code> <code>Node.js</code> <code>Git</code> <code>markdown</code> <code>themes</code> <code>bash命令</code> <code>npm</code> <code>SSH</code></p>
<h2 id="什么是Hexo？"><a href="#什么是Hexo？" class="headerlink" title="什么是Hexo？"></a>什么是<a href="https://hexo.io/docs/index.html" target="_blank" rel="external">Hexo</a>？</h2><ul>
<li>Hexo 是一个快速、简洁且高效的博客框架。</li>
<li>Hexo 使用 <a href="https://baike.baidu.com/item/markdown" target="_blank" rel="external">Markdown</a>（或其他渲染引擎，之后会解释什么是Markdown）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</li>
</ul>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p><strong>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</strong></p>
<ul>
<li><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a> （安装Recommended For Most Users那个版本）</li>
<li><a href="https://nodejs.org/en/" target="_blank" rel="external">Git</a><a id="more"></a>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2></li>
</ul>
<p><strong>当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：</strong><br>命令就是你的Launchpad里叫 <code>终端</code> 的app，相当于win的cmd<br>以下出现的$都不是命令的一部分</p>
<blockquote>
<p>$ npm install -g hexo-cli<br>全局安装 hexo 模块，</p>
<p>如果下面的操作报错则需要卸载 hexo：<br>$ npm uninstall hexo</p>
<p>再重新安装 hexo：<br>$ sudo npm install -g hexo<br>输入管理员密码（Mac登录密码）即开始安装</p>
</blockquote>
<h2 id="创建博客目录"><a href="#创建博客目录" class="headerlink" title="创建博客目录"></a>创建博客目录</h2><p><strong>初始化, 在指定目录中创建文件目录，以 blog 为例：</strong></p>
<blockquote>
<p>$ hexo init blog</p>
</blockquote>
<p><strong>blog是你建立的文件夹名称，cd到blog文件夹下，安装npm：</strong></p>
<blockquote>
<p>$ cd blog</p>
<p>$ npm install</p>
</blockquote>
<h2 id="创建一篇新文章"><a href="#创建一篇新文章" class="headerlink" title="创建一篇新文章"></a>创建一篇新文章</h2><p><strong>以创建博客 firstBlog为例，标题中包含空格需要用引号将标题引起来</strong></p>
<blockquote>
<p>$ hexo new firstBlog<br>执行该命令后在<code>source/_posts</code>目录下生成文件</p>
</blockquote>
<h2 id="生成博客页面"><a href="#生成博客页面" class="headerlink" title="生成博客页面"></a>生成博客页面</h2><blockquote>
<p>$ hexo generate<br>执行该命令后会生成<code>public</code>目录</p>
<p>$ hexo sever<br>执行命令后启动服务，访问<code>http://localhost:4000/</code>可查看博客</p>
</blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li>之后每次修改完你的博客或者配置内容，都需要用$ hexo sever来开启hexo服务器预览</li>
<li>按 Ctrl+C 停止服务器，以便于进行其他操作</li>
</ul>
<h2 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h2><p>在进行这一步时你需要一个github账号，到 <a href="https://github.com/" target="_blank" rel="external">github官网</a> 用邮箱注册就行，名字尽量简短有意义，我的github地址：<a href="https://github.com/zc95" target="_blank" rel="external">https://github.com/zc95</a></p>
<p>创建仓库登录你的Github帐号，新建仓库，一定要是名为 <code>用户名.github.io</code> 的固定写法（如 <code>zc95.github.io</code> ），我的仓库地址：<a href="https://github.com/zc95/zc95.github.io" target="_blank" rel="external">https://github.com/zc95/zc95.github.io</a></p>
<h2 id="上传到-github"><a href="#上传到-github" class="headerlink" title="上传到 github"></a>上传到 github</h2><p><strong>首次使用配置：</strong></p>
<blockquote>
<p>$ npm install hexo-deplorer-git –save<br>安装 <code>hexo-deplorer-git</code></p>
</blockquote>
<p>打开新建的blog文件夹，找到 <code>_config.yml</code> 配置文件，用记事本打开，Ctrl+F来搜索deploy，type改为git，repository改为你自己的仓库地址，在配置博客站点的_config.yml文件时（包括theme主题站点中的_config.yml），在所有的冒号: 后边都要加一个空格，否则执行hexo命令会报错，切记 切记</p>
<blockquote>
<p>deploy:<br>type: git<br>repository: <code>你的仓库地址</code><br>branch: master</p>
</blockquote>
<p>ok，可以尽情装逼了。。。</p>
<blockquote>
<p>hexo g == hexo generate #生成页面文件</p>
<p>hexo s == hexo server #启动服务预览</p>
<p>hexo d == hexo deploy # 部署到GitHub</p>
</blockquote>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><blockquote>
<p>git clone #克隆主题时用到</p>
<p>cd blog #进入blog文件夹</p>
<p>hexo n “我的博客” == hexo new “我的博客” #新建文章</p>
<p>hexo clean  #清除缓存 网页正常情况下可以忽略此条命令  </p>
<p>hexo g == hexo generate #生成</p>
<p>hexo s == hexo server #启动服务预览</p>
<p>hexo d == hexo deploy # 部署</p>
<p>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d #你应该看得懂…</p>
</blockquote>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><pre><code class="javascript">var author = { 
  Name  : &quot;张成&quot;,
  Blog : &quot;http://zc95.github.io&quot;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 技术篇 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> github </tag>
            
            <tag> Node.js </tag>
            
            <tag> markdown </tag>
            
            <tag> npm </tag>
            
            <tag> 博客 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/10/19/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><a id="more"></a>
<pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
