{"meta":{"title":"Blog | 秋刀鱼的滋味","subtitle":null,"description":null,"author":"张成","url":"http://zc95.github.io"},"pages":[{"title":"about","date":"2017-11-11T10:49:42.579Z","updated":"2017-10-20T23:31:52.142Z","comments":true,"path":"about/index.html","permalink":"http://zc95.github.io/about/index.html","excerpt":"","text":"关于我var zhangcheng = { Name : &quot;zhangcheng&quot;, Birth : &quot;1995/7/3&quot;, University : &quot;Nanjin university&quot;, Location : &quot;SIP&quot;, Blog : &quot;https://zc95.github.io&quot;, Github : &quot;https://github.com/zc95&quot;, QQ : &quot;571346800&quot;, Mail : &quot;571346800@qq.com&quot;, Tel : &quot;17751435450&quot; }"},{"title":"friends","date":"2017-11-11T10:49:28.881Z","updated":"2017-10-19T17:37:19.000Z","comments":true,"path":"friends/index.html","permalink":"http://zc95.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-10-20T16:26:49.000Z","updated":"2017-10-20T16:16:23.000Z","comments":true,"path":"tags/index.html","permalink":"http://zc95.github.io/tags/index.html","excerpt":"","text":""},{"title":"timeline","date":"2017-10-20T16:03:38.000Z","updated":"2017-10-20T16:03:38.000Z","comments":true,"path":"timeline/index.html","permalink":"http://zc95.github.io/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"我的收藏","slug":"Collection","date":"2017-11-21T11:30:45.000Z","updated":"2017-11-22T15:38:06.547Z","comments":true,"path":"2017/11/21/Collection/","link":"","permalink":"http://zc95.github.io/2017/11/21/Collection/","excerpt":"","text":"我的博客https://zc95.github.io工具jsrun在线代码编辑tinypng压缩图片Google翻译msdn.itellyouMDN文档前端插件&amp;框架echartslayui阿里巴巴矢量图标图学习网站freecodecamp慕课网前端菜鸟教程","categories":[{"name":"汇总篇","slug":"汇总篇","permalink":"http://zc95.github.io/categories/汇总篇/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"http://zc95.github.io/tags/收藏/"},{"name":"前端必备","slug":"前端必备","permalink":"http://zc95.github.io/tags/前端必备/"}]},{"title":"数组复习","slug":"arrayReview","date":"2017-11-21T10:44:45.000Z","updated":"2017-11-22T12:00:23.697Z","comments":true,"path":"2017/11/21/arrayReview/","link":"","permalink":"http://zc95.github.io/2017/11/21/arrayReview/","excerpt":"","text":"检测数组typeofvar ary = [1,23,4]; console.log(typeof ary); //输出结果是Object instanceofvar ary = [1,23,4]; console.log(ary instanceof Array)//true; 原型链方法var ary = [1,23,4]; console.log(ary.__proto__.constructor==Array);//true console.log(ary.constructor==Array)//true 这两段代码是一样的 以上三种方法都不太好，instanceof 和 constructor 判断的变量，必须在当前页面声明的，比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个arr，并将其赋值给父页面的一个变量，这时判断该变量，Array == object.constructor;会返回false； 正确方法var ary = [1,2,3,4]; function isArray(e){ return Object.prototype.toString.call(e)==&#39;[object Array]&#39;; } console.log(isArray(ary)); 自己封装的基本数据类型验证var type = { isObj: function(o) { return Object.prototype.toString.call(o) == &quot;[object Object]&quot;; }, isArray: function(o) { return Object.prototype.toString.call(o) == &quot;[object Array]&quot;; }, isNull: function(o) { return Object.prototype.toString.call(o) == &quot;[object Null]&quot;; }, isUndefined: function(o) { return Object.prototype.toString.call(o) == &quot;[object Undefined]&quot;; }, isBoolean: function(o) { return Object.prototype.toString.call(o) == &quot;[object Boolean]&quot;; }, isString: function(o) { return Object.prototype.toString.call(o) == &quot;[object String]&quot;; }, isNumber: function(o) { return Object.prototype.toString.call(o) == &quot;[object Number]&quot;; }, isDocument: function() { return Object.prototype.toString.call(o) == &quot;[object Document]&quot; || &quot;[object HTMLDocument]&quot;; } } ------------------------------ &gt;console.log(type.isArray([1,2,3])); &gt;true push()和pop() push() 向数组末尾添加任意个项并返回新数组的长度 pop() 从数组末尾移除最后一项，减少数组的length值 （返回的是移除的项） shift()和unshift() unshift() 向数组前端添加任意个项并返回新数组的长度 shift() 从数组前端移除第一项，减少数组的length值 （返回的是移除的项） 重排序 sort() reverse()function compare(a,b){ return a-b;//升序 //return b-a; 或者在升序方法之后使用reverse()反转数组 } arr.sort(compare); 操作方法 concat() slice() splice()concat()concat() 方法用于连接两个或多个数组，不会改变原始数组。 slice()slice() 方法可从已有的数组中返回选定的元素，不会改变原始数组。 arrayObject.slice(start,end) 参数 描述 start 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 splice()splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目，会改变原始数组。 arrayObject.splice(index,howmany,item1,…..,itemX) 参数 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX 可选。向数组添加的新项目。 位置方法indexOf() indexOF() 从前往后查找，返回首次出现的位置（没有返回-1） lastindexOf() lastindexOf() 从后往前查找，返回首次出现的位置（没有返回-1） 迭代方法 迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。 every(): 对数组中的每一项运行给定的函数，如果该函数对每一项都返回true，则结果返回true。 filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 forEach(): 对数组中的每一项运行给定函数，这个方法没有返回值。 map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some(): 对数组中的每一项运行给定函数，如果该函数任意一项返回true，则返回true。 every()和some()var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; var everyResult = numbers.every(function(item, index, array) { return (item &gt; 2); }); var someResult = numbers.some(function(item) { return (item &gt; 2); }); console.log(everyResult); //false console.log(someResult); //true filter()var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; var filterResult = numbers.filter(function(item) { return (item &gt; 2); }); console.log(filterResult); \\\\[3, 4, 5, 4, 3] map()var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; var mapResult = numbers.map(function(item) { return (item * 2); }); console.log(mapResult); //[2, 4, 6, 8, 10, 8, 6, 4, 2] forEach()var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; numbers.forEach(function(item, index, arr) { //这里执行一些操作 });","categories":[{"name":"汇总篇","slug":"汇总篇","permalink":"http://zc95.github.io/categories/汇总篇/"}],"tags":[{"name":"array","slug":"array","permalink":"http://zc95.github.io/tags/array/"}]},{"title":"自定义range滑块","slug":"rangeUI","date":"2017-11-17T11:06:48.000Z","updated":"2017-11-21T10:52:02.448Z","comments":true,"path":"2017/11/17/rangeUI/","link":"","permalink":"http://zc95.github.io/2017/11/17/rangeUI/","excerpt":"","text":"Range 开始 DEMO 源码 简易版DEMO 导入jQuery, CSS和JSjQueryhttp://jsrun.net/CciKp.css p { font-family: &quot;微软雅黑&quot;; letter-spacing: -1px; text-shadow: -2px -1px 1px #fff, 1px 2px 2px rgba(0, 0, 0, 0.2); font-weight: 300; font-size: 36px; margin: 10px; } input[type=range] { -webkit-appearance: none; width: 300px; border-radius: 10px; /*这个属性设置使填充进度条时的图形为圆角*/ background: -webkit-linear-gradient(#2EB969, #2EB969) no-repeat;/*进度条的颜色*/ background-size: 0% 100%; } input[type=range]:focus { outline: none; } input[type=range]:hover { cursor:pointer; } input[type=range]::-webkit-slider-runnable-track { height: 6px; border-radius: 10px; /*将轨道设为圆角的*/ box-shadow: 0.2px 0.2px 1px 0.8px #cec8c8 inset; /*添加底部阴影*/ } input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; cursor: pointer; height: 20px; width: 20px; margin-top:-6px; border-radius: 50%; background-color:white; box-shadow: 0px 0px 3px 1px #DEDEDE; } ​ http://jsrun.net/CciKp.js $.fn.RangeSlider = function(cfg){ var userAgent = navigator.userAgent; var isWebkit = (userAgent.indexOf(&quot;AppleWebKit&quot;) &gt;= 0); var isIE = isIE(); function isIE() { var isIE = false; if (window.ActiveXObject || &quot;ActiveXObject&quot; in window) { isIE = true; } else { isIE = (userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !(userAgent.indexOf(&quot;Opera&quot;) &gt; -1)); isIE = false; } return isIE; } this.sliderCfg = { min: cfg &amp;&amp; !isNaN(parseFloat(cfg.min)) ? Number(cfg.min) : null, max: cfg &amp;&amp; !isNaN(parseFloat(cfg.max)) ? Number(cfg.max) : null, step: cfg &amp;&amp; Number(cfg.step) ? cfg.step : 1, callback: cfg &amp;&amp; cfg.callback ? cfg.callback : null }; var $input = $(this); var min = this.sliderCfg.min; var max = this.sliderCfg.max; var step = this.sliderCfg.step; var callback = this.sliderCfg.callback; $input.attr(&#39;min&#39;, min) .attr(&#39;max&#39;, max) .attr(&#39;step&#39;, step); var event = null; if (isIE) { event = &quot;change&quot;; } else { event = &quot;input&quot;; } $input.bind(event, function(e){ $input.attr(&#39;value&#39;, this.value); if (isWebkit) { $input.css( &#39;background-size&#39;, this.value + &#39;% 100%&#39; ); } if ($.isFunction(callback)) { callback(this); } }); }; ​ 使用&lt;p&gt; 进度条&amp;emsp;&lt;span id=&quot;num&quot;&gt;0&lt;/span&gt;% &lt;/p&gt; &lt;input type=&quot;range&quot; value=&quot;0&quot;&gt; $(function() { $(&#39;input&#39;).RangeSlider({ step: 0.1, callback: change }); }); var change = function($input) { /*内容可自行定义*/ $(&quot;#num&quot;).text($(&#39;input&#39;).val()); }","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"column","slug":"column","date":"2017-11-10T16:30:14.000Z","updated":"2017-11-17T11:28:09.800Z","comments":true,"path":"2017/11/11/column/","link":"","permalink":"http://zc95.github.io/2017/11/11/column/","excerpt":"","text":"CSS3多列CSS3 可以将文本内容设计成像报纸一样的多列布局，如下实例： CSS3 多列属性 column-count column-gap column-rule-style column-rule-width column-rule-color column-rule column-span column-width CSS3 创建多列column-count 属性指定了需要分割的列数 以下实例将 &lt;div&gt; 元素中的文本分为 3 列： .newspaper { -moz-column-count:3; /* Firefox */ -webkit-column-count:3; /* Safari and Chrome */ column-count:3; } &lt;div class=&quot;newspaper&quot;&gt;....................&lt;/div&gt; 尝试一下 » CSS3 多列中列与列间的间隙column-gap 属性指定了列与列间的间隙 以下实例指定了列与列间的间隙为 40 像素： .newspaper { -moz-column-count:3; /* Firefox */ -webkit-column-count:3; /* Safari and Chrome */ column-count:3; -moz-column-gap:40px; /* Firefox */ -webkit-column-gap:40px; /* Safari and Chrome */ column-gap:40px; } &lt;div class=&quot;newspaper&quot;&gt;....................&lt;/div&gt; 尝试一下 » CSS3 列边框column-rule-style 属性指定了列与列间的边框样式： .newspaper { -webkit-column-rule-style: solid; /* Chrome, Safari, Opera */ -moz-column-rule-style: solid; /* Firefox */ column-rule-style: solid; } 尝试一下 » column-rule-width 属性指定了两列的边框厚度： div { -webkit-column-rule-width: 1px; /* Chrome, Safari, Opera */ -moz-column-rule-width: 1px; /* Firefox */ column-rule-width: 1px; } 尝试一下 » column-rule-color 属性指定了两列的边框颜色： div { -webkit-column-rule-color: lightblue; /* Chrome, Safari, Opera */ -moz-column-rule-color: lightblue; /* Firefox */ column-rule-color: lightblue; } 尝试一下 » column-rule 属性是 column-rule-* 所有属性的简写。 以下实例设置了列直接的边框的厚度，样式及颜色： div { -webkit-column-rule: 1px solid lightblue; /* Chrome, Safari, Opera */ -moz-column-rule: 1px solid lightblue; /* Firefox */ column-rule: 1px solid lightblue; } 尝试一下 » 指定元素跨越多少列以下实例指定 &lt;h2&gt; 元素跨越所有列： h2 { -webkit-column-span: all; /* Chrome, Safari, Opera */ column-span: all; } 尝试一下 » 指定列的宽度column-width 属性指定了列的宽度。 div { -webkit-column-width: 100px; /* Chrome, Safari, Opera */ column-width: 100px; } 尝试一下 » CSS3 多列属性下表列出了所有 CSS3 的多列属性： 属性 描述 column-count 指定元素应该被分割的列数。 column-fill 指定如何填充列 column-gap 指定列与列之间的间隙 column-rule 所有 column-rule-* 属性的简写 column-rule-color 指定两列间边框的颜色 column-rule-style 指定两列间边框的样式 column-rule-width 指定两列间边框的厚度 column-span 指定元素要跨越多少列 column-width 指定列的宽度 columns 设置 column-width 和 column-count 的简写","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"css3","slug":"css3","permalink":"http://zc95.github.io/tags/css3/"},{"name":"布局","slug":"布局","permalink":"http://zc95.github.io/tags/布局/"}]},{"title":"类似Windows文件的布局问题","slug":"AdaptiveLayout","date":"2017-11-03T10:40:24.000Z","updated":"2017-11-03T10:47:21.136Z","comments":true,"path":"2017/11/03/AdaptiveLayout/","link":"","permalink":"http://zc95.github.io/2017/11/03/AdaptiveLayout/","excerpt":"","text":"问题如何做到类似windows文件的布局：无论如何改变窗口（屏幕）的大小，文件或者文件夹的大小都是固定的，不同的是一行显示的数目会有所变化； 百分比布局首先这类布局，肯定会先想到百分比的方法（最快的方法），在不同手机上看的话当然没区别，比如一行显示4个的话，那么一个就是25%，但如果放到ipad或者电脑上来看的话，就大的有些恐怖了 百分比加@media布局同上，我们可以用@media的方法来解决不同类型设备的差异问题，也就是多写几行css的问题 我的方法var eachWidth = $(document).width() / Math.floor($(document).width() / 80); 假如我想每个div都在80px左右，那么一行就可以放 $(document).width() / 80 个，用 Math.floor 向下取整之后可以去掉不满一个的零头，再用屏幕宽度除以这个取整后的个数，就能得到长度在80±10的eachWidth值了 下面是在控制台的不同手机屏幕大小下console出来的数据： $(document).width() / Math.floor($(document).width() / 80) //iPad --&gt; 85.33333333333333 $(document).width() / Math.floor($(document).width() / 80) //iPhone 6 Plus --&gt; 82.8 $(document).width() / Math.floor($(document).width() / 80) //iPhone 6 --&gt; 93.75 $(document).width() / Math.floor($(document).width() / 80) //iPhone 5 --&gt; 80 $(document).width() / Math.floor($(document).width() / 80) //Nexus 6P --&gt; 82.4 效果图 移动端 iPad","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"},{"name":"页面布局","slug":"页面布局","permalink":"http://zc95.github.io/tags/页面布局/"}]},{"title":"原生javascript和jquery的用法对比","slug":"jsAndJq","date":"2017-10-25T04:39:12.000Z","updated":"2017-11-03T10:46:31.416Z","comments":true,"path":"2017/10/25/jsAndJq/","link":"","permalink":"http://zc95.github.io/2017/10/25/jsAndJq/","excerpt":"","text":"选取元素// jQuery var els = $(&#39;.el&#39;); // Native var els = document.querySelectorAll(&#39;.el&#39;); // Shorthand var $ = function (el) { return document.querySelectorAll(el); } querySelectorAll方法返回的是NodeList对象，需要转换为数组。 myList = Array.prototype.slice.call(myNodeList) 创建元素// jQuery var newEl = $(&#39;&lt;div&gt;&lt;/div&gt;&#39;); // Native var newEl = document.createElement(&#39;div&#39;); 添加事件// jQuery $(&#39;.el&#39;).on(&#39;event&#39;, function() { }); // Native [].forEach.call(document.querySelectorAll(&#39;.el&#39;), function (el) { el.addEventListener(&#39;event&#39;, function() { }, false); }); get/set属性// jQuery $(&#39;.el&#39;).filter(&#39;:first&#39;).attr(&#39;key&#39;, &#39;value&#39;); $(&#39;.el&#39;).filter(&#39;:first&#39;).attr(&#39;key&#39;); // Native document.querySelector(&#39;.el&#39;).setAttribute(&#39;key&#39;, &#39;value&#39;); document.querySelector(&#39;.el&#39;).getAttribute(&#39;key&#39;); 添加和移除样式ClassDOM元素本身有一个可读写的className属性，可以用来操作class。 HTML 5还提供一个classList对象，功能更强大（IE 9不支持）。 // jQuery $(&#39;.el&#39;).addClass(&#39;class&#39;); $(&#39;.el&#39;).removeClass(&#39;class&#39;); $(&#39;.el&#39;).toggleClass(&#39;class&#39;); // Native document.querySelector(&#39;.el&#39;).classList.add(&#39;class&#39;); document.querySelector(&#39;.el&#39;).classList.remove(&#39;class&#39;); document.querySelector(&#39;.el&#39;).classList.toggle(&#39;class&#39;); 追加元素尾部追加元素： // jQuery $(&#39;.el&#39;).append($(&#39;&lt;div/&gt;&#39;)); // Native document.querySelector(&#39;.el&#39;).appendChild(document.createElement(&#39;div&#39;)); 头部追加元素： //jQuery $(‘.el’).prepend(&#39;&lt;div&gt;&lt;/div&gt;&#39;) //Native var parent = document.querySelector(&#39;.el&#39;); parent.insertBefore(&quot;&lt;div&gt;&lt;/div&gt;&quot;,parent.childNodes[0]) 克隆元素// jQuery var clonedEl = $(&#39;.el&#39;).clone(); // Native var clonedEl = document.querySelector(&#39;.el&#39;).cloneNode(true); 移除元素Remove // jQuery $(&#39;.el&#39;).remove(); // Native remove(&#39;.el&#39;); function remove(el) { var toRemove = document.querySelector(el); toRemove.parentNode.removeChild(toRemove); } 获取父级元素// jQuery $(&#39;.el&#39;).parent(); // Native document.querySelector(&#39;.el&#39;).parentNode; 获取上一个/下一个元素（Prev/next element）// jQuery $(&#39;.el&#39;).prev(); $(&#39;.el&#39;).next(); // Native document.querySelector(&#39;.el&#39;).previousElementSibling; document.querySelector(&#39;.el&#39;).nextElementSibling; XHR and AJAX// jQuery $.get(&#39;url&#39;, function (data) { }); $.post(&#39;url&#39;, {data: data}, function (data) { }); // Native // get var xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, url); xhr.onreadystatechange = function (data) { } xhr.send(); // post var xhr = new XMLHttpRequest() xhr.open(&#39;POST&#39;, url); xhr.onreadystatechange = function (data) { } xhr.send({data: data}); 清空子元素//jQuery $(&quot;#elementID&quot;).empty() //Native var element = document.getElementById(&quot;elementID&quot;) while(element.firstChild) element.removeChild(element.firstChild); 检查是否有子元素//jQuery if (!$(&quot;#elementID&quot;).is(&quot;:empty&quot;)){} //Native if (document.getElementById(&quot;elementID&quot;).hasChildNodes()){} $(document).readyDOM加载完成，会触发DOMContentLoaded事件，等同于jQuery的$(document).ready方法。 document.addEventListener(&quot;DOMContentLoaded&quot;, function() { // ... }); 数据储存jQuery对象可以储存数据。 $(&quot;body&quot;).data(&quot;foo&quot;, 52); $(&quot;body&quot;).data(&quot;foo&quot;); HTML 5有一个dataset对象，也有类似的功能（IE 10不支持），不过只能保存字符串。 element.dataset.user = JSON.stringify(user); element.dataset.score = score; 动画jQuery的animate方法，用于生成动画效果。 $foo.animate(&#39;slow&#39;, { x: &#39;+=10px&#39; }) jQuery的动画效果，很大部分基于DOM。但是目前，CSS 3的动画远比DOM强大，所以可以把动画效果写进CSS，然后通过操作DOM元素的class，来展示动画。 foo.classList.add(&#39;animate&#39;) 如果需要对动画使用回调函数，CSS 3也定义了相应的事件。 el.addEventListener(&quot;webkitTransitionEnd&quot;, transitionEnded); el.addEventListener(&quot;transitionend&quot;, transitionEnded);","categories":[{"name":"汇总篇","slug":"汇总篇","permalink":"http://zc95.github.io/categories/汇总篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"css换行问题","slug":"wordBreak","date":"2017-10-25T04:27:15.000Z","updated":"2017-11-22T11:48:11.176Z","comments":true,"path":"2017/10/25/wordBreak/","link":"","permalink":"http://zc95.github.io/2017/10/25/wordBreak/","excerpt":"","text":"css实现强制不换行/自动换行/强制换行 强制换行按单词自动换行 p { word-wrap:break-word; } 强制按英文字母断行 需要将行内元素设置为块级元素 p { word-break:break-all; } 强制不换行强制不换行 p { white-space:nowrap; } 超出显示省略号 p { white-space:nowrap; text-overflow:ellipsis; overflow:hidden; } 一定要给文字的父容器 如果父容器是行级，一定要转成块级（一定要是 block，设置为 inline-block 无效） white-space: normal pre nowrap pre-wrap pre-line inherit ; white-space 属性设置如何处理元素内的空白 normal 默认。多个空白或者多个换行将被当一个空白或一个换行处理- pre 空白和换行会被浏览器保留。其行为方式类似 HTML 中的 pre 标签- nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止- pre-wrap 保留空白符序列，但是正常地进行换行 - pre-line 合并空白符序列，但是保留换行符- inherit 规定应该从父元素继承 white-space 属性的值word-break: normal break-all keep-all ; word-break 属性用来标明怎么样进行单词内的断句 normal：使用浏览器默认的换行规则- break-all:允许再单词内换行 - keep-all:只能在半角空格或连字符处换行","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"表头固定","slug":"amazingTable","date":"2017-10-23T16:15:16.000Z","updated":"2017-11-03T12:54:52.389Z","comments":true,"path":"2017/10/24/amazingTable/","link":"","permalink":"http://zc95.github.io/2017/10/24/amazingTable/","excerpt":"","text":"table的表头固定 ——— 上下滚动表头固定，左右滚动表头跟随滚动 关于表格固定如果数据不是很多，一般都是用两个表格，一个放thead，另一个放tbody，这个没难度就不再赘述了 如果数据很多就要考虑左右滚动的情况了 方法一demo: http://jsrun.net/biiKp/show 同样是两个table，一个放thead，另一个放tbody，用两个div分别包裹起来 这两个div依赖于他们的的父容器进行absolute定位 theadDiv { position: absolute; left: 0; right: 0; overflow: hidden; //这里hidden是用于隐藏滚动条} tbodyDiv { position: absolute; top: 35px; left: 0; right: 0; bottom: 0; overflow: auto;} 给放置thead的div添加样式 overflow: hidden; ，表头不需要看到滚动条 给放置tbody的div添加样式 overflow: auto; ，表的主体需要滚动条 这时只需要在滚动下面的tbody时，同样滚动上面的thead就行 $(‘#tbodyDiv’).on(‘scroll’, function () { $(“#theadDiv”).scrollLeft($(‘#tbodyDiv’).scrollLeft()); }); }) 方法二demo: http://jsrun.net/2iiKp/show 大概思路就是 容器A 下面有 容器1（放置thead） 和 容器2（放置tbody） x轴滚动条属于 容器A ，滚动 容器1（放置thead） 和 容器2（放置tbody） y轴属于 容器2 ，滚动 tbody 这个方法有缺陷，就是y轴的滚动条必须要当x轴滚到最右边才看得到，当然Mac下无差（Mac下的滚动条不滚动的时候是隐藏的，而win系统下就会影响美观，但都不影响操作，毕竟我们有鼠标滚轮）","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"DOM","slug":"DOM","date":"2017-10-21T06:37:42.000Z","updated":"2017-11-22T11:47:51.671Z","comments":true,"path":"2017/10/21/DOM/","link":"","permalink":"http://zc95.github.io/2017/10/21/DOM/","excerpt":"","text":"为什么我们要尽量少的去操作DOM结构？ 前言在前端开发的过程中，javascript极为重要的一个功能就是对DOM对象的操作，无论增删改查在前端页面操作这一范围内都是比较消耗性能的。如何高效率的，便捷的操作DOM，这就是本文要讲述的，希望看完全文，你能知道如何更高效的通过原生js以及jQuery操作DOM元素。 性能影响 DOM修改导致的页面重绘repaint、重构reflow，重新排版是用户阻塞的操作，同时，如果频繁重排，CPU使用率也会猛涨 repaint意味着样式的改变比如div调整了背景色等，但是位置不变，只改变我们操作的元素 reflow意味着结构的改变，比如一堆元素堆叠，改变其中一个的宽高，那么相应的所有元素的位置都要改变 所以通常来看repaint的代价要远小于reflow，速度也更快 如何避免能放到DOM操作之外的操作就放到外面，DOM操作要尽量少这是一个不好的事例： var $obj = $(&quot;#obj&quot;); var data = [{&quot;id&quot;:0,&quot;name&quot;:&quot;a&quot;},{&quot;id&quot;:1,&quot;name&quot;:&quot;b&quot;}]; for (var i = 0; i &lt; data.length; i++) { $obj.append(&#39;&lt;option value=&quot;&#39;+data[i].id+&#39;&quot;&gt;&#39;+data[i].name+&#39;&lt;/option&gt;&#39;); }; 更好的做法，使用容器存放临时变更，最后再一次性更新DOM： var $obj = $(&quot;#obj&quot;); var data = [{&quot;id&quot;:0,&quot;name&quot;:&quot;a&quot;},{&quot;id&quot;:1,&quot;name&quot;:&quot;b&quot;}]; var tempStr = &quot;&quot;; for (var i = 0; i &lt; data.length; i++) { tempStr +=(&#39;&lt;option value=&quot;&#39;+data[i].id+&#39;&quot;&gt;&#39;+data[i].name+&#39;&lt;/option&gt;&#39;); }; $obj.html(tempStr); 大范围操作先把容器隐藏，在其中操作完成后再显示这个也算是优化的一种，这原理涉及到浏览器加载和渲染的原理,简单说就是隐藏的元素其中不会产生reflow 样式操作不要注意修改属性，直接替换class这个还是比较容易理解的，你逐一修改要访问很多次，而替换class就相当于批量操作了，访问一次DOM就可以了,当然性能提高了 总结对于性能方面，平时应注意积累。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"},{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://zc95.github.io/tags/jquery/"},{"name":"DOM操作","slug":"DOM操作","permalink":"http://zc95.github.io/tags/DOM操作/"},{"name":"循环","slug":"循环","permalink":"http://zc95.github.io/tags/循环/"},{"name":"渲染","slug":"渲染","permalink":"http://zc95.github.io/tags/渲染/"},{"name":"性能","slug":"性能","permalink":"http://zc95.github.io/tags/性能/"}]},{"title":"文本框模糊查询","slug":"input","date":"2017-10-21T05:14:08.000Z","updated":"2017-11-21T10:59:49.196Z","comments":true,"path":"2017/10/21/input/","link":"","permalink":"http://zc95.github.io/2017/10/21/input/","excerpt":"","text":"文本框模糊匹配(纯html+jquery简单实现) ，自己写的一个小组件。 Demo链接 Demo 源码 开始使用 引入css和js: http://jsrun.net/EXiKp.css 和 http://jsrun.net/sXiKp.js （点开链接拷到你的项目中） 给需要加模糊查询的input加上class=&quot;filter_input&quot;，id必需 getFilters(id, msg);（前面一个参数是input的id，后面一个参数是后台返的json字符串） JS主要代码创建需要的div包裹住文本框 function wraps(){ for(var i = 0 ; i&lt;$(&#39;.filter_input&#39;).length ; i++){ var id = $(&#39;.filter_input&#39;).eq(i).attr(&#39;id&#39;); var $width = $(&#39;.filter_input&#39;).eq(i).css(&quot;width&quot;); $(&#39;#&#39; + id).wrap(&quot;&lt;div class=&#39;filter_wrap&#39; id=&#39;filter_wrap&quot;+id+&quot;&#39;&gt;&lt;/div&gt;&quot;); $(&#39;#&#39; + id).after(&quot;&lt;div style=\\&quot;width:&quot; + $width + &quot;;\\&quot; class=&#39;filter_case&#39; id=&#39;filter_&quot; + id + &quot;&#39;&gt;&lt;/div&gt;&lt;span class=&#39;arrowTip&#39;&gt;▼&lt;/span&gt;&quot;); } } 根据后台返回的数据加载数据 function getFilters(id,msg){ var html = &quot;&quot;; $.each(eval(msg), function (i, n) { for(key in n){ html += &quot;&lt;div onclick=\\&quot;inme(&#39;&quot; + n[key] + &quot;&#39;)\\&quot; class=\\&quot;div_item\\&quot;&gt;&quot; + n[key] + &quot;&lt;/div&gt;&quot;; }; }); $(&#39;#filter_&#39;+id).html(html); $(&#39;#filter_&#39;+id).append(&quot;&lt;div onclick=&#39;NothingClick()&#39; class=\\&quot;Nothing\\&quot;&gt;无匹配项&lt;/div&gt;&quot;); } 弹出列表框 $(&quot;.filter_input&quot;).click(function() { $(&quot;.arrowTip&quot;).text(&quot;▼&quot;); $(&quot;.filter_case&quot;).hide(); $(&quot;#filter_&quot; + this.id).show(); $(&quot;#filter_&quot; + this.id).next().text(&quot;▲&quot;); return false; }); 监听文本框输入 $(&quot;.filter_input&quot;).keyup(function() { $(&quot;#filter_&quot; + this.id).show(); //只要输入就显示列表框 if ($(&quot;#&quot;+ this.id).val().length &lt;= 0) { $(&quot;#filter_&quot;+ this.id).find(&quot;.div_item&quot;).show(); //如果什么都没填，跳出，保持全部显示状态 return; } $(&quot;#filter_&quot;+ this.id).find(&quot;.div_item&quot;).hide(); //如果填了，先将所有的选项隐藏 var num=0; for (var i = 0; i &lt; $(&quot;#filter_&quot;+ this.id).find(&quot;.div_item&quot;).length; i++) { //模糊匹配，将所有匹配项显示 if ($(&quot;#filter_&quot;+ this.id).find(&quot;.div_item&quot;).eq(i).text().toLowerCase().indexOf($(&quot;#&quot; + this.id).val().toLowerCase()) &gt;= 0) { num++; $(&quot;#filter_&quot;+ this.id).find(&quot;.div_item&quot;).eq(i).show(); $(&#39;.Nothing&#39;).hide(); } } if(num==0){ $(&#39;.Nothing&#39;).show(); } }); 模糊项的点击 function inme(name) { var event = event? event: window.event; var srcObj = ((event.srcElement)?event.srcElement:event.target); $(srcObj).parent().prev().val(name); }; 点击无匹配 function NothingClick(){ var event = event? event: window.event; var srcObj = ((event.srcElement)?event.srcElement:event.target); $(srcObj).parent().prev().val(&quot;&quot;); $(&#39;.Nothing&#39;).hide(); $(&quot;.filter_case&quot;).hide(); $(&quot;.div_item&quot;).show(); } 隐藏列表框 $(&quot;body&quot;).click(function() { $(&quot;.filter_case&quot;).hide(); $(&quot;.arrowTip&quot;).text(&quot;▼&quot;); }); CSS主要代码.filter_wrap{ display:inline-block; position:relative; } .arrowTip{ position:absolute; right:5px; top:4px; color:#c2c2c2; font-size:13px; } .Nothing{ height: 30px; width: 260px; line-height: 30px; font-size: 14px; text-align:center; color:#999; display:none; cursor:pointer; } .filter_case { padding:4px 0px 4px 0px; position: absolute; z-index: 100; height:auto; max-height: 200px; border: 1px solid #999; box-sizing:border-box; overflow-x: hidden; display: none; background-color: white; margin-top:3px; box-shadow: 0 4px 6px rgba(0,0,0,.24); border-radius: 2px; } .div_item { text-indent: 8px; height: 30px; width: 260px; white-space: nowrap; line-height: 30px; font-size: 13px; } .div_item:hover { cursor: pointer; background-color: #1C86EE; color: white; } input { text-indent: 8px; box-sizing:border-box; outline: none; border:1px solid #999 !important; text-indent: 8px; height: 30px; width: 258px; box-sizing:border-box; -moz-box-sizing:border-box; /* Firefox */ -webkit-box-sizing:border-box; /* Safari */ outline: none; border-radius: 2px; } html和CSS部分的一些细节 outline: none; outline （轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，为了美观应该去掉 box-sizing:border-box; 这可令浏览器呈现出带有指定宽度和高度的框，并把边框和内边距放入框中。 autocomplete=”off” autocomplete是form表单的属性，默认为on，其含义代表是否让浏览器自动记录之前输入的值，应该关闭记录","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"},{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://zc95.github.io/tags/jquery/"}]},{"title":"日常问题整理","slug":"dailySummary","date":"2017-10-21T04:14:08.000Z","updated":"2017-11-21T10:51:17.725Z","comments":true,"path":"2017/10/21/dailySummary/","link":"","permalink":"http://zc95.github.io/2017/10/21/dailySummary/","excerpt":"","text":"记录每天学到的知识点或者遇到的问题 从数组里随机取一项arr[Math.floor(Math.random()*arr.length)] 阻止浏览器默认的右键点击事件window.document.oncontextmenu = function () { return false; } 左击右击事件function clickMe() { var event = event ? event : window.event; if (1 == event.which) { //左击 } if (3 == event.which) { //右击 } } 循环时候去掉最后一个逗号var json = eval(msg), arr = []; for (var k in json[0]) { arr.push(k + &quot;：&quot; + json[0][k] + &quot;条&quot;); } $(&#39;#dataNum&#39;).html(arr.join(&#39;，&#39;)); 判断是否存在id为item元素if($(&#39;#item&#39;).length!=0){//因为jquery获取的元素是一个集合，看长度是否为0就可以知道是不是存在 //有元素 }else{ //没有元素 } 生成区间随机数function getRandom(m,n){ return Math.floor(Math.random()*(n-m+1)+m) } 小数转为百分数Number(point*100).toFixed(2)+&quot;%&quot;; trim() 去掉前后空白//去左空格; function ltrim(s){ return s.replace(/(^\\s*)/g, &quot;&quot;); } //去右空格; function rtrim(s){ return s.replace(/(\\s*$)/g, &quot;&quot;); } //去左右空格; function trim(s){ return s.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;); } 数组去重function QuChong(arr){ var newArr =[]; for(i in arr){ if(!newArr.includes(arr[i])){ newArr.push(arr[i]); } } return newArr; } reverse()reverse();用于翻转数组，该方法会改变原来的数组，而不会创建新的数组。 sort()function sortNumber(a,b) { return a - b;//升序 //return b - a;//倒序 或者升序之后用 reverse() 翻转数组 } arr.sort(sortNumber); 找出元素 item 在给定数组 arr 中的位置function indexOf(arr, item) { return arr.indexOf(item) } 计算给定数组 arr 中所有元素的总和计算给定数组 arr 中所有元素的总和 function sum(arr) { var hehe=0; for(e in arr){ hehe += arr[e]; } return hehe; } function sum(arr) { return eval(arr.join(&#39;+&#39;)); } 移除数组 arr 中的所有值与 item 相等的元素移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组 function remove(arr, item) { var arr2 =[]; for(e in arr){ if(arr[e] != item){ arr2.push(arr[e]); } } return arr2; } function remove(arr, item) { var newArr = arr.slice(0); while(newArr.indexOf(item)!=-1){ newArr.splice(newArr.indexOf(item),1); } return newArr; } 在数组 arr 末尾添加元素 item在数组 arr 末尾添加元素 item。不要直接修改数组 arr，结果返回新的数组 function append(arr, item) { return arr.concat([item]); } function append(arr, item) { var newArr = arr.slice(0); return newArr.push(item); } 删除数组 arr 最后一个元素删除数组 arr 最后一个元素。不要直接修改数组 arr，结果返回新的数组 function truncate(arr) { var newArr = arr.slice(0); newArr.pop(); //newArr.splice(newArr.length-1,1); //newArr.splice(newArr.length-1); return newArr; } 在数组 arr 开头添加元素 item在数组 arr 开头添加元素 item。不要直接修改数组 arr，结果返回新的数组 function prepend(arr, item) { return [item].concat(arr); } function prepend(arr, item) { var newArr = arr.slice(0); newArr.unshift(item); return newArr; } 删除数组 arr 第一个元素删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组 function curtail(arr) { return arr.slice(1); } 合并数组 arr1 和数组 arr2合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组 function concat(arr1, arr2) { return arr1.concat(arr2); } 在数组 arr 的 index 处添加元素 item在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组 function insert(arr, item, index) { var newArr = arr.slice(0); newArr.splice(index,0,item); return newArr; } 统计数组 arr 中值等于 item 的元素出现的次数统计数组 arr 中值等于 item 的元素出现的次数 function count(arr, item) { var c=0; for(e in arr){ if(arr[e]==item){ c++; } } return c; } 生成m到n的区间随机数生成m到n的区间随机数 function getRand(m, n) { var random = Math.floor(Math.random() * (n - m + 1) + m); return random; } 检查数组里是否包含了某值检查数组里是否包含了某值 arr.includes(item);//结果返回true和false 编写一个javscript函数 fn编写一个javscript函数 fn，该函数有一个参数 n(数字类型)，其返回值是一个数组，该数组内是 n 个随机且不重复的整数，且整数取值范围是 [2, 32]。 //fn函数 function fn(n) { var arr = []; for (var i = 0; i &lt; n; i++) { var rnd = getRand(2, 32); if (arr.includes(rnd)) { i--;//减一是因为如果第i次循环的时候如果数组有了改值，就重新走一遍 } else { arr.push(rnd); } } return arr; } //生成区间随机数 function getRand(m, n) { var random = Math.floor(Math.random() * (n - m + 1) + m); return random; } //检查是否重复,这里直接用了 arr.includes(e) function checkInArr(e,arr){ if(arr.indexOf(e)==-1){ return false; } return true; } //console.log(fn(5)); 打乱一个数组randomArr.sort(function () { return Math.random() &gt; 0.5 ? -1 : 1; }); 动态添加行function AddRow(json) { //json: [{&quot;OperatorNum&quot;:&quot;8000011&quot;,&quot;TollT&quot;:1,&quot;TollY&quot;:2,&quot;TollS&quot;:3,&quot;TollC&quot;:4,&quot;ArrearageNum&quot;:5,&quot;ArrearageToll&quot;:6,&quot;AddNum&quot;:7,&quot;AddToll&quot;:8},{&quot;OperatorNum&quot;:&quot;总计&quot;,&quot;TollT&quot;:1,&quot;TollY&quot;:2,&quot;TollS&quot;:3,&quot;TollC&quot;:4,&quot;ArrearageNum&quot;:5,&quot;ArrearageToll&quot;:6,&quot;AddNum&quot;:7,&quot;AddToll&quot;:8}] $(&#39;#tbody&#39;).html(&#39;&#39;); for (key in json) { var _tr = $(&quot;&lt;tr&gt;&lt;/tr&gt;&quot;); for (var k in json[key]) { var _td = $(&quot;&lt;td&gt;&quot; + json[key][k] + &quot;&lt;/td&gt;&quot;); _tr.append(_td); } $(&#39;#tbody&#39;).append(_tr); } } a标签的一些用法&lt;a href=&quot;javascript:void(alert(&#39;Warning!!!&#39;))&quot;&gt;点我弹窗&lt;/a&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;点我没效果&lt;/a&gt; &lt;a href=&quot;#pos&quot;&gt;点我定位到指定位置&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;点我定位到顶部&lt;/a&gt; 计算给定数组 arr 中所有元素的总和//一般的方法 function sum(arr) { var sum = 0; for(var i =0;i&lt;arr.length;i++){ sum = sum +arr[i]; } return sum; } //或者可以这样 function sum(arr) { return eval(arr.join(&quot;+&quot;)) } checkbox的一些用法$(&quot;input[name=&#39;WeiZhi&#39;]&quot;); //选取name为xx的元素 $(&quot;input[type=&#39;checkbox&#39;]&quot;).prop(&#39;checked&#39;,true); //设置checkbox选中 $(&quot;input[type=&#39;checkbox&#39;]&quot;).attr(&#39;checked&#39;); //两种结果 &quot;checked&quot;和undefined，注意引号！ $(&quot;input[name=&#39;WeiZhi&#39;]:checked&quot;).length; // 选中的个数 小数转百分数function toPercent(point) { return Number(point * 100).toFixed(2) + &quot;%&quot;;//保留2位小数 } 清除浮动.clearfix:after, { content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden; } 获取事件源function test(){ var event = event? event: window.event; var srcObj = ((event.srcElement)?event.srcElement:event.target); alert($(srcObj)); } 阻止页面的表单元素自动联想填满&lt;form id=&quot;Content&quot; autocomplete=&quot;off&quot;&gt; autocomplete=&quot;off&quot;用来阻止浏览器自动填充（联想） 动态创建tablevar json = eval(msg); var tab = &quot;&quot;; if (json.length &gt; 0) { $.each(json, function (i, n) { var num = i + 1; tab += &quot; &lt;tr&gt; &lt;td style=&#39;text-align:center;&#39;&gt;&quot; + num + &quot;&lt;/td&gt; &lt;td&gt;&quot; + n.NianFen + &quot;&lt;/td&gt; &lt;td&gt;&quot; + n.YueFen + &quot;&lt;/td&gt; &lt;td&gt;&quot; + n.SFZName + &quot;&lt;/td&gt; &lt;td&gt;&quot; + n.DFNum + &quot;&lt;/td&gt; &lt;td&gt;&quot; + n.PJF + &quot;&lt;/td&gt; &lt;td&gt;&quot; + n.ZongFenShu + &quot;&lt;/td&gt; &lt;td&gt;&quot; + n.RenShu + &quot;&lt;/td&gt; &lt;/tr&gt;&quot;; }) $(&quot;#tbody&quot;).html(tab); } 查看的绑定var json = eval(msg); if (json.length &gt; 0) { for (var key in json[0]) { $(&quot;#&quot; + key).text(json[0][key]); } } 让input只能输入正整数&lt;input type=&quot;text&quot; onkeyup=&quot;this.value=this.value.replace(/\\D/g,&#39;&#39;)&quot; 注意：一般在JS中拼接的时候 符号 \\ 会被视为转义字符，最后页面显示的是.replace(/D/g,&#39;&#39;)&quot; 。 所以在JS拼接时可以这样：.replace(/\\\\D/g,&#39;&#39;)&quot; 自适应屏幕大小document.getElementById(&#39;InforList&#39;).style.width = document.body.clientWidth * 0.90 + &quot;px&quot;; document.getElementById(&#39;InforList&#39;).style.height = window.innerHeight * 0.75 + &quot;px&quot;; 获取选中的下拉列表的value和textvar index = $(&#39;#HuoJia&#39;)[0].selectedIndex; // 选中索引 var HuoJia = $(&#39;#HuoJia&#39;)[0].options[index].text; // 选中文本 $(&quot;#HuoJia&quot;).find(&quot;option:selected&quot;).text() //简洁 join, split, splice, substring的区别join(&#39;,&#39;)是将数组用逗号隔开，转化为字符串 split(&#39;-&#39;)是以字符串中的-符号转化为数组 splice(3,1)是返回 从下标索引为3的位置切割出长度为1的字符 str.substring(3,5)是截取两个指定下标位置的字符串，这个是下标为3和5的位置 选择器的权重在写侧边栏点击变色的时候可以选择为li的点击事件加上addClass(&#39;active&#39;)和removeClass(&#39;active&#39;),但是在样式表里你不能直接写.active的样式 注意看看之前有没有写过li的样式，比如你点击的这个li上级的class为.side，假如之前写过.side&gt;li{ background-color:red; }的样式，点击虽然可以为li加上class，但是 .active{ background-color:black; }的样式不能体现，这时候这样写就行了.side&gt;.active{ background-color:black; }，因为子元素选择器的权重比较高，会覆盖其他单独class的样式 背景图片充满屏幕/*背景图片充满屏幕的时候可以这样避免图片大小的因素*/ &lt;div style=&quot;position: absolute; width: 100%; height: 100%; z-index: -1&quot;&gt; &lt;img id=&quot;bgcolor&quot; style=&quot;position: fixed;&quot; src=&quot;~/Images/icon_login02.jpg&quot; width=&quot;100%&quot;/&gt; &lt;/div&gt; background: linear-gradient(#24a8e6, #44a9dc, #6bc5ec);/*渐变色。注意是background,不是background-color*/ 隐藏侧边导航的滚动条::-webkit-scrollbar{width:0px;} /*隐藏侧边导航的滚动条，只支持webkit内核的浏览器*/ 常用的返回上一页方法window.location.href = &quot;/XXX/XXX&quot;; window.location.href = document.referrer; history.back(-1); window.history.back(); history.go(-1); 回到顶部$(window).scroll(function () { var scrollt = document.documentElement.scrollTop + document.body.scrollTop; if ( scrollt &gt; 700 ){ $(&quot;.to-top&quot;).fadeIn(500); } else { $(&quot;.to-top&quot;).fadeOut(500); } }); $(&quot;.to-top&quot;).click(function(){ $(&quot;html,body&quot;).animate({scrollTop: 0}, 1000); }); 防止用户选中文字onselectstart：return false; -webkit-user-select:none; 阴影和背景渐变色阴影： div{box-shadow: 10px 10px 5px #888888;} 背景渐变色： background: -webkit-gradient(linear, 0% 0%, 0% 100%, from(white), to(#cdcdcd)); 悬浮放大.newSongBody div img,.singerBody div img{ transition: transform 0.7s ; } .newSongBody div:hover img,.singerBody div:hover img { transform: scale(1.08,1.08); } 超出div的部分省略号：.resourceDiv{ width:80px; height:80px; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; display:block; } enter键代替按钮点击document.onkeydown = function (event) { var e = event || window.event || arguments.callee.caller.arguments[0]; if (e &amp;&amp; e.keyCode == 13) { // enter 键 Login(); } }","categories":[{"name":"汇总篇","slug":"汇总篇","permalink":"http://zc95.github.io/categories/汇总篇/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"},{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://zc95.github.io/tags/jquery/"}]},{"title":"在Mac下通过Hexo在Github上搭建博客（入门篇）","slug":"hexoBlog","date":"2017-10-20T13:48:28.000Z","updated":"2017-11-03T10:51:34.113Z","comments":true,"path":"2017/10/20/hexoBlog/","link":"","permalink":"http://zc95.github.io/2017/10/20/hexoBlog/","excerpt":"","text":"Hexo 快速，简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。Hexo支持Github Flavored Markdown的所有功能，甚至可以整合Octopress的大多数插件，并自己也拥有强大的插件系统。 Hexo github Node.js Git markdown themes bash命令 npm SSH 什么是Hexo？ Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 Markdown（或其他渲染引擎，之后会解释什么是Markdown）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 前期准备安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js （安装Recommended For Most Users那个版本） Git 安装Hexo当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：命令就是你的Launchpad里叫 终端 的app，相当于win的cmd以下出现的$都不是命令的一部分 $ npm install -g hexo-cli全局安装 hexo 模块， 如果下面的操作报错则需要卸载 hexo：$ npm uninstall hexo 再重新安装 hexo：$ sudo npm install -g hexo输入管理员密码（Mac登录密码）即开始安装 创建博客目录初始化, 在指定目录中创建文件目录，以 blog 为例： $ hexo init blog blog是你建立的文件夹名称，cd到blog文件夹下，安装npm： $ cd blog $ npm install 创建一篇新文章以创建博客 firstBlog为例，标题中包含空格需要用引号将标题引起来 $ hexo new firstBlog执行该命令后在source/_posts目录下生成文件 生成博客页面 $ hexo generate执行该命令后会生成public目录 $ hexo sever执行命令后启动服务，访问http://localhost:4000/可查看博客 注意： 之后每次修改完你的博客或者配置内容，都需要用$ hexo sever来开启hexo服务器预览 按 Ctrl+C 停止服务器，以便于进行其他操作 关联Github在进行这一步时你需要一个github账号，到 github官网 用邮箱注册就行，名字尽量简短有意义，我的github地址：https://github.com/zc95 创建仓库登录你的Github帐号，新建仓库，一定要是名为 用户名.github.io 的固定写法（如 zc95.github.io ），我的仓库地址：https://github.com/zc95/zc95.github.io 上传到 github首次使用配置： $ npm install hexo-deplorer-git –save安装 hexo-deplorer-git 打开新建的blog文件夹，找到 _config.yml 配置文件，用记事本打开，Ctrl+F来搜索deploy，type改为git，repository改为你自己的仓库地址，在配置博客站点的_config.yml文件时（包括theme主题站点中的_config.yml），在所有的冒号: 后边都要加一个空格，否则执行hexo命令会报错，切记 切记 deploy:type: gitrepository: 你的仓库地址branch: master ok，可以尽情装逼了。。。 hexo g == hexo generate #生成页面文件 hexo s == hexo server #启动服务预览 hexo d == hexo deploy # 部署到GitHub 常用命令 git clone #克隆主题时用到 cd blog #进入blog文件夹 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g == hexo generate #生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy # 部署 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d #你应该看得懂… 关于作者var author = { Name : &quot;张成&quot;, Blog : &quot;http://zc95.github.io&quot; }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://zc95.github.io/tags/Hexo/"},{"name":"github","slug":"github","permalink":"http://zc95.github.io/tags/github/"},{"name":"Node.js","slug":"Node-js","permalink":"http://zc95.github.io/tags/Node-js/"},{"name":"markdown","slug":"markdown","permalink":"http://zc95.github.io/tags/markdown/"},{"name":"npm","slug":"npm","permalink":"http://zc95.github.io/tags/npm/"},{"name":"博客","slug":"博客","permalink":"http://zc95.github.io/tags/博客/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-18T16:10:04.000Z","updated":"2017-10-18T16:10:04.000Z","comments":true,"path":"2017/10/19/hello-world/","link":"","permalink":"http://zc95.github.io/2017/10/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}