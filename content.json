{"meta":{"title":"张成的学习笔记","subtitle":null,"description":null,"author":"张成","url":"http://zc95.github.io"},"pages":[{"title":"关于我","date":"2017-12-09T06:56:47.000Z","updated":"2018-08-12T14:47:20.719Z","comments":true,"path":"about/index.html","permalink":"http://zc95.github.io/about/index.html","excerpt":"","text":"很高兴大家能来到我的博客，或者说我的学习笔记。 我不是什么大牛，只是一个小菜鸟罢了。 前端技能： HTML、CSS、JS、Ajax、jQuery、Bootstrap、 vue全家桶、iview、webpack、node等 喜欢追求新事物，喜欢总结，喜欢刨根问底。 热爱前端、热爱苏州，想在这座城市扎根。 未来计划？ 目前还是着重web前端，夯实基础，以后的事还没想好。 梦想就是金鸡湖或者独墅湖边上有一套湖景三居室哈哈 姓名：张成 生日：1995/07 GitHub地址：https://github.com/zc95 邮件：571346800@qq.com 电话：17751435450 QQ: 571346800 邮箱：571346800@qq.com 关于本博客：可以看我写的hexo小白教程，或者官网"},{"title":"categories","date":"2018-03-31T04:42:28.182Z","updated":"2018-03-31T04:42:28.174Z","comments":true,"path":"categories/index.html","permalink":"http://zc95.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-03-31T04:43:45.032Z","updated":"2018-03-31T04:43:45.016Z","comments":true,"path":"tags/index.html","permalink":"http://zc95.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"美团、支付宝、微信扫码支付","slug":"alipay","date":"2018-08-10T15:54:01.000Z","updated":"2018-08-10T15:56:38.302Z","comments":true,"path":"2018/08/10/alipay/","link":"","permalink":"http://zc95.github.io/2018/08/10/alipay/","excerpt":"","text":"&lt;template&gt; &lt;div&gt; &lt;div class=&quot;orderInfo&quot;&gt; &lt;p&gt;支付方式： &lt;Select v-model=&quot;orderInfo.payType&quot;&gt; &lt;Option value=&quot;CASH&quot;&gt;现金&lt;/Option&gt; &lt;Option value=&quot;WECHAT&quot;&gt;微信&lt;/Option&gt; &lt;Option value=&quot;ALIPAY&quot;&gt;支付宝&lt;/Option&gt; &lt;/Select&gt; &lt;/p&gt; &lt;div v-if=&quot;orderInfo.payType!=&#39;CASH&#39;&quot;&gt; &lt;p v-show=&quot;authCode==&#39;&#39;&quot;&gt;等待扫码&lt;/p&gt; &lt;p v-show=&quot;authCode!==&#39;&#39;&quot;&gt;正在扫码&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div slot=&quot;footer&quot;&gt; &lt;Button type=&quot;ghost&quot;&gt;取消&lt;/Button&gt; &lt;Button v-if=&quot;orderInfo.payType==&#39;CASH&#39;&quot; type=&quot;primary&quot; @click=&quot;handleSureOrder&quot;&gt; 确定 &lt;/Button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: [&#39;orderInfo&#39;, &#39;orderShow&#39;], data() { return { spinShow: false, authCode: &#39;&#39;, } }, watch: { &#39;orderInfo.payType&#39;(type) { let _this = this; window.onkeyup = function (e) { if (type !== &#39;CASH&#39; &amp;&amp; _this.orderShow) { _this.doKeyup(e) } } }, authCode() { setTimeout(() =&gt; { this.authCode = &#39;&#39; }, 1200) } }, methods: { doKeyup(e) { let keyCode = e.keyCode let keyValue = e.key if (keyCode &gt;= 48 &amp;&amp; keyCode &lt;= 57) { this.authCode += keyValue } else if (keyCode === 13 &amp;&amp; this.authCode !== &#39;&#39;) { this.handleSureOrder() this.authCode = &#39;&#39; } }, handleSureOrder() { // ... } } } &lt;/script&gt;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"如何使用js调用摄像头拍照","slug":"mediaDevices","date":"2018-07-28T14:55:59.000Z","updated":"2018-07-28T15:34:19.163Z","comments":true,"path":"2018/07/28/mediaDevices/","link":"","permalink":"http://zc95.github.io/2018/07/28/mediaDevices/","excerpt":"","text":"MediaDevices.getUserMedia()MediaDevices.getUserMedia() 会提示用户给予使用媒体输入的许可，媒体输入会产生一个MediaStream，里面包含了请求的媒体类型的轨道。此流可以包含一个视频轨道（来自硬件或者虚拟视频源，比如相机、视频采集设备和屏幕共享服务等等）、一个音频轨道（同样来自硬件或虚拟音频源，比如麦克风、A/D转换器等等），也可能是其它轨道类型。 它返回一个 Promise 对象，成功后会resolve回调一个 MediaStream 对象。若用户拒绝了使用权限，或者需要的媒体源不可用，promise会reject回调一个 PermissionDeniedError 或者 NotFoundError 。 返回的promise对象可能既不会resolve也不会reject，因为用户不是必须选择允许或拒绝。 通常你可以使用 navigator.mediaDevices 来获取 MediaDevices ，例如： navigator.mediaDevices.getUserMedia(constraints) .then(function(stream) { /* 使用这个stream stream */ }) .catch(function(err) { /* 处理error */ }); 关于参数 constraints 同时请求音频和视频 { audio: true, video: true } 使用1280x720的摄像头分辨率 { audio: true, video: { width: 1280, height: 720 } } 在移动设备优先使用前置摄像头 { audio: true, video: { facingMode: “user” } } 强制使用后置摄像头 { audio: true, video: { facingMode: { exact: “environment” } } } vue项目实战&lt;Modal v-model=&quot;photoDialog&quot;&gt; &lt;p slot=&quot;header&quot; style=&quot;text-align:left&quot;&gt; &lt;Icon type=&quot;android-camera&quot;&gt;&lt;/Icon&gt; &lt;span&gt;打卡&lt;/span&gt;&lt;/p&gt; &lt;div style=&quot;text-align:center&quot;&gt; &lt;Spin size=&quot;large&quot; fix v-if=&quot;spinShow&quot;&gt;&lt;/Spin&gt; &lt;video v-show=&quot;!took&quot; ref=&quot;video&quot; width=&quot;320&quot; height=&quot;240&quot; autoplay&gt;&lt;/video&gt; &lt;canvas v-show=&quot;took&quot; ref=&quot;canvas&quot; width=&quot;320&quot; height=&quot;240&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;div slot=&quot;footer&quot; style=&quot;text-align: right&quot;&gt; &lt;span v-if=&quot;!took&quot; @click=&quot;takePhoto&quot; style=&quot;margin: 3px 0; display: inline; margin-left: 10px;&quot;&gt;&lt;Button type=&quot;primary&quot;&gt;拍照&lt;/Button&gt;&lt;/span&gt; &lt;span v-if=&quot;took&quot; @click=&quot;initCamera&quot; style=&quot;margin: 3px 0; display: inline; margin-left: 10px;&quot;&gt;&lt;Button&gt;重拍&lt;/Button&gt;&lt;/span&gt; &lt;span v-if=&quot;took&quot; @click=&quot;&quot; style=&quot;margin: 3px 0; display: inline; margin-left: 10px;&quot;&gt;&lt;Button type=&quot;primary&quot;&gt;提交&lt;/Button&gt;&lt;/span&gt; &lt;/div&gt; &lt;/Modal&gt; export default { data() { return { photoDialog: false spinShow: false, took: false, stream: null, took: false, attendance: { content: &#39;&#39; } } }, watch: { photoDialog(val, oldVal) { if (!val) { this.stream.getVideoTracks()[0].stop(); //监听弹窗状态来关闭摄像头 } }, }, methods: { ClockIn() { this.photoDialog = true; this.initCamera() }, initCamera() { let _this = this; _this.spinShow = true; _this.took = false; if (navigator.mediaDevices.getUserMedia) { navigator.mediaDevices.getUserMedia({ &#39;video&#39;: true }).then(function(stream) { _this.stream = stream; _this.$refs.video.src = window.URL.createObjectURL(stream); setTimeout(function() { _this.spinShow = false; }, 800) }). catch(function(err) { console.log(err); }); } }, takePhoto() { var context = this.$refs.canvas.getContext(&#39;2d&#39;); context.drawImage(this.$refs.video, 0, 0, 320, 240); this.attendance.content = this.$refs.canvas.toDataURL(&#39;image/jpeg&#39;); this.stream.getVideoTracks()[0].stop(); this.took = true }, } }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"Material Page","slug":"material-page","date":"2018-06-11T11:55:03.000Z","updated":"2018-06-11T12:01:19.364Z","comments":true,"path":"2018/06/11/material-page/","link":"","permalink":"http://zc95.github.io/2018/06/11/material-page/","excerpt":"","text":"Material Page Nature, Pure 原质，纯粹 Material Page 是一个客制化上网首页 基于 Material Design &amp; vuetifyjs &amp; Vue.js 集成搜索，网站收藏和分类，TODO 链接demo：https://zc95.github.io/demo/material-page/index.html github：https://github.com/zc95/material-page 功能 搜索：Google + Bing + 百度 网站：可自定义网站列表 TODO: 简单的 Todo 列表 使用# install dependencies npm install # serve with hot reload at localhost:8080 npm run dev # build for production with minification npm run build For a detailed explanation on how things work, check out the guide and docs for vue-loader.","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"如何把你的demo打包成一个app","slug":"package-app","date":"2018-05-27T06:52:16.000Z","updated":"2018-05-27T06:57:11.539Z","comments":true,"path":"2018/05/27/package-app/","link":"","permalink":"http://zc95.github.io/2018/05/27/package-app/","excerpt":"","text":"如何将你的html代码打包成一个app？那就是HBuilder，无论是只有一个页面的小demo，还是一个完整的vue项目，都可以变成原生app。 准备好项目新建一个文件夹，里面放入你的文件，我这里以一个页面为例，里面就写了一句页面跳转到博客的js语句。 如果是Vue项目，npm run build之后找到dist文件夹打开就行。 下载HBuilder进入 官网 下载就行 打开目录点击 文件/打开目录… 选择你刚刚的项目。 转换成移动app右击刚刚打开的项目选择 转换成移动app ，此时，项目前的W图标变成了A，然后文件夹里就多了一个manifest文件，我们可以在这里配置app的名字、图标、载入动画、入口页面、是否全屏或者一些更高的权限（摄像头，阿里支付等） 注意上传图标的时候，尽量选择1024 1024的图标，如果是ios则必须1024 1024，然后点击自动生成所有图标并替换 开始打包选择 发行/云打包-打原生安装包 ，然后按提示操作就行。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"app","slug":"app","permalink":"http://zc95.github.io/tags/app/"}]},{"title":"本地开启的localhost服务器如何在移动设备访问","slug":"mobilewatchlocalhost","date":"2018-05-26T03:36:42.000Z","updated":"2018-06-05T13:25:17.981Z","comments":true,"path":"2018/05/26/mobilewatchlocalhost/","link":"","permalink":"http://zc95.github.io/2018/05/26/mobilewatchlocalhost/","excerpt":"","text":"当vue-cli为我们开启了一个本地服务器如：http://localhost:8080，我们该怎么在手机或平板上查看呢。 1.找到 config/index.js ，将红色方框内原来的localhost改成0.0.0.0，表示底层的TCP bind IP结构体被置为全0，就允许监听本机全部网卡。 2.新建命令 ifconfig（Windows用户是ipconfig），找到本机ip地址 3.打开浏览器把localhost换成刚刚的ip http://192.168.2.238:8080，发现仍然可以访问 4.打开草料二维码粘贴生成二维码，手机微信扫一扫就好啦","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"localhost","slug":"localhost","permalink":"http://zc95.github.io/tags/localhost/"},{"name":"ifconfig","slug":"ifconfig","permalink":"http://zc95.github.io/tags/ifconfig/"}]},{"title":"我的第一个vue项目[饿了么app]","slug":"vue-sell","date":"2018-05-25T14:00:24.000Z","updated":"2018-06-06T16:26:49.281Z","comments":true,"path":"2018/05/25/vue-sell/","link":"","permalink":"http://zc95.github.io/2018/05/25/vue-sell/","excerpt":"","text":"这是一个饿了么外卖app开发笔记，记录我的第一个vue项目的开发过程。 暂时还没做完就不上图了。。。 Linkgithub地址：https://github.com/zc95/vue-sell 手机预览：https://zc95.github.io/demo/vue-sell/ 二维码： vue-cli脚手架 搭建基本代码框架 全局安装vue-cli $ npm install hexo-cli -g 创建一个基于webpack模版的新项目，基本配置看下图 $ vue init webpack vue-sell 安装依赖，开启localhost本地服务器 $ cd vue-sell $ npm run dev 引入准备好的字体图标慕课准备好了图标，这一步就省略了，可以去 icomoon.io 自己打包图标 mock数据（模拟后台数据）1.将准备好的 data.json 模拟数据文件放到根目录下 2.打开build/webpack.dev.conf.js 文件编写数据接口 const appData = require(&#39;../data.json&#39;) const seller = appData.seller const goods = appData.goods const ratings = appData.ratings before(app) { app.get(&#39;/api/seller&#39;, function (req, res) { res.json({ errno: 0, data: seller }) }); app.get(&#39;/api/goods&#39;, function (req, res) { res.json({ errno: 0, data: goods }) }); app.get(&#39;/api/ratings&#39;, function (req, res) { res.json({ errno: 0, data: ratings }) }); } 3.浏览器中打开 http://localhost:8080/api/seller 查看数据是否能正常访问，我们可以安装谷歌插件 JSONView 让数据格式化，然后依次查看goods ratings数据是否正常。 重置css样式引入reset.css即可 CSS预处理器 stylus 的安装1.在 package.json 文件中写入依赖 “stylus”: “^0.54.5”, “stylus-loader”: “^3.0.1”, 然后安装依赖，mac用户需要加sudo，win不需要 sudo npm install npm run dev 头部组件的命名问题因为 header 是html5的一个原生的标签，组件名字和它有冲突。 [Vue warn]: Do not use built-in or reserved HTML elements as component id: header 修改后： &lt;v-header&gt;&lt;/v-header&gt; &lt;script&gt; import header from &#39;./components/header/header.vue&#39; export default { components:{ &#39;v-header&#39;:header } } &lt;/script&gt; ESLint规范ESLint是一种代码检测工具，空格、分号各种报错。。。当然我们可以在配置里面注释它，但是有良好的代码习惯还是很重要的，一个个解决吧～ Missing space before value for key ‘v-header’ ‘v-header’:header 缺少空格，改： ‘v-header’: header Extra semicolon 有无用的分号，删掉 好麻烦，还是直接在 build/webpack.base.conf.js 禁止检测吧 //…(config.dev.useEslint ? [createLintingRule()] : []), 重启服务器，世界都清净了。。。 vue-routerApp.vue &lt;template&gt; &lt;div&gt; &lt;v-header :seller=&quot;seller&quot;&gt;&lt;/v-header&gt; &lt;div class=&quot;tab border-1px&quot;&gt; &lt;div class=&quot;tab-item&quot;&gt; &lt;router-link to=&quot;/goods&quot;&gt;商品&lt;/router-link&gt; &lt;/div&gt; &lt;div class=&quot;tab-item&quot;&gt; &lt;router-link to=&quot;/ratings&quot;&gt;评论&lt;/router-link&gt; &lt;/div&gt; &lt;div class=&quot;tab-item&quot;&gt; &lt;router-link to=&quot;/seller&quot;&gt;商家&lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/div&gt; &lt;/template&gt; components/router/index.js import Vue from &#39;vue&#39;; import Router from &#39;vue-router&#39;; import goods from &#39;components/goods/goods&#39;; import ratings from &#39;components/ratings/ratings&#39;; import seller from &#39;components/seller/seller&#39;; Vue.use(Router); const routes = [{ path: &#39;/&#39;, redirect: &#39;/goods&#39; }, { path: &#39;/goods&#39;, component: goods }, { path: &#39;/ratings&#39;, component: ratings }, { path: &#39;/seller&#39;, component: seller }]; export default new Router({ linkActiveClass: &#39;active&#39;, routes }); 本地开启的服务如果在手机上调试可以看我的另外一篇文章：https://zc95.github.io/2018/05/26/mobilewatchlocalhost/ 路径优化之resolveresolve.extensions 在webpack.base.conf.js中，我们可以看到resolve配置，其中的extengsions是一个数组，如下所示： extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;], 通过这样的配置，我们在组件中过着路由中应用组件时，就可以更为方便的应用，比如： import header from &quot;components/header/header&quot;; 即header.vue这个组件我们不需要添加.vue后缀就可以引用到了 resolve.alias 我们引入组件的时候路径是相对于当前页面的。 但是如果嵌套等更为复杂，那么写起来会比较麻烦。但是如果我们通过这样的配置： alias: { &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39;, &#39;@&#39;: resolve(&#39;src&#39;), &#39;src&#39;: path.resolve(__dirname, &#39;../src&#39;), &#39;common&#39;: path.resolve(__dirname, &#39;../src/common&#39;), &#39;components&#39;: path.resolve(__dirname, &#39;../src/components&#39;) } 这样我们引入组件的时候就不用考虑路径的问题，直接从 src common components 这几层往下找就行 npm run build 打包之后的项目打开后一片空白？npm run build之后打开 dist/index.html 文件，发现一片空白。这是因为打包配置的路径有问题，我们找到 config/ndex.js 这个文件的 build 部分将 assetsPublicPath 的空值改为 ./ // Paths assetsRoot: path.resolve(__dirname, &#39;../dist&#39;), assetsSubDirectory: &#39;static&#39;, assetsPublicPath: &#39;./&#39;, 再次打包，ok了 npm run build 打包之后的项目访问不到数据？我们的数据都是mock的假数据，是存在根目录下的data.json文件，再通过模拟接口调用数据，打包的时候并不会打包这些。 通过判断是开发环境还是生产环境来解决： const ERR_OK = 0; const debug = process.env.NODE_ENV !== &#39;production&#39;; export default { ..., created() { const url = debug ? &#39;/api/seller&#39; : &#39;https://zc95.github.io/demo/vue-sell/api/seller.json&#39;; this.$http.get(url + &#39;?id=&#39; + this.seller.id).then((response) =&gt; { response = response.body; if(response.errno===ERR_OK){ this.seller = response.data; } }); }, ... } CSS Sticky footer布局 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;content-wrapper&gt; &lt;div class=&quot;content&quot;&gt;内容区域，可随机长度&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;close&quot;&gt; &lt;div&gt; &lt;div class =&quot;close&quot;&gt;关闭图标&lt;/div&gt;始终再底部. .container{//总容器为全屏，所以高度为100％ positon: fiexd; top:0; left:0; height:100%; overflow: auto;//如果内容太长，会显示滚动条查看其余内容。 } .content-wrapper{ min-height: 100%;//如果内容不够长时，也保证内容有全屏长度 } .content{ margin-top: 50px;//向上和屏幕顶部保持50px间距 padding-bottom: 50px;//保证内容content区域的底部有50px的空白 } .close{ margin: -64px;//让关闭按钮向content－wrapper里面伸入50px，正好把内容区的50px空白补上； } Vue路由切换时的左滑和右滑效果CSS部分 我们要实现的是左右切换的效果，所以要定义两种动画（左滑和右滑） .transitionBody{ transition: all 0.15s ease; /*定义动画的时间和过渡效果*/ } .transitionLeft-enter, .transitionRight-leave-active { -webkit-transform: translate(100%, 0); transform: translate(100%, 0); /*当左滑进入右滑进入过渡动画*/ } .transitionLeft-leave-active, .transitionRight-enter { -webkit-transform: translate(-100%, 0); transform: translate(-100%, 0); } HTML部分 这里的 keep-alive 是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM，我们要把它也包裹在transition标签内，否则页面将重新渲染，切换的动画也会卡顿 &lt;transition :name=&quot;transitionName&quot;&gt; &lt;keep-alive&gt; &lt;router-view class=&quot;transitionBody&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/transition&gt; JS部分 在Vue组件中，data必须是一个函数，将对象 {transitionName: ‘transitionLeft’} 挂载到Vue实例中，然后我们可以监听路由的 to 和 from 来判断此时应该左滑还是右滑，来动态切换transition的name值。 export default { data() { return { transitionName: &#39;transitionLeft&#39; }; }, watch: { &#39;$route&#39; (to, from) { const arr = [&#39;/goods&#39;,&#39;/ratings&#39;,&#39;/seller&#39;]; const compare = arr.indexOf(to.path)&gt;arr.indexOf(from.path); this.transitionName = compare ? &#39;transitionLeft&#39; : &#39;transitionRight&#39;; } } } 解决vue的变量在setTimeout内部效果失效方法定义一个self暂存this就行啦 var self=this; this.progressShow=true; setTimeout(function(){ self.progressShow=false },3000);","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://zc95.github.io/tags/webpack/"},{"name":"Vue","slug":"Vue","permalink":"http://zc95.github.io/tags/Vue/"},{"name":"mock模拟数据","slug":"mock模拟数据","permalink":"http://zc95.github.io/tags/mock模拟数据/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://zc95.github.io/tags/vue-cli/"},{"name":"饿了么vue项目","slug":"饿了么vue项目","permalink":"http://zc95.github.io/tags/饿了么vue项目/"}]},{"title":"vue-todo","slug":"vue-todo","date":"2018-04-26T16:12:01.000Z","updated":"2018-05-21T15:38:25.650Z","comments":true,"path":"2018/04/27/vue-todo/","link":"","permalink":"http://zc95.github.io/2018/04/27/vue-todo/","excerpt":"","text":"这几天看了点vue，感觉很棒，把之前的todo翻出来用vue写了一下，瞬间少了三分之二的代码😂 demo &amp; 源码demo：https://zc95.github.io/demo/vue-todo github：https://github.com/zc95/ToDo/blob/master/vue-todo.html 扫描二维码，在移动设备上查看： demo对比（前面是vue写的）： 代码量对比 主要代码let todoStorage = { save: function (todos) { localStorage.setItem(&#39;vueTodoStorage&#39;, JSON.stringify(todos)) } } let app = new Vue({ el: &#39;#app&#39;, data: { todos: localStorage.vueTodoStorage ? JSON.parse(localStorage.vueTodoStorage) : [], inputValue: &quot;&quot; }, watch: { todos: { handler: function (items) { todoStorage.save(items); }, deep: true } }, methods: { add() { mdui.prompt(&#39;add a todo&#39;, function (value) { if(value.trim()==&quot;&quot;){ mdui.snackbar({ message: &quot;Can&#39;t be empty!&quot; }); return false; } app.todos.push({ text: value, completed: false }); mdui.snackbar({ message: &#39;A todo has been added.&#39; }); } ); }, removeTodo(index) { this.todos.splice(index, 1); mdui.snackbar({ message: &#39;A todo has been removed.&#39; }); }, deleteAll() { mdui.confirm(&#39;Are you sure you remove all todo?&#39;, function () { app.todos = []; mdui.snackbar({ message: &#39;All todo have been removed.&#39; }); }); }, resetAll() { mdui.confirm(&#39;Are you sure you reset all todo?&#39;, function () { app.todos.forEach(element =&gt; { element.completed = false; }); mdui.snackbar({ message: &#39;All todo have been reset.&#39; }); }); } } })","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"material design","slug":"material-design","permalink":"http://zc95.github.io/tags/material-design/"},{"name":"Vue","slug":"Vue","permalink":"http://zc95.github.io/tags/Vue/"},{"name":"todo","slug":"todo","permalink":"http://zc95.github.io/tags/todo/"}]},{"title":"vue-devtools的安装","slug":"vue-devtools","date":"2018-04-21T17:22:45.000Z","updated":"2018-04-21T17:25:53.079Z","comments":true,"path":"2018/04/22/vue-devtools/","link":"","permalink":"http://zc95.github.io/2018/04/22/vue-devtools/","excerpt":"","text":"vue-devtools 是一款基于chrome游览器的插件，用于调试vue应用，由于国内不能访问谷歌商店（要科学上网），所以安装比较麻烦，写个博客记录一下。 第一步将vue-devtools clone到本地 git clone https://github.com/vuejs/vue-devtools.git 第二步在vue-devtools目录下安装依赖包 cd vue-devtools npm install 第三步编译代码 npm run build 第四步修改 vue-devtools/shells/chrome/manifest.json 文件，将 persistent改成 true 第五步打开chrome，输入 chrome://extensions/ 进入到chrome扩展程序设置页面打开右上角的 开发者模式 点击 加载已解压的扩展程序 选择 vue-devtools/shells/chrome 注意：勾选 允许访问文件网址 至此，vue-devtools已经安装完毕。enjoy it!","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://zc95.github.io/tags/Vue/"},{"name":"vue-devtools","slug":"vue-devtools","permalink":"http://zc95.github.io/tags/vue-devtools/"}]},{"title":"js的函数重载","slug":"overloading","date":"2018-04-15T15:17:48.000Z","updated":"2018-04-16T12:52:48.502Z","comments":true,"path":"2018/04/15/overloading/","link":"","permalink":"http://zc95.github.io/2018/04/15/overloading/","excerpt":"","text":"函数的重载函数重载，简单说，就是函数有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。 所以说，重载函数需要两点：同样的函数名，不同的函数参数。 js到底有没有函数重载如果在我们在一个页面中定义了两个名字相同的函数，则该名字只属于后定义的函数，如下： function add(num){ return num+1; } function add(num){ return num+2; } add(4); //结果为6 在上面的例子中，add()函数被定义了两次，然而，当我们调用他的时候，却直接调用了第二个函数，这说明在JavaScript中，后定义的函数会覆盖先定义的函数。 其实，在java或者.net中都是是存在重载的，那么js中呢？可以肯定的说，js中是不存在重载的，但是我们可以通过其他的方式来模拟重载。 arguments对象当我们在js中在调用一个函数的时候，我们经常会给这个函数传递一些参数，js把传入到这个函数的全部参数存储在一个叫做arguments的东西里面，arguments对象不是一个Array 。它类似于Array，可以使用[i]或者.length，为了代码的严谨度，我们可以用arguments的length属性来判断当前传入参数的个数是否与我们需要的数量一致。 function add(num1, num2){ // 根据arguments.length，对不同的值进行不同的操作 switch(arguments.length) { case 0: /*没有传入任何参数时*/ break; case 1: /*传入一个参数时*/ break; case 2: /*传入两个参数时*/ break; /*case N.....*/ } } 通过这个例子，我们可以看出，通过检查传入函数中参数的数量，JavaScript函数可以做出不同的反应，这可以间接达到重载的目的。 所以，JavaScript是可以模仿函数的重载的。 其他arguments 类数组对象转为真正的数组Array.prototype.slice.apply(arguments); Array.from(arguments); [...arguments]; calleearguments.callee 属性包含当前正在执行的函数。callee 是 arguments 对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。这在函数的名称是未知时很有用，例如在没有名称的函数表达式（也称为匿名函数）内。 以一个求阶乘的方法为例： function fact(n) { if (n &lt; 2) { return n; } else { return n * fact(n - 1); } } console.log(fact(5)); //5*4*3*2=120 匿名函数中： (function (n) { if (n &lt; 2) { return n; } else { return n * arguments.callee(n - 1); } })(5);","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"函数重载","slug":"函数重载","permalink":"http://zc95.github.io/tags/函数重载/"},{"name":"arguments对象","slug":"arguments对象","permalink":"http://zc95.github.io/tags/arguments对象/"}]},{"title":"Node.js构建TCP服务器和TCP客户端","slug":"nodejs-TCP","date":"2018-03-20T13:56:12.000Z","updated":"2018-04-15T15:19:58.967Z","comments":true,"path":"2018/03/20/nodejs-TCP/","link":"","permalink":"http://zc95.github.io/2018/03/20/nodejs-TCP/","excerpt":"","text":"网络是通信互联网的基础，Node.js提供了net、http、dgram模块、分别用来实现TCP、HTTP、UDP的通信。上次的文章《Node.js构建HTTP服务器》实现了HTTP的通信，这篇文章说一说TCP服务器和TCP客户端的构建。 用Node.js创建TCP服务器构建TCP服务器为了使用Node.js创建TCP服务器，首先要使用require(“net”)来加载net模块，然后使用net模块的createServer方法就可以轻松地创建一个TCP服务器。 /** * 构建TCP客户端 */ /* 引入net模块 */ var net = require(&quot;net&quot;); /* 创建TCP服务器 */ var server = net.createServer(function(socket){ console.log(&#39;someone connects&#39;); }) /* 设置连接的服务器 */ server.listen(8000, function(){ console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;); }) 运行这段代码并访问了http://127.0.0.1:8000/的话会看到控制台打印了”someone connects”，表明已经成功连接到这个创建的TCP服务器。 / 设置连接的服务器 /server.listen(8000, function(){​ console.log(“Creat server on http://127.0.0.1:8000/“);}) 上面这段代码实际上触发的是server下的listening事件，等同于： / 设置监听端口 / server.listen(8000); / 设置监听时的回调函数 / server.on(“listening”, function () { ​ console.log(“Creat server on http://127.0.0.1:8000/“); }) 事实上，除了listening事件外，TCP服务器还支持以下事件： connection：当有新的连接创建时触发，回调函数的参数为socket连接对象。 close：TCP服务器关闭的时候触发，回调函数没有参数 error：TCP服务器发生错误的时候触发，回调函数的参数为error对象 下列代码通过net.Server类来创建一个TCP服务器，并添加以上事件。 /** * 通过net.Server类来创建一个TCP服务器 */ /* 引入net模块 */ var net = require(&quot;net&quot;); /* 实例化一个服务器对象 */ var server = new net.Server(); /* 监听 connection 事件 */ server.on(&quot;connection&quot;, function (socket) { console.log(&quot;someone connects&quot;); }); /* 设置监听端口 */ server.listen(8000); /* 设置监听时的回调函数 */ server.on(&quot;listening&quot;, function () { console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;); }) /* 设置关闭时的回调函数 */ server.on(&quot;close&quot;, function () { console.log(&quot;server closed!&quot;); }) /* 设置错误时的回调函数 */ server.on(&quot;error&quot;, function (err) { console.log(&quot;error!&quot;); }) 查看服务器监听的地址当创建了一个TCP服务器后，可以通过server.address()方法来查看这个TCP服务器监听的地址，并返回一个JSON对象。这个对象的属性有： port：TCP服务器监听的端口号 family：说明TCP服务器监听的地址是 IPv6 还是 IPv4 address：TCP服务器监听的地址 /** * 查看服务器监听的地址 */ /* 引入net模块 */ var net = require(&quot;net&quot;); /* 创建TCP服务器 */ var server = net.createServer(function(socket){ console.log(&#39;someone connects&#39;); }) /* 获取地址信息 */ server.listen(8000,function(){ /* 获取地址信息，得到的是一个json { address: &#39;::&#39;, family: &#39;IPv6&#39;, port: 8000 } */ var address = server.address(); /* TCP服务器监听的端口号 */ console.log(&quot;the port of server is&quot;+ address.port); /* TCP服务器监听的地址 */ console.log(&quot;the address of server is&quot;+ address.address); /* 说明TCP服务器监听的地址是 IPv6 还是 IPv4 */ console.log(&quot;the family of server is&quot;+ address.family); }) 连接服务器的客户端数量创建一个TCP服务器后，可以通过server.getConnections()方法获取连接这个TCP服务器的客户端数量。除此之外，也可以通过maxConnections属性来设置这个服务器的最大连接数量，当连接数量超过最大值时，服务器将拒绝新的连接。 /** * 连接服务器的客户端数量 */ /* 引入net模块 */ var net = require(&quot;net&quot;); /* 创建TCP服务器 */ var server = net.createServer(function(socket){ console.log(&#39;someone connects&#39;); /* 设置最大连接数量 */ server.maxConnections=3; server.getConnections(function(err,count){ console.log(&quot;the count of client is &quot;+count); }) }) /* 获取监听端口 */ server.listen(8000,function(){ console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;); }) 你可以打开多个网页输入localhost:8000来测试这段代码，也可以用Telnet命令 telnet localhost 8000 来连接这个TCP服务器（上一篇文章有提到如何用Homebrew安装Telnet：《Homebrew》）。 服务器和客户端之间的通信利用socket.write()可以使TCP服务器发送数据给客户端； socket对象可以用来获取客户端发出的流数据，每次接收到数据的时候触发data事件，通过监听这个事件就可以在回调函数中获取客户端发送的数据了。 /** * 发送和获取 */ /* 引入net模块 */ var net = require(&quot;net&quot;); /* 创建TCP服务器 */ var server = net.createServer(function(socket){ /* 获取地址信息 */ var address = server.address(); var message = &quot;the server address is&quot;+JSON.stringify(address); /* 发送数据 */ socket.write(message,function(){ var writeSize = socket.bytesWritten; console.log(message + &quot;has send&quot;); console.log(&quot;the size of message is&quot;+writeSize); }) /* 监听data事件 */ socket.on(&#39;data&#39;,function(data){ console.log(data.toString()); var readSize = socket.bytesRead; console.log(&quot;the size of data is&quot;+readSize); }) }) /* 获取地址信息 */ server.listen(8000,function(){ console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;); }) 下图中TCP服务器给客户端发送了字符串： the server address is{“address”:”::”,”family”:”IPv6”,”port”:8000}has send 客户端给TCP服务器发送了字符串 hello TCP! 和字节数。 用Node.js创建TCP客户端构建TCP客户端上面说到用打开网页或者Telnet来访问TCP服务器，其实我们也可以用Node.js来构建一个TCP客户端，实现TCP客户端和TCP服务器的通信。 为了使用Node.js创建TCP客户端，首先要使用require(“net”)来加载net模块，然后创建一个连接TCP客户端的socket对象即可： / 引入net模块 / var net = require(“net”); / 创建TCP客户端 / var client = net.Socket(); 创建完socket对象后，使用socket对象的connect方法就可以连接一个TCP服务器。 /** * 构建TCP客户端 */ /* 引入net模块 */ var net = require(&quot;net&quot;); /* 创建TCP客户端 */ var client = net.Socket(); /* 设置连接的服务器 */ client.connect(8000, &#39;127.0.0.1&#39;, function () { console.log(&quot;connect the server&quot;); /* 向服务器发送数据 */ client.write(&quot;message from client&quot;); }) /* 监听服务器传来的data数据 */ client.on(&quot;data&quot;, function (data) { console.log(&quot;the data of server is &quot; + data.toString()); }) /* 监听end事件 */ client.on(&quot;end&quot;, function () { console.log(&quot;data end&quot;); }) TCP客户端和TCP服务器的通信运行 这段代码 之后再运行 这段代码 ，可以发现服务器已经接收到客户端的数据，客户端也已经接收到服务端的数据。 LINK 本章github源码：https://github.com/zc95/nodeTest/tree/master/TCP 《Node.js构建HTTP服务器》：https://zc95.github.io/2018/03/19/nodejs-HTTP/ 用Homebrew安装Telnet：https://zc95.github.io/2018/03/20/Homebrew/","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://zc95.github.io/tags/Node-js/"},{"name":"TCP","slug":"TCP","permalink":"http://zc95.github.io/tags/TCP/"}]},{"title":"Homebrew","slug":"Homebrew","date":"2018-03-20T13:31:52.000Z","updated":"2018-03-21T14:58:14.483Z","comments":true,"path":"2018/03/20/Homebrew/","link":"","permalink":"http://zc95.github.io/2018/03/20/Homebrew/","excerpt":"Homebrew简称brew，OSX上的软件包管理工具，在Mac终端可以通过brew安装、更新、卸载软件。 Homebrew 能干什么?Homebrew官网 的title是这么说的：macOS 缺失的软件包管理器，意思就是使用 Homebrew 安装 Apple 没有预装但你需要的东西，比如high sierra 10.13中移除了telnet，只需要 brew install telnet 一个命令就行。","text":"Homebrew简称brew，OSX上的软件包管理工具，在Mac终端可以通过brew安装、更新、卸载软件。 Homebrew 能干什么?Homebrew官网 的title是这么说的：macOS 缺失的软件包管理器，意思就是使用 Homebrew 安装 Apple 没有预装但你需要的东西，比如high sierra 10.13中移除了telnet，只需要 brew install telnet 一个命令就行。 安装 Homebrew一、进入Homebrew官网，按照官网提示在命令行执行ruby脚本（mac自带ruby），在终端运行以下命令： /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 二、按提示输入电脑密码，一路enter到底，直到出现下面的信息就说明安装成功。 ==&gt; Next steps: - Run `brew help` to get started - Further documentation: https://docs.brew.sh 三、运行命令 brew help 就可以了解一些brew常用的命令： Example usage: brew search [TEXT|/REGEX/] brew (info|home|options) [FORMULA...] brew install FORMULA... brew update brew upgrade [FORMULA...] brew uninstall FORMULA... brew list [FORMULA...] Troubleshooting: brew config brew doctor brew install -vd FORMULA Developers: brew create [URL [--no-fetch]] brew edit [FORMULA...] https://docs.brew.sh/Formula-Cookbook Further help: man brew brew help [COMMAND] brew home","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"Homebrew","slug":"Homebrew","permalink":"http://zc95.github.io/tags/Homebrew/"},{"name":"brew","slug":"brew","permalink":"http://zc95.github.io/tags/brew/"},{"name":"telnet","slug":"telnet","permalink":"http://zc95.github.io/tags/telnet/"}]},{"title":"Node.js构建HTTP服务器","slug":"nodejs-HTTP","date":"2018-03-19T12:29:42.000Z","updated":"2018-04-09T14:29:15.156Z","comments":true,"path":"2018/03/19/nodejs-HTTP/","link":"","permalink":"http://zc95.github.io/2018/03/19/nodejs-HTTP/","excerpt":"Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. Node.js简介Node.js 是一个基于 Google Chrome V8 引擎 的 JavaScript 运行环境。Node.js使用后多种先进的技术，其中包括 事件驱动、非阻塞 I/O 模型，使其轻量又高效，受到众多开发者的追捧。 简单的说，Node.js 就是运行在服务端的 JavaScript ，可以稳定地在各种平台下运行，包括Linux、Windows、Mac OS X、Sun Os 和FreeBSD等众多平台。","text":"Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. Node.js简介Node.js 是一个基于 Google Chrome V8 引擎 的 JavaScript 运行环境。Node.js使用后多种先进的技术，其中包括 事件驱动、非阻塞 I/O 模型，使其轻量又高效，受到众多开发者的追捧。 简单的说，Node.js 就是运行在服务端的 JavaScript ，可以稳定地在各种平台下运行，包括Linux、Windows、Mac OS X、Sun Os 和FreeBSD等众多平台。 安装nodejs 点击 https://nodejs.org 进入nodejs官网 有两个版本：LTS和Current，LTS是长期支持版本，成熟可靠 next到底 打开终端，输入 node -v ，回车，如果出现类似 v6.11.4 的版本号就说明安装成功 构建一个HTTP服务器在如今web大行其道的时代，支撑无数网页运行的正是HTTP服务器。Node.js之所以受到大量web开发者的青睐，与Node.js有能力自己构建服务器是分不开的。 在根目录下新建 nodetest 文件夹 在 nodetest 下新建 HTTP 文件夹 在 HTTP 文件夹下新建一个 server.js 的文件 拷贝粘贴这段代码，保存： /** * 创建http服务器 */ /* 引入http模块 */ var http = require(&quot;http&quot;); /* 创建HTTP服务器 */ var server = http.createServer(function(request, response) { /* 设置相应的头部 */ response.writeHead(200, { &quot;content-Type&quot; : &quot;text/plain&quot; }); /* 设置相应的数据 */ response.write(&quot;Welcome to Nodejs&quot;); response.end(); }); /* 设置服务器端口 */ server.listen(8000, function(){ console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;); }) 打开终端 输入 cd nodetest/HTTP 输入 node server.js ，返回 Creat server on http://127.0.0.1:8000/ 打开浏览器输入 http://127.0.0.1:8000/ 或者 http://localhost:8000 Welcome to Nodejs 文件模块上面说到的HTTP服务器知识实现了将一串字符串发送给服务器。很明显，如果服务器只能发送一些字符串，那几乎是远远不够的，因此我们要做一些扩展，通过文件模块将文件读取并发送给服务器是一个不错的选择，在nodetest文件夹下新建 fsModule.js : /** * fs模块 */ /* 引入http模块 */ var http = require(&quot;http&quot;); /* 引入fs模块 */ var fs = require(&quot;fs&quot;); /* 创建HTTP服务器 */ var server = http.createServer(function(request, response) { /* 设置响应的头部 */ response.writeHead(200, { &quot;content-Type&quot; : &quot;text/html&quot; }); /* 读取文件数据 */ var data = fs.readFileSync(&quot;./index.html&quot;); /* 设置响应的数据 */ response.write(data); response.end(); }); /* 设置服务器端口 */ server.listen(8000, function(){ console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;); }) 同时在同级目录中创建一个名为 index.html 的文件，写入以下代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;title&gt;fs module&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;fs文件模块&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; node fsModule.js 运行，在浏览器中打开 http://localhost:8000 ，Node.js已经把index这个文件发送到客户端了； 需要提及的是，这里HTTP服务器在发送给浏览器的头部信息中将 content-type修改为了 text/html 。 content-type的人作用就是用来表示客户端或者服务器传输数据的类型，服务器或者客客户端通过这个值来做相应的解析。如果这个值改为原来的 text/plain ，浏览器将显示index.html的所有源代码，这显然不是我们想要的。 HTTP服务器的路由控制上一节中的服务器虽然已经可以通过读取文件数据来发送给客户端了，但你并没有做任何的路由控制，在浏览器中输入任何URL都将返回同样的内容，简单来说，路由就是URL到函数的映射。 要做到路由控制，通过上面的学习可以预想到修改content-type就可以了，这里假定只需要处理html、js、css和图片文件，创建一个名为 mime.js 的文件： module.exports = { &quot;.html&quot; : &quot;text/html&quot;, &quot;.css&quot; : &quot;text/css&quot;, &quot;.js&quot; : &quot;text/javascript&quot;, &quot;.gif&quot; : &quot;image/gif&quot;, &quot;.ico&quot; : &quot;image/x-icon&quot;, &quot;.jpeg&quot; : &quot;image/jpeg&quot;, &quot;.jpg&quot; : &quot;image/jpeg&quot;, &quot;.png&quot; : &quot;image/png&quot;, } 创建一个名为 fsModule2.js 的文件： /** * 这里通过路径处理判断来返回不同的资源，从而做到简单的路由控制 */ /* 引入http模块 */ var http = require(&quot;http&quot;); /* 引入fs模块 */ var fs = require(&quot;fs&quot;); /* 引入url模块 */ var url = require(&quot;url&quot;); /* 引入mime文件 */ var mime = require(&quot;./mime.js&quot;); /* 引入path模块 */ var path = require(&quot;path&quot;); /* 创建HTTP服务器 */ var server = http.createServer(function(request, response) { var filePath = &quot;.&quot;+url.parse(request.url).pathname; if(filePath === &quot;./&quot;){ filePath = &#39;./index.html&#39; } /* 判断相应的文件是否存在 */ fs.exists(filePath,function(exists){ /* 存在则返回相应文件数据 */ if(exists){ var data = fs.readFileSync(filePath); var contentType = mime[path.extname(filePath)]; response.writeHead(200,{ &quot;content-type&quot;: contentType }); response.write(data); response.end(); }else{ response.end(&quot;404&quot;); } }) }); /* 设置服务器端口 */ server.listen(8000, function(){ console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;); }) 这里通过对路径处理判断来返回不同的资源，从而做到简单的路由控制。 LINK 本章github源码：https://github.com/zc95/nodeTest/tree/master/HTTP 《Node.js构建TCP服务器和TCP客户端》：https://zc95.github.io/2018/03/20/nodejs-TCP/","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://zc95.github.io/tags/Node-js/"},{"name":"本地服务器","slug":"本地服务器","permalink":"http://zc95.github.io/tags/本地服务器/"}]},{"title":"ES6入门","slug":"es6-webpack","date":"2018-03-13T13:42:52.000Z","updated":"2018-03-20T13:32:31.633Z","comments":true,"path":"2018/03/13/es6-webpack/","link":"","permalink":"http://zc95.github.io/2018/03/13/es6-webpack/","excerpt":"github：https://github.com/zc95/es6-webpack webpack搭建ES6环境首先下载源码 git clone https://github.com/zc95/es6-webpack.git 然后安装 cd es6-webpack npm install npm install webpack -g npm install webpack-dev-server -g 最后运行 cd es6-webpack npm start","text":"github：https://github.com/zc95/es6-webpack webpack搭建ES6环境首先下载源码 git clone https://github.com/zc95/es6-webpack.git 然后安装 cd es6-webpack npm install npm install webpack -g npm install webpack-dev-server -g 最后运行 cd es6-webpack npm start es6基础常量// ES5 中常量的写法 Object.defineProperty(window, &quot;PI2&quot;, { value: 3.1415926, writable: false, }) // ES6 的常量写法 const PI = 3.1415926 箭头函数// ES3,ES5 var evens = [1, 2, 3, 4, 5]; var odds = evens.map(function(v) { return v + 1 }); console.log(evens, odds); }; // ES6 let evens = [1, 2, 3, 4, 5]; let odds = evens.map(v =&gt; v + 1); console.log(evens, odds); this的指向 // ES3,ES5中 this 的指向是 该函数被调用的对象 var factory = function() { this.a = &#39;a&#39;; this.b = &#39;b&#39;; this.c = { a: &#39;a+&#39;, b: function() { return this.a } } } console.log(new factory().c.b()); }; // ES6箭头函数中 this 的指向是 定义时this的指向 var factory = function() { this.a = &#39;a&#39;; this.b = &#39;b&#39;; this.c = { a: &#39;a+&#39;, b: () =&gt; { return this.a } } } console.log(new factory().c.b()); 默认参数默认参数 // ES5\\ES3 默认参数的写法 function f(x, y, z) { if (y === undefined) { y = 7; } if (z === undefined) { z = 42 } return x + y + z } console.log(f(1, 3)); // ES6 默认参数 function f(x, y = 7, z = 42) { return x + y + z } console.log(f(1, 3)); 可变参数 // ES3,ES5 可变参数 function f() { var a = Array.prototype.slice.call(arguments); var sum = 0; a.forEach(function(item) { sum += item * 1; }) return sum } console.log(f(1, 2, 3, 6)); // ES6 可变参数 function f(...a) { var sum = 0; a.forEach(item =&gt; { sum += item * 1 }); return sum } console.log(f(1, 2, 3, 6)); 合并数组 // ES5 合并数组 var params = [&#39;hello&#39;, true, 7]; var other = [1, 2].concat(params); console.log(other); // ES6 利用扩展运算符合并数组 var params = [&#39;hello&#39;, true, 7]; var other = [ 1, 2, ...params ]; console.log(other); 对象代理// ES3,ES5 数据保护 var Person = function() { var data = { name: &#39;es3&#39;, sex: &#39;male&#39;, age: 15 } this.get = function(key) { return data[key] } this.set = function(key, value) { if (key !== &#39;sex&#39;) { data[key] = value } } } // 声明一个实例 var person = new Person(); // 读取 console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)}); // 修改 person.set(&#39;name&#39;, &#39;es3-cname&#39;); console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)}); person.set(&#39;sex&#39;, &#39;female&#39;); console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)}); // ES5 var Person = { name: &#39;es5&#39;, age: 15 }; Object.defineProperty(Person, &#39;sex&#39;, { writable: false, value: &#39;male&#39; }); console.table({name: Person.name, age: Person.age, sex: Person.sex}); Person.name = &#39;es5-cname&#39;; console.table({name: Person.name, age: Person.age, sex: Person.sex}); try { Person.sex = &#39;female&#39;; console.table({name: Person.name, age: Person.age, sex: Person.sex}); } catch (e) { console.log(e); } // ES6 let Person = { name: &#39;es6&#39;, sex: &#39;male&#39;, age: 15 }; let person = new Proxy(Person, { get(target, key) { return target[key] }, set(target,key,value){ if(key!==&#39;sex&#39;){ target[key]=value; } } }); console.table({ name:person.name, sex:person.sex, age:person.age }); try { person.sex=&#39;female&#39;; } catch (e) { console.log(e); } finally { }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://zc95.github.io/tags/ES6/"},{"name":"webpack","slug":"webpack","permalink":"http://zc95.github.io/tags/webpack/"}]},{"title":"撸了一个canvas手写板","slug":"canvasPalette","date":"2018-03-08T15:15:11.000Z","updated":"2018-03-31T04:47:20.741Z","comments":true,"path":"2018/03/08/canvasPalette/","link":"","permalink":"http://zc95.github.io/2018/03/08/canvasPalette/","excerpt":"用 canvas 写了一个手写板，功能：画笔粗细、橡皮擦大小、画笔颜色、清空画布、历史操作等 canvas手写板 demo github","text":"用 canvas 写了一个手写板，功能：画笔粗细、橡皮擦大小、画笔颜色、清空画布、历史操作等 canvas手写板 demo github 扫一扫","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://zc95.github.io/tags/canvas/"},{"name":"material design","slug":"material-design","permalink":"http://zc95.github.io/tags/material-design/"}]},{"title":"自己写了个音乐播放器","slug":"musicPlayer","date":"2018-02-21T04:45:29.000Z","updated":"2018-03-31T04:48:24.864Z","comments":true,"path":"2018/02/21/musicPlayer/","link":"","permalink":"http://zc95.github.io/2018/02/21/musicPlayer/","excerpt":"material design风格的音乐播放器 demo github","text":"material design风格的音乐播放器 demo github 扫一扫 HTML 5 audio标签定义和用法 标签定义声音，比如音乐或其他音频流，是 HTML 5 的新标签。 实例&lt;audio src=&quot;https://music.163.com/song/media/outer/url?id=451703096.mp3&quot;&gt; 您的浏览器不支持 audio 标签。 &lt;/audio&gt; 提示和注释可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。 属性 属性 值 描述 autoplay autoplay 如果出现该属性，则音频在就绪后马上播放。 controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。 loop loop 如果出现该属性，则每当音频结束时重新开始播放。 preload preload 如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。 src url 要播放的音频的 URL。 Javascript控制html5 Audio标签javascript动态创建audio标签var audio=document.creatElement(&quot;audio&quot;); audio.src=&quot;audio/source.ogg&quot;;//路径 audio.play(); or audio=new Audio(&quot;audio/source.ogg&quot;);//路径 audio.play(); 预加载我们可以通过preload=”auto”来实现音频的自动加载，但是我们无法知道音频加载的进度 这时候可以用canplaythrough来完成 var audio = document.createElement(&quot;audio&quot;); audio.src = &quot;https://music.163.com/song/media/outer/url?id=451703096.mp3&quot;; audio.addEventListener(&quot;canplaythrough&quot;, function () { alert(&#39;音频文件已经准备好，随时待命&#39;); }, false); 第一次运行时间会长一些，第二次运行由于文件已经缓存到本地，所以会直接弹出提示框。 javascript控制audio的播放，暂停，停止function aPlay() { audio.play(); } function aPause() { audio.pause(); } function aStop() { audio.currentTime = 0; audio.pause(); } function aSkip() { audio.currentTime = 50; audio.play(); } &lt;input type=&quot;button&quot; onclick=&quot;aPlay();&quot; value=&quot;播放音频&quot;&gt; &lt;input type=&quot;button&quot; onclick=&quot;aPause();&quot; value=&quot;暂停音频&quot;&gt; &lt;input type=&quot;button&quot; onclick=&quot;aStop();&quot; value=&quot;停止音频&quot;&gt; &lt;input type=&quot;button&quot; onclick=&quot;aSkip();&quot; value=&quot;跳到第50秒&quot;&gt; javascript控制audio的声音大小 audio.volume = 0;//表示静音 audio.volume = 1; //表示声音最大 audio.volume //返回当前音量，声音值在0-1之间 javascript控制audio的快进，快退，以及显示进度与时长 audio.currentTime //控制audio的进度 audio.duration //返回当前音量的总时长","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"material design","slug":"material-design","permalink":"http://zc95.github.io/tags/material-design/"}]},{"title":"教你下载会员歌曲","slug":"musicLink","date":"2018-02-19T15:19:04.000Z","updated":"2018-03-31T04:48:47.851Z","comments":true,"path":"2018/02/19/musicLink/","link":"","permalink":"http://zc95.github.io/2018/02/19/musicLink/","excerpt":"教你找歌曲的外链（要会员的歌曲都能下载🤪） 什么是歌曲的外链？我们手机里的歌曲都是下载好的mp3文件，比如说散就散.mp3， 而外链就比如 https://music.163.com/song/media/outer/url?id=523251118.mp3 这样链接的形式。","text":"教你找歌曲的外链（要会员的歌曲都能下载🤪） 什么是歌曲的外链？我们手机里的歌曲都是下载好的mp3文件，比如说散就散.mp3， 而外链就比如 https://music.163.com/song/media/outer/url?id=523251118.mp3 这样链接的形式。 怎么免费下载会员歌曲？你应该注意到了《说散就散》在qq音乐和网易云都是要vip才能下载 这里以网易云音乐的网页版为例说一下”破解“的方法 这个外链下载会员歌曲的方法也是最近撸一个播放器的时候发现的 https://zc95.github.io/demo/music （还在改进，下次再说吧 ，逃。。。） 废话少说，开始了第一步打开你电脑上的浏览器，输入 http://music.163.com ，网易云音乐官网，输入 “说散就散” 搜索，点第一个要钱的原唱！ 第二步到了 http://music.163.com/#/song?id=523251118 这个页面 这个什么 生成外链播放器 不用管，就是个iframe（一般用来博客里），点了提示没版权，放弃。。。 还有下载按钮，点了提示下载PC端和app，肯定还是要会员。。。放弃 重点是url，有个?id = xxxxx ，原来百度云网页版的每首歌都有自己的id标识 第三步从url得到这首歌的id是 523251118 所以这首歌的外链就是 https://music.163.com/song/media/outer/url?id=523251118.mp3 ，之后找到别的歌，把这个链接的id替换了就行，除了那种网易云没播放版权的，所有的都可以。 第四步打开电脑里的浏览器，输入 https://music.163.com/song/media/outer/url?id=523251118.mp3 回车，这时候url被解析成好长的一段，不用管它，有上面的链接就足够了，点html5 video标签上的下载按钮就行啦（如下），移动端和Safari的video应该是没有下载按钮的。。。 第五步如果是安卓机的就直接把这首歌导入到手机里去，qq音乐、网易云都会自动加到列表里去。 如果是iphone，，，那就没啥吊用了。。。。 最后说一下，有很多方法下载这种会员歌曲，，发现这种方法是因为最近在手撸一个音乐播放器，需要用到这样的链接https://zc95.github.io/demo/music 不然才不费这么大劲。。毕竟我有破解版😂😂😂","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"歌曲","slug":"歌曲","permalink":"http://zc95.github.io/tags/歌曲/"}]},{"title":"Rich Text Format","slug":"RTF","date":"2018-02-06T15:20:53.000Z","updated":"2018-03-31T04:49:02.246Z","comments":true,"path":"2018/02/06/RTF/","link":"","permalink":"http://zc95.github.io/2018/02/06/RTF/","excerpt":"自己写的一个移动端的富文本编辑器 Link demo github","text":"自己写的一个移动端的富文本编辑器 Link demo github","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"一行代码实现星级评分","slug":"star-rating","date":"2018-01-23T13:03:13.000Z","updated":"2018-01-30T15:23:57.113Z","comments":true,"path":"2018/01/23/star-rating/","link":"","permalink":"http://zc95.github.io/2018/01/23/star-rating/","excerpt":"实现原理 Link demo github","text":"实现原理 Link demo github 主要代码css.score_wrapper { display:inline-block; font-size: 45px; cursor: pointer; color: #dc2020; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none; } html&lt;div class=&quot;score_wrapper&quot;&gt;&lt;/div&gt; javascript $(function () { ScoreInit(3); //初始化，参数是0～5的数字，代表星数，传空默认0颗星 }) //点击 function ScoreInit(e) { Score((e == null) ? 0 : e); //传空默认0颗星 $(&quot;.score_wrapper&quot;).bind(&#39;click&#39;, function (e) { var eachWidth = $(&quot;.score_wrapper&quot;).width() / 5; //计算出每个星星的长度 var X = e.pageX - $(this).offset().left; //距离父容器的偏移距离 var score = Math.floor(X / eachWidth) + 1; //分数 Score((getScore() == score) ? 0 : score); //取消评分 }) } //评分 function Score(rate) { $(&quot;.score_wrapper&quot;).html(&quot;★★★★★☆☆☆☆☆&quot;.slice(5 - rate, 10 - rate)); } //获取评分 function getScore() { var str = $(&quot;.score_wrapper&quot;).html(), num = 0; for (var i = 0; i &lt; str.length; i++) { if (str[i] == &quot;★&quot;) { num++ } } return num; }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"水平垂直居中","slug":"centerAndmiddle","date":"2018-01-10T13:17:24.000Z","updated":"2018-01-10T14:26:16.029Z","comments":true,"path":"2018/01/10/centerAndmiddle/","link":"","permalink":"http://zc95.github.io/2018/01/10/centerAndmiddle/","excerpt":"水平垂直居中（已知宽高）方法很多，这里就说一个不常见的 &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; .father { position: relative; width: 300px; height: 300px; border: 1px solid black; } .son { position: absolute; width: 60px; height: 60px; top: 0; left: 0; bottom: 0; right: 0; margin: auto; border: 1px solid gray; }","text":"水平垂直居中（已知宽高）方法很多，这里就说一个不常见的 &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; .father { position: relative; width: 300px; height: 300px; border: 1px solid black; } .son { position: absolute; width: 60px; height: 60px; top: 0; left: 0; bottom: 0; right: 0; margin: auto; border: 1px solid gray; } 水平垂直居中（宽高不确定/伪元素）用伪元素和 inline-block / vertical-align 可以实现水平垂直居中 &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; .father { position:fixed; top:0; right:0; left:0; bottom:0; text-align: center; border: 1px solid black; } .father:before { content: &#39;&#39;; display: inline-block; height: 100%; vertical-align: middle; margin-right: -0.25em; /*去空隙*/ } .son { display: inline-block; vertical-align: middle; border: 1px solid gray; } 水平垂直居中（宽高不确定/flex）css弹性布局（flex） &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot; style=&quot;display:inline-block;&quot;&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; .father { height: 300px; width: 100%; display: flex; align-items: center; /*定义body的元素垂直居中*/ justify-content: center; /*定义body的里的元素水平居中*/ } .son{ border:1px solid gray; } 水平垂直居中（宽高不确定/transform）CSS3的transform，通过设置div的transform: translate(-50%,-50%)，使得div向上平移（translate）自身高度的一半(50%)、自身宽度的一半(50%) &lt;div class=&quot;son&quot;&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;/div&gt; .son { position: absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%); border: 1px solid gray; }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"},{"name":"水平垂直居中","slug":"水平垂直居中","permalink":"http://zc95.github.io/tags/水平垂直居中/"}]},{"title":"ToDo 待办事宜app","slug":"ToDo","date":"2018-01-07T10:29:58.000Z","updated":"2018-01-07T12:54:37.261Z","comments":true,"path":"2018/01/07/ToDo/","link":"","permalink":"http://zc95.github.io/2018/01/07/ToDo/","excerpt":"ToDo最近做事情总是丢三落四，老忘记一些重要的事情，就突发奇想写了这个 ToDo 待办事宜的app。 项目地址 github地址","text":"ToDo最近做事情总是丢三落四，老忘记一些重要的事情，就突发奇想写了这个 ToDo 待办事宜的app。 项目地址 github地址 主要功能 可以添加待办事项到首页中，数据都是保存在本地localStorage的，只要不是手动删除或者换了设备，数据是永久保存的 点击事项可以将待办事项的状态改为 选中 和 未选中 ，每次改变状态都会保存到localStorage，每天的开始都可以点 重置所有状态 的按钮来设置所有的待办事项为未选中 可以删除已添加的待办事项或者彻底删除所有本地localStorage数据 可以复制项目链接在自己的浏览器中打开，然后添加到桌面，方便使用；https://htmlpreview.github.io/?https://github.com/zc95/ToDo/blob/master/index.html","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"localStorage","slug":"localStorage","permalink":"http://zc95.github.io/tags/localStorage/"}]},{"title":"VMware服务器虚拟化","slug":"VMware","date":"2017-12-26T12:49:24.000Z","updated":"2017-12-26T13:10:59.660Z","comments":true,"path":"2017/12/26/VMware/","link":"","permalink":"http://zc95.github.io/2017/12/26/VMware/","excerpt":"今天去机房打了一天酱油，听到了看到了一些没接触过的东西，做个简单的整理。 VMware服务器虚拟化VMware官网 大多数服务器的容量利用率不足 15%，这不仅导致了服务器数量剧增，还增加了复杂性。实现服务器虚拟化后，多个操作系统可以作为虚拟机在单台物理服务器上运行，并且每个操作系统都可以访问底层服务器的计算资源，从而解决效率低下问题。接下来将服务器集群聚合为一项整合资源，这可以提高整体效率并降低成本。服务器虚拟化还可以加快工作负载部署速度、提高应用性能以及改善可用性。","text":"今天去机房打了一天酱油，听到了看到了一些没接触过的东西，做个简单的整理。 VMware服务器虚拟化VMware官网 大多数服务器的容量利用率不足 15%，这不仅导致了服务器数量剧增，还增加了复杂性。实现服务器虚拟化后，多个操作系统可以作为虚拟机在单台物理服务器上运行，并且每个操作系统都可以访问底层服务器的计算资源，从而解决效率低下问题。接下来将服务器集群聚合为一项整合资源，这可以提高整体效率并降低成本。服务器虚拟化还可以加快工作负载部署速度、提高应用性能以及改善可用性。 虚拟化的优势虚拟化可以提高 IT 部门的敏捷性、灵活性和可扩展性，同时大幅节约成本。工作负载的部署速度更快、性能和可用性得到提升、运维实现自动化，所有这一切不仅简化了 IT 管理，还降低了拥有成本和运维成本。其他优势包括： 降低资金成本和运维成本。 最大限度地减少或消除停机。 提高 IT 部门的工作效率、效益、敏捷性和响应能力。 更快地调配应用和资源。 支持业务连续性与灾难恢复。 简化数据中心管理。 构建真正的软件定义的数据中心 VMware vSphere client用来连接VMware ESXi主机和vCenter server，业内最完整、 最强健的虚拟化平台。创建资源池来管理计算、 网络和存储容量与易用性，并提供最高水平的服务，每个应用程序工作负载以最低的总成本。VSphere — — 取决于世界上要求最苛刻的数据中心虚拟化您业务关键型应用程序为空前的灵活性和可靠性。 UPS电源百度百科 UPS电源一般指不间断电源。 UPS（Uninterruptible Power System/Uninterruptible Power Supply），即不间断电源，是将蓄电池（多为铅酸免维护蓄电池）与主机相连接，通过主机逆变器等模块电路将直流电转换成市电的系统设备。主要用于给单台计算机、计算机网络系统或其它电力电子设备如电磁阀、压力变送器等提供稳定、不间断的电力供应。当市电输入正常时，UPS 将市电稳压后供应给负载使用，此时的UPS就是一台交流式电稳压器，同时它还向机内电池充电；当市电中断（事故停电）时， UPS 立即将电池的直流电能，通过逆变器切换转换的方法向负载继续供应220V交流电，使负载维持正常工作并保护负载软、硬件不受损坏。UPS 设备通常对电压过高或电压过低都能提供保护。 特点 UPS是针对中国电网环境和网络监控及网络系统、医疗系统等对电源的可靠性要求，克服中、大型计算机网络系统集中供电所造成的供电电网环境日益恶劣的问题，以全新的数字技术研制出的第三代工频纯在线式智能型UPS。直流电源，是维持电路中形成稳恒电流的装置。如干电池、蓄电池、直流发电机等。 UPS和直流电源是企业重要的供电保障设备，传统的维护管理包括：①日常巡检外观，定期更换电池、滤波电容、风机等易损件，大修时做电池活化等；②改造或采用换代设备，使用高级工具测试电池性能。这种管理方式企业投入成本高，维护人员工作量大，不易实时掌握设备运行状态和关键数据，设备事故预防能力低。实施在线维护管理可避免传统方式的不足之处，获得良好效益。 UPS的中文意思为“不间断电源”，是英语“Uninterruptible Power System/Uninterruptible Power Supply”的缩写，它可以保障计算机系统在停电之后继续工作一段时间以使用户能够紧急存盘，使用户不致因停电而影响工作或丢失数据。 交换机百度百科 交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机。其他常见的还有电话语音交换机、光纤交换机等。 图片上是 Cisco Catalyst 4500-E Series ，Cisco Catalyst 4500-X 系列交换机 概念交换（switching）是按照通信两端传输信息的需要，用人工或设备自动完成的方法，把要传输的信息送到符合要求的相应路由上的技术的统称。根据工作位置的不同，可以分为广域网交换机和局域网交换机。广义的交换机（switch）就是一种在通信系统中完成信息交换功能的设备。 在计算机网络系统中，交换概念的提出改进了共享工作模式。我们以前介绍过的HUB集线器就是一种共享设备，HUB本身不能识别目的地址，当同一局域网内的A主机给B主机传输数据时，数据包在以HUB为架构的网络上是以广播方式传输的，由每一台终端通过验证数据包头的地址信息来确定是否接收。也就是说，在这种工作方式下，同一时刻网络上只能传输一组数据帧的通讯，如果发生碰撞还得重试。这种方式就是共享网络带宽。 hub百度百科 HUB是一个多端口的转发器，在以HUB为中心设备时，即使网络中某条线路产生了故障，并不影响其它线路的工作。所以HUB在局域网中得到了广泛的应用。大多数的时候它用在星型与树型网络拓扑结构中，以RJ45接口与各主机相连（也有BNC接口），HUB按照不同的说法有很多种类。 HUB按照对输入信号的处理方式上，可以分为无源HUB、有源HUB、智能HUB。 磁盘阵列百度百科 磁盘阵列（Redundant Arrays of Independent Disks，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。 磁盘阵列是由很多价格较便宜的磁盘，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。利用这项技术，将数据切割成许多区段，分别存放在各个硬盘上。 磁盘阵列还能利用同位检查（Parity Check）的观念，在数组中任意一个硬盘故障时，仍可读出数据，在数据重构时，将数据经计算后重新置入新硬盘中。 堡垒机百度百科 堡垒机，即在一个特定的网络环境下，为了保障网络和数据不受来自外部和内部用户的入侵和破坏，而运用各种技术手段实时收集和监控网络环境中每一个组成部分的系统状态、安全事件、网络活动，以便集中报警、及时处理及审计定责。 产生原因随着企事业单位IT系统的不断发展，网络规模和设备数量迅速扩大，日趋复杂的IT系统与不同背景的运维人员的行为给信息系统安全带来较大风险，主要表现在： 多个用户使用同一个账号。这种情况主要出现在同一工作组中，由于工作需要，同时系统管理账号唯一，因此只能多用户共享同一账号。如果发生安全事故，不仅难以定位账号的实际使用者和责任人，而且无法对账号的使用范围进行有效控制，存在较大安全风险和隐患。 一个用户使用多个账号。目前，一个维护人员使用多个账号是较为普遍的情况，用户需要记忆多套口令同时在多套主机系统、网络设备之间切换，降低工作效率，增加工作复杂度。如下图所示： 缺少统一的权限管理平台，权限管理日趋繁重和无序；而且维护人员的权限大多是粗放管理，无法基于最小权限分配原则的用户权限管理，难以实现更细粒度的命令级权限控制，系统安全性无法充分保证。 无法制定统一的访问审计策略，审计粒度粗。各网络设备、主机系统、数据库是分别单独审计记录访问行为，由于没有统一审计策略，并且各系统自身审计日志内容深浅不一，难以及时通过系统自身审计发现违规操作行为和追查取证。 传统的网络安全审计系统无法对维护人员经常使用的SSH、RDP等加密、图形操作协议进行内容审计。 核心功能单点登录功能支持对X11、linux、unix、数据库、网络设备、安全设备等一系列授权账号进行密码的自动化周期更改，简化密码管理，让使用者无需记忆众多系统密码，即可实现自动登录目标设备，便捷安全。[1] 账号管理设备支持统一账户管理策略，能够实现对所有服务器、网络设备、安全设备等账号进行集中管理，完成对账号整个生命周期的监控，并且可以对设备进行特殊角色设置如：审计巡检员、运维操作员、设备管理员等自定义设置，以满足审计需求 身份认证设备提供统一的认证接口，对用户进行认证，支持身份认证模式包括 动态口令、静态密码、硬件key 、生物特征等多种认证方式，设备具有灵活的定制接口，可以与其他第三方认证服务器之间结合；安全的认证模式，有效提高了认证的安全性和可靠性。 资源授权设备提供基于用户、目标设备、时间、协议类型IP、行为等要素实现细粒度的操作授权，最大限度保护用户资源的安全 访问控制设备支持对不同用户进行不同策略的制定，细粒度的访问控制能够最大限度的保护用户资源的安全，严防非法、越权访问事件的发生。 操作审计设备能够对字符串、图形、文件传输、数据库等全程操作行为审计；通过设备录像方式实时监控运维人员对操作系统、安全设备、网络设备、数据库等进行的各种操作，对违规行为进行事中控制。对终端指令信息能够进行精确搜索，进行录像精确定位。[2]","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"VMware","slug":"VMware","permalink":"http://zc95.github.io/tags/VMware/"},{"name":"服务器虚拟化","slug":"服务器虚拟化","permalink":"http://zc95.github.io/tags/服务器虚拟化/"},{"name":"堡垒机","slug":"堡垒机","permalink":"http://zc95.github.io/tags/堡垒机/"},{"name":"磁盘阵列","slug":"磁盘阵列","permalink":"http://zc95.github.io/tags/磁盘阵列/"},{"name":"交换机","slug":"交换机","permalink":"http://zc95.github.io/tags/交换机/"}]},{"title":"JavaScript闭包","slug":"javascriptClosure","date":"2017-12-21T12:48:17.000Z","updated":"2017-12-26T13:11:21.185Z","comments":true,"path":"2017/12/21/javascriptClosure/","link":"","permalink":"http://zc95.github.io/2017/12/21/javascriptClosure/","excerpt":"对于JavaScript的程序员来说，闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 MDN Closures 变量的作用域变量的作用域无非就是两种：全局变量和局部变量。当在函数中声明一个变量的时候，如果用关键字var来声明此变量，那么它就是局部变量，如果没有var那么就会成为全局变量。一般不建议用这种方式定义全局变量。而是用var将变量声明在函数的外面。 var name = &#39;小张&#39;; // 全局变量 function func() { var name = &#39;小明&#39;; // 局部变量 age = 12; // 全局变量，建议少用这种全局变量的定义方式 }","text":"对于JavaScript的程序员来说，闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 MDN Closures 变量的作用域变量的作用域无非就是两种：全局变量和局部变量。当在函数中声明一个变量的时候，如果用关键字var来声明此变量，那么它就是局部变量，如果没有var那么就会成为全局变量。一般不建议用这种方式定义全局变量。而是用var将变量声明在函数的外面。 var name = &#39;小张&#39;; // 全局变量 function func() { var name = &#39;小明&#39;; // 局部变量 age = 12; // 全局变量，建议少用这种全局变量的定义方式 } 在JavaScript中，函数可以用来创造函数作用域。函数内部可以看到外面的变量，而外面看不到函数里的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，直到搜索到全局变量为止。 var a = 1; var func1 = function(){ var b = 2; var func2 = function(){ var c = 3; console.log( b ); // 2 console.log( a ); // 1 } func2(); console.log( c ); // 报错：c is not defined }; func1(); 那么能不能从函数外部来访问局部变量呢？答案是可以。 var func = function() { var number = 6; return function() { return number; } }; console.log( func()() ); // 6 变量的生存周期全局变量的生存周期是永久的，除非我们主动的销毁这个全局变量。而对于局部变量来说，当退出函数时，这些局部变量就失去了生存的环境，所以会随着函数调用的结束而被销毁。那么是否可以让局部变量在函数调用结束的时候不被销毁呢？来看下面这个例子： var func = function() { var a = 1; return function() { a++; console.log( a ); } }; var f = func(); f(); // 2 f(); // 3 f(); // 4 从上面这个输出结果，我们可以看到局部变量a并没有随着f()的调用而被销毁。这是因为全局变量f保存着对func里面匿名函数的引用。而这个匿名函数是可以访问到局部变量a的，所以自然a也被保存下来了。所以这种情况下局部变量的生存周期就得以延续。上面这个匿名函数其实就是一个闭包。再来看一个闭包的经典应用。 // 假设有5个div var nodes = document.getElementsByTagName( &#39;div&#39; ); for ( var i = 0, l = nodes.length; i &lt; l; i++ ) { nodes[i].onclick = function() { console.log( i ); } } 当真正执行这段代码的时候，发现无论点击那个div，最后打印的结果都是4。这是因为onclick事件是异步触发的，当事件触发的时候，for循环早已经结束，此时变量i的值已经是4。解决方案可以是用闭包把每次的i都保存起来： for ( var i = 0, l = nodes.length; i &lt; l; i++ ) { (function( i ) { nodes[i].onclick = function() { console.log( i ); } })( i ); } 同理，我们编写一段代码用来判断对象类型： var Type = {}; for ( var i = 0, type; type = [ &#39;String&#39;, &#39;Array&#39;, &#39;Number&#39; ][ i++ ]; ) { (function( type ) { Type[ &#39;is&#39; + type ] = function( obj ) { return Object.prototype.toString.call( obj ) === &#39;[object &#39; + type + &#39;]&#39;; } })( type ); } Type.isArray( [] ); // true Type.isString( &#39;str&#39; ); // true 什么是闭包官方的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因为这些变量也是该表达式的一部分。这个概念不好理解，我们可以简单得理解成闭包就是能够访问函数内部变量的函数。 闭包的作用 可以在函数外部访问在函数内部定义的局部变量 延续局部变量的生存周期 封装变量闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。假设有一个计算乘积的函数： var mult = function() { var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) { a = a * arguments[i]; } return a; }; mult(2, 3, 4); // 24 mult函数接受一些Number类型的参数，并且返回他们的乘积。现再我们觉得对于那些相同参数来说，每次再进行计算是一种浪费，所以我们决定加入缓存机制来提高函数性能： var cache = {}; var mult = function() { var args = Array.prototype.join.call( arguments, &#39;&#39; ); if ( cache[ args ] ) { return cache[ args ]; } var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) { a = a * arguments[i]; } return cache[ args ] = a; }; 我们看到cache这个变量仅仅在mult函数中被使用，所以为了避免cache污染全局变量，我们将它放到mult函数里面 var mult = (function() { var cache = {}; return function() { var args = Array.prototype.join.call( arguments, &#39;&#39; ); if ( cache[ args ] ) { return cache[ args ]; } var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) { a = a * arguments[i]; } return cache[ args ] = a; } })(); 提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有利于代码的复用，如果这些小函数有一个良好的命名，那么它们本身就起到了一个很好的注释作用。 var mult = (function() { var cache = {}; var calculate = function() { var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) { a = a * arguments[i]; } return a; }; return function() { var args = Array.prototype.join.call( arguments, &#39;&#39; ); if ( cache[ args ] ) { return cache[ args ]; } return cache[ args ] = calculate.apply( null, arguments ); } })(); 闭包与内存管理局部变量本来应该在函数退出的时候就被结束引用，但如果局部变量被封装在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上来看，闭包确实会使一些数据无法被及时销毁。如果将来需要回收这些变量，我们可以手动把这些变量设为null。跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域中保存着一些DOM节点，这个时候就有可能造成内存泄露。在IE9之前的浏览器中，由于BOM和DOM中的对象是使用C++对象以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是引用计数策略。在基于引用计数的垃圾收集机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。但我们只要把循环引用中的对象设为null即可解决这个问题。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://zc95.github.io/tags/正则表达式/"}]},{"title":"正则表达式","slug":"RegularExpression","date":"2017-12-20T10:48:26.000Z","updated":"2017-12-21T12:41:12.999Z","comments":true,"path":"2017/12/20/RegularExpression/","link":"","permalink":"http://zc95.github.io/2017/12/20/RegularExpression/","excerpt":"PART 1-为什么使用正则表达式？ 测试字符串内的模式 例如，可以测试输入字符串，以查看字符串内是否出现电话号码或信用卡号码模式。这称为数据验证 替换文本 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它 基于模式匹配从字符串中提取子字符串 可以查找文档内或输入域内特定的文本","text":"PART 1-为什么使用正则表达式？ 测试字符串内的模式 例如，可以测试输入字符串，以查看字符串内是否出现电话号码或信用卡号码模式。这称为数据验证 替换文本 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它 基于模式匹配从字符串中提取子字符串 可以查找文档内或输入域内特定的文本 PART 2-练习正则表达式我们可以在console控制台，regexper 或者 IDE 去练习正则表达式 推荐一个JS正则可视化的在线工具，简单易懂：regexper.com 现在大部分IDE都会支持正则表达式匹配，如sublime： PART 3-举个🌰实例 ^[0-9]+abc$ ^ 为匹配输入字符串的开始位置 [0-9]+ 匹配单个数字，+ 匹配一个或者多个 abc$ 匹配字母 abc 结尾 $ 为匹配输入字符串的结束位置 匹配以数字开头，并以abc结尾的字符串： var str = &quot;123abc&quot;; var patt1 = /^[0-9]+abc$/; document.write(str.match(patt1)); ==&gt; 123ABC PART 4-基本正则字符基础字符含义MDN Regular Expressions 字符 描述 \\ 转意，即通常在”\\”后面的字符不按原来意义解释，如/b/匹配字符”b”，当b前面加了反斜杠后/\\b/，转意为匹配一个单词的边界。 ^ 匹配输入的开始 例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。 当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。补充字符集合一节有详细介绍和示例。 $ 匹配输入的结束。 例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。 * 匹配前面元字符0次或多次，/ba*/ 将匹配b,ba,baa,baaa ，相当于{0, } 例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西。 + 匹配前面元字符1次或多次，/ba+/将匹配ba,baa,baaa，相当于{1, } 例如，/a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。 ? 匹配前面元字符0次或1次，相当于 {0,1} 例如，/e?le?/ 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’ 如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。 例如，对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。 还可以运用于先行断言，如本表的 x(?=y) 和 x(?!y) 条目中所述。 . 匹配除换行符之外的任何单个字符 例如，/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。 x&#124;y 匹配x或y {n} 精确匹配n次 {n,} 匹配n次以上 {n,m} 匹配n-m次 [^xyz ] 字符集(character set)，匹配这个集合中的任一一个字符(或元字符) [\\b] 匹配一个退格符 \\b 匹配一个单词的边界 \\B 匹配一个非单词边界 \\cX 这儿，X是一个控制符，/\\cM/匹配Ctrl-M \\d 匹配一个数字，/\\d/ = /[0-9]/ \\D 匹配一个非字数字符，/\\D/ = /[ ^0-9]/ \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\s 匹配一个空白字符，包括\\n,\\r,\\f,\\t,\\v等 \\S 匹配一个非空白字符，等于 /[ ^\\n\\f\\r\\t\\v]/ \\t 匹配一个制表符 \\v 匹配一个重直制表符 \\w 匹配字母或数字或下划线，等于[a-zA-Z_0-9] ( 能不能匹配汉字要视你的操作系统和你的应用环境而定 \\W 匹配一个不可以组成单词的字符，如[\\W]匹配”5.98”中的，等于 [ ^a-zA-Z0-9] PART 5-使用正则表达式正则表达式可以被用于RegExp的exec和test方法以及 String的match、replace、search和split方法。这些方法在JavaScript 手册中有详细的解释。 方法 描述 exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。 test 一个在字符串中测试是否匹配的RegExp方法，它返回true或false。 match 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。 search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://zc95.github.io/tags/正则表达式/"}]},{"title":"用最简单的代码实现点击查看大图","slug":"enlargeImg","date":"2017-11-29T13:03:34.000Z","updated":"2017-12-21T12:42:50.170Z","comments":true,"path":"2017/11/29/enlargeImg/","link":"","permalink":"http://zc95.github.io/2017/11/29/enlargeImg/","excerpt":"今天做了个点击查看大图的功能，只需要给img加一个class，不用写额外的html代码 链接 demo地址 github地址","text":"今天做了个点击查看大图的功能，只需要给img加一个class，不用写额外的html代码 链接 demo地址 github地址 核心代码 html部分&lt;img class=&quot;enlargeImg&quot; width=&quot;80&quot; src=&quot;https://zc95.github.io/img/avatar.png&quot; title=&quot;点击查看大图&quot; /&gt; 重点： img标签 class=”enlargeImg” 限制图片宽度或高度为”小图片”，width=”80” src有值 title=”点击查看大图” css部分.enlargeImg_wrapper { display: none; position: fixed; z-index: 999; top: 0; right: 0; bottom: 0; left: 0; background-repeat: no-repeat; background-attachment: fixed; background-position: center; background-color: rgba(52, 52, 52, 0.8); background-size: 50%; } img:hover, .enlargeImg_wrapper:hover { cursor: pointer; } 重点： 半透明遮罩层 background-color: rgba(52, 52, 52, 0.8); 水平垂直居中 background-position: center; 放大后的图片大小 background-size: 50%; 如果受页面中别的定位元素的z-index影响，改z-index的值就行 js部分$(function() { enlargeImg(); }) //查看大图 function enlargeImg() { $(&quot;.enlargeImg&quot;).click(function() { $(this).after(&quot;&lt;div onclick=&#39;closeImg()&#39; class=&#39;enlargeImg_wrapper&#39;&gt;&lt;/div&gt;&quot;); var imgSrc = $(this).attr(&#39;src&#39;); $(&quot;.enlargeImg_wrapper&quot;).css(&quot;background-image&quot;, &quot;url(&quot; + imgSrc + &quot;)&quot;); $(&#39;.enlargeImg_wrapper&#39;).fadeIn(200); }) } //关闭并移除图层 function closeImg() { $(&#39;.enlargeImg_wrapper&#39;).fadeOut(200).remove(); } 重点： 点击class为 enlargeImg 的图片时获取它的路径，var imgSrc = $(this).attr(‘src’); 创建遮罩层，$(this).after(““); 赋值给 enlargeImg_wrapper ，$(“.enlargeImg_wrapper”).css(“background-image”, “url(“ + imgSrc + “)”); 关闭遮罩层时移除遮罩层，$(‘.enlargeImg_wrapper’).fadeOut(200).remove();","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"更改hosts文件来更好地使用github","slug":"hostsChange","date":"2017-11-28T15:49:00.000Z","updated":"2017-12-21T12:12:16.566Z","comments":true,"path":"2017/11/28/hostsChange/","link":"","permalink":"http://zc95.github.io/2017/11/28/hostsChange/","excerpt":"最近可能是网不太好，hexo d的时候总是提交不了，很苦恼，试了n多种方法。。。 hexo d时报错fatal: unable to access&#39;https://github.com/zc95/zc95.github.io.git/ &#39;: Could not resolve host: github.com FATAL Something&#39;s wrong.Maybe you can find the solution here:http:hexo.io/docs/troubleshooting.html ... 命令行终端 ping github.com打开命令行终端，输入 ping github.com 并回车 ping github.com","text":"最近可能是网不太好，hexo d的时候总是提交不了，很苦恼，试了n多种方法。。。 hexo d时报错fatal: unable to access&#39;https://github.com/zc95/zc95.github.io.git/ &#39;: Could not resolve host: github.com FATAL Something&#39;s wrong.Maybe you can find the solution here:http:hexo.io/docs/troubleshooting.html ... 命令行终端 ping github.com打开命令行终端，输入 ping github.com 并回车 ping github.com 如果像下面这样ping不出，就继续往下看吧 ping github.com PING github.com (192.30.255.113): 56 data bytes Request timeout Request timeout for icmp_seq 0 Request timeout for icmp_seq 1 Request timeout for icmp_seq 2 Request timeout for icmp_seq 3 Request timeout for icmp_seq 4 Request timeout for icmp_seq 5 ... Ping github.com 打开链接 http://ping.chinaz.com 输入 github.com ,点击Ping检测 选择一条TTL值最小的ip地址，例如：192.30.255.113 修改hosts 点击Finder - 前往 - 前往文件夹… - 输入 /etc/hosts 点击前往 找到hosts文件，修改hosts文件需要管理员权限，所以不能单纯修改，先按住hosts文件拖到桌面，双击打开桌面上的hosts文件 在 127.0.0.1 localhost 下面另起一行输入 192.30.255.113 github.com ，保存并退出 将桌面的hosts文件拖回直原来的位置，他会提示你 修改”etc”需要管理员密码 ，点击”鉴定”，会提示你是否覆盖原文件，点击”是”，输入密码或指纹，ok了 再次在命令行终端 ping github.com 就能看到ping成功了 可以愉快的deploy了 FAQ什么是hosts？ Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 每次改完配置需要重启机器吗？ 不需要，它实质上是个文本文件，当计算机需要解析地址时，会首先检查此文件，读取后再确定是本地解析还是要发送到DNS服务器来解析。改后，只要再上网，就会生效。 hosts文件在哪里?Linux:/etc/hosts Mac OS X:/etc/hosts Android:/etc/hosts Windows:C:/windows/System32/drivers/etc/hosts hosts文件规则?#ip地址 域名 127.0.0.1 localhost 192.30.255.113 github.com 255.255.255.255 broadcasthost ::1 localhost","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"github","slug":"github","permalink":"http://zc95.github.io/tags/github/"},{"name":"hosts","slug":"hosts","permalink":"http://zc95.github.io/tags/hosts/"}]},{"title":"关于float清除浮动和inline-block出现空隙的问题","slug":"floatAndInlineBlock","date":"2017-11-26T15:21:45.000Z","updated":"2018-01-10T13:27:57.924Z","comments":true,"path":"2017/11/26/floatAndInlineBlock/","link":"","permalink":"http://zc95.github.io/2017/11/26/floatAndInlineBlock/","excerpt":"最近在写项目的时候手写了一个简单选项卡，遇到这类布局，最常见、最快速的布局方式就是display:inline-block;和float:left; 但我们都知道 display:inline-block 布局会出现空隙的问题，float:left 又要清除浮动，本文就这两个问题整理出解决方案。","text":"最近在写项目的时候手写了一个简单选项卡，遇到这类布局，最常见、最快速的布局方式就是display:inline-block;和float:left; 但我们都知道 display:inline-block 布局会出现空隙的问题，float:left 又要清除浮动，本文就这两个问题整理出解决方案。 display:inline-block去掉空隙移除标签间的空格&lt;ul class=&quot;tab-wrapper&quot;&gt; &lt;li class=&quot;tab-item active&quot;&gt;项目一&lt;/li&gt;&lt;li class=&quot;tab-item&quot;&gt;项目二&lt;/li&gt;&lt;li class=&quot;tab-item&quot;&gt;项目三&lt;/li&gt;&lt;li class=&quot;tab-item&quot;&gt;项目四&lt;/li&gt; &lt;/ul&gt; 这个方法是我最初学html时知道的方法，当时觉得挺方便的，现在工作了觉得这个方法好蠢😂，一个代码格式化就能毁了它，这样不易维护的代码太脆弱了； 去掉闭合标签&lt;ul class=&quot;tab-wrapper&quot;&gt; &lt;li class=&quot;tab-item active&quot;&gt;项目一 &lt;li class=&quot;tab-item&quot;&gt;项目二 &lt;li class=&quot;tab-item&quot;&gt;项目三 &lt;li class=&quot;tab-item&quot;&gt;项目四 &lt;/ul&gt; 这个方法算是种好方法，最后一个li的闭合标签可有可无，也能很好的解决空隙问题，但依然还是代码不易维护的问题。 font-size:0;&lt;ul class=&quot;tab-wrapper&quot;&gt; &lt;li class=&quot;tab-item active&quot;&gt;项目一&lt;/li&gt; &lt;li class=&quot;tab-item&quot;&gt;项目二&lt;/li&gt; &lt;li class=&quot;tab-item&quot;&gt;项目三&lt;/li&gt; &lt;li class=&quot;tab-item&quot;&gt;项目四&lt;/li&gt; &lt;/ul&gt; .tab-wrapper{ font-size:0; /*父容器font-size为0*/ -webkit-text-size-adjust:none; /*Chrome有最小字体大小限制，考虑到兼容性需要取消字体大小限制*/ } .tab-wrapper .tab-item{ display:inline-block; font-size:13px; /*这里比较重要，因为子元素会继承父元素的字体大小，这里要恢复正常font-size*/ padding:5px 12px; } 这个方法方法好理解，比较主流的解决方案； float 清除浮动空标签 &lt;div class=&quot;box-wrapper&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt; &lt;/div&gt; 最佳方法/* 全浏览器通用的clearfix方案【推荐 */ /* 引入了zoom以支持IE6/7 */ /* 同时加入:before以解决现代浏览器上边距折叠的问题 */ .clearfix:before, .clearfix:after { display: table; content: &quot; &quot;; } .clearfix:after { clear: both; } .clearfix{ *zoom: 1; }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"基于 GitHub Issues 的评论系统：gitment","slug":"gitment","date":"2017-11-23T15:47:12.000Z","updated":"2017-12-21T12:43:24.822Z","comments":true,"path":"2017/11/23/gitment/","link":"","permalink":"http://zc95.github.io/2017/11/23/gitment/","excerpt":"如何为hexo博客添加评论功能多说、友言、Disqus、livere(来比力)、gitment、畅言、valine基本都可以实现，但有些已经关闭，有些需要翻墙 本文讲的是一款基于 GitHub Issues 的评论系统：gitment 。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown语法 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。","text":"如何为hexo博客添加评论功能多说、友言、Disqus、livere(来比力)、gitment、畅言、valine基本都可以实现，但有些已经关闭，有些需要翻墙 本文讲的是一款基于 GitHub Issues 的评论系统：gitment 。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown语法 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 gitmentPC端 移动端 基础配置打开博客主题文件夹下的 _config.yml 文件，以我的为例： comment: type: gitment # 启用哪种评论系统 gitment: githubID: zc95 # 你的GitHub名称 repo: zc95.github.io # 你的GitHub名称.github.io ClientID: ********* ClientSecret: ********* lazy: false # 这个我也不清楚 大概是懒加载的意思吧 githubID 和 repo 都有了，就剩 ClientID 和 ClientSecret 了 注册OAuth Application通过地址OAuth Application注册传送门申请配置，注册一个新的 OAuth Application，其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://zc95.github.io） 获取ClientID与ClientSecret 总结 优点 界面​简洁 与github绑定，方便注册，不用依赖脚本或插件 评论会出现在github项目中的Issues里，方便管理 支持Markdown全部语法和html标签（这个很厉害） 缺点 ​每篇文章都需要手动点击initialize comments按钮来初始化评论，否则不能评论； 不支持图片（可以尝试用markdown或者img标签来实现）和表情（emoji可以用） 只能支持github登陆 最后更新最后还是选择了livere 来必力，注册登陆需要翻墙（或许因为我网不好。。），一旦注册之后评论之类的就不需翻墙了，支持QQ、微信、微博、百度等登陆方式，本页拉到最底下就是来必力了，体验还是可以的。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://zc95.github.io/tags/Hexo/"},{"name":"gitment","slug":"gitment","permalink":"http://zc95.github.io/tags/gitment/"},{"name":"Issues","slug":"Issues","permalink":"http://zc95.github.io/tags/Issues/"}]},{"title":"我的收藏","slug":"Collection","date":"2017-11-21T11:30:45.000Z","updated":"2017-12-21T12:13:56.049Z","comments":true,"path":"2017/11/21/Collection/","link":"","permalink":"http://zc95.github.io/2017/11/21/Collection/","excerpt":"我的博客https://zc95.github.io工具jsrun在线代码编辑tinypng压缩图片Google翻译msdn.itellyouMDN文档","text":"我的博客https://zc95.github.io工具jsrun在线代码编辑tinypng压缩图片Google翻译msdn.itellyouMDN文档 前端插件&amp;框架echartslayui阿里巴巴矢量图标图学习网站freecodecamp慕课网前端菜鸟教程","categories":[{"name":"汇总篇","slug":"汇总篇","permalink":"http://zc95.github.io/categories/汇总篇/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"http://zc95.github.io/tags/收藏/"},{"name":"前端必备","slug":"前端必备","permalink":"http://zc95.github.io/tags/前端必备/"}]},{"title":"数组复习","slug":"arrayReview","date":"2017-11-21T10:44:45.000Z","updated":"2017-12-21T12:14:17.731Z","comments":true,"path":"2017/11/21/arrayReview/","link":"","permalink":"http://zc95.github.io/2017/11/21/arrayReview/","excerpt":"检测数组typeofvar ary = [1,23,4]; console.log(typeof ary); //输出结果是Object instanceofvar ary = [1,23,4]; console.log(ary instanceof Array)//true;","text":"检测数组typeofvar ary = [1,23,4]; console.log(typeof ary); //输出结果是Object instanceofvar ary = [1,23,4]; console.log(ary instanceof Array)//true; 原型链方法var ary = [1,23,4]; console.log(ary.__proto__.constructor==Array);//true console.log(ary.constructor==Array)//true 这两段代码是一样的 以上三种方法都不太好，instanceof 和 constructor 判断的变量，必须在当前页面声明的，比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个arr，并将其赋值给父页面的一个变量，这时判断该变量，Array == object.constructor;会返回false； 正确方法var ary = [1,2,3,4]; function isArray(e){ return Object.prototype.toString.call(e)==&#39;[object Array]&#39;; } console.log(isArray(ary)); 自己封装的基本数据类型验证var type = { isObj: function(o) { return Object.prototype.toString.call(o) == &quot;[object Object]&quot;; }, isArray: function(o) { return Object.prototype.toString.call(o) == &quot;[object Array]&quot;; }, isNull: function(o) { return Object.prototype.toString.call(o) == &quot;[object Null]&quot;; }, isUndefined: function(o) { return Object.prototype.toString.call(o) == &quot;[object Undefined]&quot;; }, isBoolean: function(o) { return Object.prototype.toString.call(o) == &quot;[object Boolean]&quot;; }, isString: function(o) { return Object.prototype.toString.call(o) == &quot;[object String]&quot;; }, isNumber: function(o) { return Object.prototype.toString.call(o) == &quot;[object Number]&quot;; }, isDocument: function() { return Object.prototype.toString.call(o) == &quot;[object Document]&quot; || &quot;[object HTMLDocument]&quot;; } } ------------------------------ &gt;console.log(type.isArray([1,2,3])); &gt;true push()和pop() push() 向数组末尾添加任意个项并返回新数组的长度 pop() 从数组末尾移除最后一项，减少数组的length值 （返回的是移除的项） shift()和unshift() unshift() 向数组前端添加任意个项并返回新数组的长度 shift() 从数组前端移除第一项，减少数组的length值 （返回的是移除的项） 重排序 sort() reverse()function compare(a,b){ return a-b;//升序 //return b-a; 或者在升序方法之后使用reverse()反转数组 } arr.sort(compare); 操作方法 concat() slice() splice()concat()concat() 方法用于连接两个或多个数组，不会改变原始数组。 slice()slice() 方法可从已有的数组中返回选定的元素，不会改变原始数组。 arrayObject.slice(start,end) 参数 描述 start 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 splice()splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目，会改变原始数组。 arrayObject.splice(index,howmany,item1,…..,itemX) 参数 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX 可选。向数组添加的新项目。 位置方法indexOf() indexOF() 从前往后查找，返回首次出现的位置（没有返回-1） lastindexOf() lastindexOf() 从后往前查找，返回首次出现的位置（没有返回-1） 迭代方法 迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。 every(): 对数组中的每一项运行给定的函数，如果该函数对每一项都返回true，则结果返回true。 filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 forEach(): 对数组中的每一项运行给定函数，这个方法没有返回值。 map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some(): 对数组中的每一项运行给定函数，如果该函数任意一项返回true，则返回true。 every()和some()var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; var everyResult = numbers.every(function(item, index, array) { return (item &gt; 2); }); var someResult = numbers.some(function(item) { return (item &gt; 2); }); console.log(everyResult); //false console.log(someResult); //true filter()var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; var filterResult = numbers.filter(function(item) { return (item &gt; 2); }); console.log(filterResult); \\\\[3, 4, 5, 4, 3] map()var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; var mapResult = numbers.map(function(item) { return (item * 2); }); console.log(mapResult); //[2, 4, 6, 8, 10, 8, 6, 4, 2] forEach()var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; numbers.forEach(function(item, index, arr) { //这里执行一些操作 });","categories":[{"name":"汇总篇","slug":"汇总篇","permalink":"http://zc95.github.io/categories/汇总篇/"}],"tags":[{"name":"array","slug":"array","permalink":"http://zc95.github.io/tags/array/"}]},{"title":"column","slug":"column","date":"2017-11-10T16:30:14.000Z","updated":"2017-12-21T12:15:00.202Z","comments":true,"path":"2017/11/11/column/","link":"","permalink":"http://zc95.github.io/2017/11/11/column/","excerpt":"CSS3多列CSS3 可以将文本内容设计成像报纸一样的多列布局，如下实例： CSS3 多列属性 column-count column-gap column-rule-style column-rule-width column-rule-color column-rule column-span column-width","text":"CSS3多列CSS3 可以将文本内容设计成像报纸一样的多列布局，如下实例： CSS3 多列属性 column-count column-gap column-rule-style column-rule-width column-rule-color column-rule column-span column-width CSS3 创建多列column-count 属性指定了需要分割的列数 以下实例将 &lt;div&gt; 元素中的文本分为 3 列： .newspaper { -moz-column-count:3; /* Firefox */ -webkit-column-count:3; /* Safari and Chrome */ column-count:3; } &lt;div class=&quot;newspaper&quot;&gt;....................&lt;/div&gt; 尝试一下 » CSS3 多列中列与列间的间隙column-gap 属性指定了列与列间的间隙 以下实例指定了列与列间的间隙为 40 像素： .newspaper { -moz-column-count:3; /* Firefox */ -webkit-column-count:3; /* Safari and Chrome */ column-count:3; -moz-column-gap:40px; /* Firefox */ -webkit-column-gap:40px; /* Safari and Chrome */ column-gap:40px; } &lt;div class=&quot;newspaper&quot;&gt;....................&lt;/div&gt; 尝试一下 » CSS3 列边框column-rule-style 属性指定了列与列间的边框样式： .newspaper { -webkit-column-rule-style: solid; /* Chrome, Safari, Opera */ -moz-column-rule-style: solid; /* Firefox */ column-rule-style: solid; } 尝试一下 » column-rule-width 属性指定了两列的边框厚度： div { -webkit-column-rule-width: 1px; /* Chrome, Safari, Opera */ -moz-column-rule-width: 1px; /* Firefox */ column-rule-width: 1px; } 尝试一下 » column-rule-color 属性指定了两列的边框颜色： div { -webkit-column-rule-color: lightblue; /* Chrome, Safari, Opera */ -moz-column-rule-color: lightblue; /* Firefox */ column-rule-color: lightblue; } 尝试一下 » column-rule 属性是 column-rule-* 所有属性的简写。 以下实例设置了列直接的边框的厚度，样式及颜色： div { -webkit-column-rule: 1px solid lightblue; /* Chrome, Safari, Opera */ -moz-column-rule: 1px solid lightblue; /* Firefox */ column-rule: 1px solid lightblue; } 尝试一下 » 指定元素跨越多少列以下实例指定 &lt;h2&gt; 元素跨越所有列： h2 { -webkit-column-span: all; /* Chrome, Safari, Opera */ column-span: all; } 尝试一下 » 指定列的宽度column-width 属性指定了列的宽度。 div { -webkit-column-width: 100px; /* Chrome, Safari, Opera */ column-width: 100px; } 尝试一下 » CSS3 多列属性下表列出了所有 CSS3 的多列属性： 属性 描述 column-count 指定元素应该被分割的列数。 column-fill 指定如何填充列 column-gap 指定列与列之间的间隙 column-rule 所有 column-rule-* 属性的简写 column-rule-color 指定两列间边框的颜色 column-rule-style 指定两列间边框的样式 column-rule-width 指定两列间边框的厚度 column-span 指定元素要跨越多少列 column-width 指定列的宽度 columns 设置 column-width 和 column-count 的简写","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"css3","slug":"css3","permalink":"http://zc95.github.io/tags/css3/"},{"name":"布局","slug":"布局","permalink":"http://zc95.github.io/tags/布局/"}]},{"title":"css换行问题","slug":"wordBreak","date":"2017-10-25T04:27:15.000Z","updated":"2017-12-21T12:15:55.327Z","comments":true,"path":"2017/10/25/wordBreak/","link":"","permalink":"http://zc95.github.io/2017/10/25/wordBreak/","excerpt":"css实现强制不换行/自动换行/强制换行 强制换行按单词自动换行 p { word-wrap:break-word; } 强制按英文字母断行 需要将行内元素设置为块级元素 p { word-break:break-all; }","text":"css实现强制不换行/自动换行/强制换行 强制换行按单词自动换行 p { word-wrap:break-word; } 强制按英文字母断行 需要将行内元素设置为块级元素 p { word-break:break-all; } 强制不换行强制不换行 p { white-space:nowrap; } 超出显示省略号 p { white-space:nowrap; text-overflow:ellipsis; overflow:hidden; } 一定要给文字的父容器 如果父容器是行级，一定要转成块级（一定要是 block，设置为 inline-block 无效） white-space: normal pre nowrap pre-wrap pre-line inherit ; white-space 属性设置如何处理元素内的空白 normal 默认。多个空白或者多个换行将被当一个空白或一个换行处理- pre 空白和换行会被浏览器保留。其行为方式类似 HTML 中的 pre 标签- nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止- pre-wrap 保留空白符序列，但是正常地进行换行 - pre-line 合并空白符序列，但是保留换行符- inherit 规定应该从父元素继承 white-space 属性的值word-break: normal break-all keep-all ; word-break 属性用来标明怎么样进行单词内的断句 normal：使用浏览器默认的换行规则- break-all:允许再单词内换行 - keep-all:只能在半角空格或连字符处换行","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"表头固定","slug":"amazingTable","date":"2017-10-23T16:15:16.000Z","updated":"2017-12-21T12:16:19.880Z","comments":true,"path":"2017/10/24/amazingTable/","link":"","permalink":"http://zc95.github.io/2017/10/24/amazingTable/","excerpt":"table的表头固定 ——— 上下滚动表头固定，左右滚动表头跟随滚动 关于表格固定如果数据不是很多，一般都是用两个表格，一个放thead，另一个放tbody，这个没难度就不再赘述了 如果数据很多就要考虑左右滚动的情况了","text":"table的表头固定 ——— 上下滚动表头固定，左右滚动表头跟随滚动 关于表格固定如果数据不是很多，一般都是用两个表格，一个放thead，另一个放tbody，这个没难度就不再赘述了 如果数据很多就要考虑左右滚动的情况了 方法一demo: http://jsrun.net/biiKp/show 同样是两个table，一个放thead，另一个放tbody，用两个div分别包裹起来 这两个div依赖于他们的的父容器进行absolute定位 theadDiv { position: absolute; left: 0; right: 0; overflow: hidden; //这里hidden是用于隐藏滚动条} tbodyDiv { position: absolute; top: 35px; left: 0; right: 0; bottom: 0; overflow: auto;} 给放置thead的div添加样式 overflow: hidden; ，表头不需要看到滚动条 给放置tbody的div添加样式 overflow: auto; ，表的主体需要滚动条 这时只需要在滚动下面的tbody时，同样滚动上面的thead就行 $(‘#tbodyDiv’).on(‘scroll’, function () { $(“#theadDiv”).scrollLeft($(‘#tbodyDiv’).scrollLeft()); }); }) 方法二demo: http://jsrun.net/2iiKp/show 大概思路就是 容器A 下面有 容器1（放置thead） 和 容器2（放置tbody） x轴滚动条属于 容器A ，滚动 容器1（放置thead） 和 容器2（放置tbody） y轴属于 容器2 ，滚动 tbody 这个方法有缺陷，就是y轴的滚动条必须要当x轴滚到最右边才看得到，当然Mac下无差（Mac下的滚动条不滚动的时候是隐藏的，而win系统下就会影响美观，但都不影响操作，毕竟我们有鼠标滚轮）","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"DOM","slug":"DOM","date":"2017-10-21T06:37:42.000Z","updated":"2017-12-21T12:16:39.916Z","comments":true,"path":"2017/10/21/DOM/","link":"","permalink":"http://zc95.github.io/2017/10/21/DOM/","excerpt":"为什么我们要尽量少的去操作DOM结构？ 前言在前端开发的过程中，javascript极为重要的一个功能就是对DOM对象的操作，无论增删改查在前端页面操作这一范围内都是比较消耗性能的。如何高效率的，便捷的操作DOM，这就是本文要讲述的，希望看完全文，你能知道如何更高效的通过原生js以及jQuery操作DOM元素。 性能影响 DOM修改导致的页面重绘repaint、重构reflow，重新排版是用户阻塞的操作，同时，如果频繁重排，CPU使用率也会猛涨 repaint意味着样式的改变比如div调整了背景色等，但是位置不变，只改变我们操作的元素 reflow意味着结构的改变，比如一堆元素堆叠，改变其中一个的宽高，那么相应的所有元素的位置都要改变 所以通常来看repaint的代价要远小于reflow，速度也更快","text":"为什么我们要尽量少的去操作DOM结构？ 前言在前端开发的过程中，javascript极为重要的一个功能就是对DOM对象的操作，无论增删改查在前端页面操作这一范围内都是比较消耗性能的。如何高效率的，便捷的操作DOM，这就是本文要讲述的，希望看完全文，你能知道如何更高效的通过原生js以及jQuery操作DOM元素。 性能影响 DOM修改导致的页面重绘repaint、重构reflow，重新排版是用户阻塞的操作，同时，如果频繁重排，CPU使用率也会猛涨 repaint意味着样式的改变比如div调整了背景色等，但是位置不变，只改变我们操作的元素 reflow意味着结构的改变，比如一堆元素堆叠，改变其中一个的宽高，那么相应的所有元素的位置都要改变 所以通常来看repaint的代价要远小于reflow，速度也更快 如何避免 能放到DOM操作之外的操作就放到外面，DOM操作要尽量少这是一个不好的事例： var $obj = $(&quot;#obj&quot;); var data = [{&quot;id&quot;:0,&quot;name&quot;:&quot;a&quot;},{&quot;id&quot;:1,&quot;name&quot;:&quot;b&quot;}]; for (var i = 0; i &lt; data.length; i++) { $obj.append(&#39;&lt;option value=&quot;&#39;+data[i].id+&#39;&quot;&gt;&#39;+data[i].name+&#39;&lt;/option&gt;&#39;); }; 更好的做法，使用容器存放临时变更，最后再一次性更新DOM： var $obj = $(&quot;#obj&quot;); var data = [{&quot;id&quot;:0,&quot;name&quot;:&quot;a&quot;},{&quot;id&quot;:1,&quot;name&quot;:&quot;b&quot;}]; var tempStr = &quot;&quot;; for (var i = 0; i &lt; data.length; i++) { tempStr +=(&#39;&lt;option value=&quot;&#39;+data[i].id+&#39;&quot;&gt;&#39;+data[i].name+&#39;&lt;/option&gt;&#39;); }; $obj.html(tempStr); 大范围操作先把容器隐藏，在其中操作完成后再显示这个也算是优化的一种，这原理涉及到浏览器加载和渲染的原理,简单说就是隐藏的元素其中不会产生reflow 样式操作不要注意修改属性，直接替换class这个还是比较容易理解的，你逐一修改要访问很多次，而替换class就相当于批量操作了，访问一次DOM就可以了,当然性能提高了 总结对于性能方面，平时应注意积累。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"},{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://zc95.github.io/tags/jquery/"},{"name":"DOM操作","slug":"DOM操作","permalink":"http://zc95.github.io/tags/DOM操作/"},{"name":"循环","slug":"循环","permalink":"http://zc95.github.io/tags/循环/"},{"name":"渲染","slug":"渲染","permalink":"http://zc95.github.io/tags/渲染/"},{"name":"性能","slug":"性能","permalink":"http://zc95.github.io/tags/性能/"}]},{"title":"文本框模糊查询","slug":"input","date":"2017-10-21T05:14:08.000Z","updated":"2018-02-12T13:52:49.367Z","comments":true,"path":"2017/10/21/input/","link":"","permalink":"http://zc95.github.io/2017/10/21/input/","excerpt":"文本框模糊匹配(纯html+css+jquery简单实现) ，自己写的一个小组件。 链接 demo地址 github地址 开始使用 引入css、jQuery 和 js（github里面有） $(&#39;#id&#39;).FuzzyQuery({ &#39;msg&#39;: msg });","text":"文本框模糊匹配(纯html+css+jquery简单实现) ，自己写的一个小组件。 链接 demo地址 github地址 开始使用 引入css、jQuery 和 js（github里面有） $(&#39;#id&#39;).FuzzyQuery({ &#39;msg&#39;: msg }); 参数配置msg 是json数据（必须），fontSize 是模糊查询项的字体大小，height 是模糊查询项的高度 $(&#39;#Name&#39;).FuzzyQuery({ &#39;msg&#39;: msg, &#39;fontSize&#39;: &#39;13px&#39;, &#39;height&#39;: &#39;30px&#39; }); msg格式示例name 是文本，id 是标识 msg = [{ &quot;name&quot;: &quot;苏州大学&quot;, &quot;id&quot;: &quot;szdx&quot; }, { &quot;name&quot;: &quot;北京大学&quot;, &quot;id&quot;: &quot;bjdx&quot; }, { &quot;name&quot;: &quot;南京大学&quot;, &quot;id&quot;: &quot;njdx&quot; }, { &quot;name&quot;: &quot;清华大学&quot;, &quot;id&quot;: &quot;qhdx&quot; }, { &quot;name&quot;: &quot;复旦大学&quot;, &quot;id&quot;: &quot;fddx&quot; }, { &quot;name&quot;: &quot;浙江大学&quot;, &quot;id&quot;: &quot;zjdx&quot; }, { &quot;name&quot;: &quot;上海交通大学&quot;, &quot;id&quot;: &quot;shjtdx&quot; }, { &quot;name&quot;: &quot;武汉大学&quot;, &quot;id&quot;: &quot;whdx&quot; }, { &quot;name&quot;: &quot;中国人民大学&quot;, &quot;id&quot;: &quot;zgrmdx&quot; }, { &quot;name&quot;: &quot;中国科学技术大学&quot;, &quot;id&quot;: &quot;zgkxjsdx&quot; }, { &quot;name&quot;: &quot;北京师范大学&quot;, &quot;id&quot;: &quot;bjsfdx&quot; }]; html和CSS部分的一些细节 outline: none; outline （轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，为了美观应该去掉 box-sizing:border-box; 这可令浏览器呈现出带有指定宽度和高度的框，并把边框和内边距放入框中。 autocomplete=”off” autocomplete是form表单的属性，默认为on，其含义代表是否让浏览器自动记录之前输入的值，应该关闭记录","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"},{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://zc95.github.io/tags/jquery/"},{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"在Mac下通过Hexo在Github上搭建博客（入门篇）","slug":"hexoBlog","date":"2017-10-20T13:48:28.000Z","updated":"2017-12-21T12:17:50.596Z","comments":true,"path":"2017/10/20/hexoBlog/","link":"","permalink":"http://zc95.github.io/2017/10/20/hexoBlog/","excerpt":"Hexo 快速，简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。Hexo支持Github Flavored Markdown的所有功能，甚至可以整合Octopress的大多数插件，并自己也拥有强大的插件系统。 Hexo github Node.js Git markdown themes bash命令 npm SSH 什么是Hexo？ Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 Markdown（或其他渲染引擎，之后会解释什么是Markdown）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 前期准备安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js （安装Recommended For Most Users那个版本） Git","text":"Hexo 快速，简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。Hexo支持Github Flavored Markdown的所有功能，甚至可以整合Octopress的大多数插件，并自己也拥有强大的插件系统。 Hexo github Node.js Git markdown themes bash命令 npm SSH 什么是Hexo？ Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 Markdown（或其他渲染引擎，之后会解释什么是Markdown）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 前期准备安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js （安装Recommended For Most Users那个版本） Git 安装Hexo 当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：命令就是你的Launchpad里叫 终端 的app，相当于win的cmd以下出现的$都不是命令的一部分 $ npm install -g hexo-cli全局安装 hexo 模块， 如果下面的操作报错则需要卸载 hexo：$ npm uninstall hexo 再重新安装 hexo：$ sudo npm install -g hexo输入管理员密码（Mac登录密码）即开始安装 创建博客目录初始化, 在指定目录中创建文件目录，以 blog 为例： $ hexo init blog blog是你建立的文件夹名称，cd到blog文件夹下，安装npm： $ cd blog $ npm install 创建一篇新文章以创建博客 firstBlog为例，标题中包含空格需要用引号将标题引起来 $ hexo new firstBlog执行该命令后在source/_posts目录下生成文件 生成博客页面 $ hexo generate执行该命令后会生成public目录 $ hexo sever执行命令后启动服务，访问http://localhost:4000/可查看博客 注意： 之后每次修改完你的博客或者配置内容，都需要用$ hexo sever来开启hexo服务器预览 按 Ctrl+C 停止服务器，以便于进行其他操作 关联Github在进行这一步时你需要一个github账号，到 github官网 用邮箱注册就行，名字尽量简短有意义，我的github地址：https://github.com/zc95 创建仓库登录你的Github帐号，新建仓库，一定要是名为 用户名.github.io 的固定写法（如 zc95.github.io ），我的仓库地址：https://github.com/zc95/zc95.github.io 上传到 github首次使用配置： $ npm install hexo-deplorer-git –save安装 hexo-deplorer-git 打开新建的blog文件夹，找到 _config.yml 配置文件，用记事本打开，Ctrl+F来搜索deploy，type改为git，repository改为你自己的仓库地址，在配置博客站点的_config.yml文件时（包括theme主题站点中的_config.yml），在所有的冒号: 后边都要加一个空格，否则执行hexo命令会报错，切记 切记 deploy:type: gitrepository: 你的仓库地址branch: master ok，可以尽情装逼了。。。 hexo g == hexo generate #生成页面文件 hexo s == hexo server #启动服务预览 hexo d == hexo deploy # 部署到GitHub 常用命令 git clone #克隆主题时用到 cd blog #进入blog文件夹 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g == hexo generate #生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy # 部署 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d #你应该看得懂… 关于作者var author = { Name : &quot;张成&quot;, Blog : &quot;http://zc95.github.io&quot; }","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://zc95.github.io/tags/Hexo/"},{"name":"github","slug":"github","permalink":"http://zc95.github.io/tags/github/"},{"name":"Node.js","slug":"Node-js","permalink":"http://zc95.github.io/tags/Node-js/"},{"name":"markdown","slug":"markdown","permalink":"http://zc95.github.io/tags/markdown/"},{"name":"npm","slug":"npm","permalink":"http://zc95.github.io/tags/npm/"},{"name":"博客","slug":"博客","permalink":"http://zc95.github.io/tags/博客/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-18T16:10:04.000Z","updated":"2017-12-21T12:18:09.638Z","comments":true,"path":"2017/10/19/hello-world/","link":"","permalink":"http://zc95.github.io/2017/10/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}