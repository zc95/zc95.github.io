{"meta":{"title":"张成的博客","subtitle":null,"description":null,"author":"张成","url":"http://zc95.github.io"},"pages":[{"title":"关于我","date":"2018-03-15T12:00:45.692Z","updated":"2018-03-15T12:00:45.666Z","comments":true,"path":"about/index.html","permalink":"http://zc95.github.io/about/index.html","excerpt":"","text":"您的浏览器不支持 audio 标签。 姓名：张成 生日：1995/07 坐标：苏州 大学：南京大学 GitHub地址：https://github.com/zc95 邮件：571346800@qq.com QQ: 571346800 var zhangcheng = { \"Name\": \"zhangcheng\", \"Birth\": \"1995/7/3\", \"University\": \"Nanjin university\", \"Location\": \"SIP\", \"Blog\": \"https://zc95.github.io\", \"Github\": \"https://github.com/zc95\", \"QQ\": \"571346800\", \"Mail\": \"571346800@qq.com\", \"Tel\": \"17751435450\" }; console.table(zhangcheng); 关于博客 Hexo官网 博客地址： https://zc95.github.io 我搭建Hexo的过程： https://zc95.github.io/2017/10/20/hexoBlog/ theme： hexo-theme-melody 评论： 用过 gitment 和 livere ，现在关闭评论了 统计数据：不蒜子 内置搜索：hexo-generator-json-content"},{"title":"categories","date":"2018-02-10T13:16:30.404Z","updated":"2018-02-10T13:16:30.398Z","comments":true,"path":"categories/index.html","permalink":"http://zc95.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2017-11-30T11:37:25.996Z","updated":"2017-11-30T11:37:25.982Z","comments":true,"path":"links/index.html","permalink":"http://zc95.github.io/links/index.html","excerpt":"","text":""},{"title":"timeline","date":"2018-01-24T14:38:23.427Z","updated":"2017-10-20T16:03:38.000Z","comments":true,"path":"timeline/index.html","permalink":"http://zc95.github.io/timeline/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-24T14:36:58.716Z","updated":"2018-01-24T14:36:58.704Z","comments":true,"path":"tags/index.html","permalink":"http://zc95.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Node.js构建TCP服务器和TCP客户端","slug":"nodejs-TCP","date":"2018-03-20T13:56:12.000Z","updated":"2018-03-21T14:28:37.019Z","comments":true,"path":"2018/03/20/nodejs-TCP/","link":"","permalink":"http://zc95.github.io/2018/03/20/nodejs-TCP/","excerpt":"网络是通信互联网的基础，Node.js提供了net、http、dgram模块、分别用来实现TCP、HTTP、UDP的通信。上次的文章《Node.js构建HTTP服务器》实现了HTTP的通信，这篇文章说一说TCP服务器和TCP客户端的构建。 用Node.js创建TCP服务器构建TCP服务器为了使用Node.js创建TCP服务器，首先要使用require(“net”)来加载net模块，然后使用net模块的createServer方法就可以轻松地创建一个TCP服务器。","text":"网络是通信互联网的基础，Node.js提供了net、http、dgram模块、分别用来实现TCP、HTTP、UDP的通信。上次的文章《Node.js构建HTTP服务器》实现了HTTP的通信，这篇文章说一说TCP服务器和TCP客户端的构建。 用Node.js创建TCP服务器构建TCP服务器为了使用Node.js创建TCP服务器，首先要使用require(“net”)来加载net模块，然后使用net模块的createServer方法就可以轻松地创建一个TCP服务器。 12345678910111213141516/** * 构建TCP客户端 *//* 引入net模块 */var net = require(\"net\");/* 创建TCP服务器 */var server = net.createServer(function(socket)&#123; console.log('someone connects');&#125;)/* 设置连接的服务器 */server.listen(8000, function()&#123; console.log(\"Creat server on http://127.0.0.1:8000/\");&#125;) 运行这段代码并访问了http://127.0.0.1:8000/的话会看到控制台打印了”someone connects”，表明已经成功连接到这个创建的TCP服务器。 / 设置连接的服务器 /server.listen(8000, function(){​ console.log(“Creat server on http://127.0.0.1:8000/“);}) 上面这段代码实际上触发的是server下的listening事件，等同于： / 设置监听端口 / server.listen(8000); / 设置监听时的回调函数 / server.on(“listening”, function () { ​ console.log(“Creat server on http://127.0.0.1:8000/“); }) 事实上，除了listening事件外，TCP服务器还支持以下事件： connection：当有新的连接创建时触发，回调函数的参数为socket连接对象。 close：TCP服务器关闭的时候触发，回调函数没有参数 error：TCP服务器发生错误的时候触发，回调函数的参数为error对象 下列代码通过net.Server类来创建一个TCP服务器，并添加以上事件。 1234567891011121314151617181920212223242526272829303132 /** * 通过net.Server类来创建一个TCP服务器 *//* 引入net模块 */var net = require(\"net\");/* 实例化一个服务器对象 */var server = new net.Server();/* 监听 connection 事件 */server.on(\"connection\", function (socket) &#123; console.log(\"someone connects\");&#125;);/* 设置监听端口 */server.listen(8000);/* 设置监听时的回调函数 */server.on(\"listening\", function () &#123; console.log(\"Creat server on http://127.0.0.1:8000/\");&#125;)/* 设置关闭时的回调函数 */server.on(\"close\", function () &#123; console.log(\"server closed!\");&#125;)/* 设置错误时的回调函数 */server.on(\"error\", function (err) &#123; console.log(\"error!\");&#125;) 查看服务器监听的地址当创建了一个TCP服务器后，可以通过server.address()方法来查看这个TCP服务器监听的地址，并返回一个JSON对象。这个对象的属性有： port：TCP服务器监听的端口号 family：说明TCP服务器监听的地址是 IPv6 还是 IPv address：TCP服务器监听的地址 1234567891011121314151617181920212223242526/** * 查看服务器监听的地址 *//* 引入net模块 */var net = require(\"net\");/* 创建TCP服务器 */var server = net.createServer(function(socket)&#123; console.log('someone connects');&#125;)/* 获取地址信息 */server.listen(8000,function()&#123; /* 获取地址信息，得到的是一个json &#123; address: '::', family: 'IPv6', port: 8000 &#125; */ var address = server.address(); /* TCP服务器监听的端口号 */ console.log(\"the port of server is\"+ address.port); /* TCP服务器监听的地址 */ console.log(\"the address of server is\"+ address.address); /* 说明TCP服务器监听的地址是 IPv6 还是 IPv4 */ console.log(\"the family of server is\"+ address.family);&#125;) 连接服务器的客户端数量创建一个TCP服务器后，可以通过server.getConnections()方法获取连接这个TCP服务器的客户端数量。除此之外，也可以通过maxConnections属性来设置这个服务器的最大连接数量，当连接数量超过最大值时，服务器将拒绝新的连接。 12345678910111213141516171819202122/** * 连接服务器的客户端数量 *//* 引入net模块 */var net = require(\"net\");/* 创建TCP服务器 */var server = net.createServer(function(socket)&#123; console.log('someone connects'); /* 设置最大连接数量 */ server.maxConnections=3; server.getConnections(function(err,count)&#123; console.log(\"the count of client is \"+count); &#125;)&#125;)/* 获取监听端口 */server.listen(8000,function()&#123; console.log(\"Creat server on http://127.0.0.1:8000/\");&#125;) 你可以打开多个网页输入localhost:8000来测试这段代码，也可以用Telnet命令 telnet localhost 8000 来连接这个TCP服务器（上一篇文章有提到如何用Homebrew安装Telnet：《Homebrew》）。 服务器和客户端之间的通信利用socket.write()可以使TCP服务器发送数据给客户端； socket对象可以用来获取客户端发出的流数据，每次接收到数据的时候触发data事件，通过监听这个事件就可以在回调函数中获取客户端发送的数据了。 1234567891011121314151617181920212223242526272829303132/** * 发送和获取 *//* 引入net模块 */var net = require(\"net\");/* 创建TCP服务器 */var server = net.createServer(function(socket)&#123; /* 获取地址信息 */ var address = server.address(); var message = \"the server address is\"+JSON.stringify(address); /* 发送数据 */ socket.write(message,function()&#123; var writeSize = socket.bytesWritten; console.log(message + \"has send\"); console.log(\"the size of message is\"+writeSize); &#125;) /* 监听data事件 */ socket.on('data',function(data)&#123; console.log(data.toString()); var readSize = socket.bytesRead; console.log(\"the size of data is\"+readSize); &#125;)&#125;)/* 获取地址信息 */server.listen(8000,function()&#123; console.log(\"Creat server on http://127.0.0.1:8000/\");&#125;) 下图中TCP服务器给客户端发送了字符串： the server address is{“address”:”::”,”family”:”IPv6”,”port”:8000}has send 客户端给TCP服务器发送了字符串 hello TCP! 和字节数。 用Node.js创建TCP客户端构建TCP客户端上面说到用打开网页或者Telnet来访问TCP服务器，其实我们也可以用Node.js来构建一个TCP客户端，实现TCP客户端和TCP服务器的通信。 为了使用Node.js创建TCP客户端，首先要使用require(“net”)来加载net模块，然后创建一个连接TCP客户端的socket对象即可： / 引入net模块 / var net = require(“net”); / 创建TCP客户端 / var client = net.Socket(); 创建完socket对象后，使用socket对象的connect方法就可以连接一个TCP服务器。 123456789101112131415161718192021222324252627/** * 构建TCP客户端 *//* 引入net模块 */var net = require(\"net\");/* 创建TCP客户端 */var client = net.Socket();/* 设置连接的服务器 */client.connect(8000, '127.0.0.1', function () &#123; console.log(\"connect the server\"); /* 向服务器发送数据 */ client.write(\"message from client\");&#125;)/* 监听服务器传来的data数据 */client.on(\"data\", function (data) &#123; console.log(\"the data of server is \" + data.toString());&#125;)/* 监听end事件 */client.on(\"end\", function () &#123; console.log(\"data end\");&#125;) TCP客户端和TCP服务器的通信运行 这段代码 之后再运行 这段代码 ，可以发现服务器已经接收到客户端的数据，客户端也已经接收到服务端的数据。 LINK 本章github源码：https://github.com/zc95/nodeTest/tree/master/TCP 《Node.js构建HTTP服务器》：https://zc95.github.io/2018/03/19/nodejs-HTTP/ 用Homebrew安装Telnet：https://zc95.github.io/2018/03/20/Homebrew/","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://zc95.github.io/tags/Node-js/"},{"name":"TCP","slug":"TCP","permalink":"http://zc95.github.io/tags/TCP/"}]},{"title":"Homebrew","slug":"Homebrew","date":"2018-03-20T13:31:52.000Z","updated":"2018-03-20T14:46:52.669Z","comments":true,"path":"2018/03/20/Homebrew/","link":"","permalink":"http://zc95.github.io/2018/03/20/Homebrew/","excerpt":"Homebrew简称brew，OSX上的软件包管理工具，在Mac终端可以通过brew安装、更新、卸载软件。 Homebrew 能干什么?Homebrew官网 的title是这么说的：macOS 缺失的软件包管理器，意思就是使用 Homebrew 安装 Apple 没有预装但你需要的东西，比如high sierra 10.13中移除了telent，只需要 brew install telent 一个命令就行。","text":"Homebrew简称brew，OSX上的软件包管理工具，在Mac终端可以通过brew安装、更新、卸载软件。 Homebrew 能干什么?Homebrew官网 的title是这么说的：macOS 缺失的软件包管理器，意思就是使用 Homebrew 安装 Apple 没有预装但你需要的东西，比如high sierra 10.13中移除了telent，只需要 brew install telent 一个命令就行。 安装 Homebrew一、进入Homebrew官网，按照官网提示在命令行执行ruby脚本（mac自带ruby），在终端运行以下命令： 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 二、按提示输入电脑密码，一路enter到底，直到出现下面的信息就说明安装成功。 1234==&gt; Next steps:- Run `brew help` to get started- Further documentation: https://docs.brew.sh 三、运行命令 brew help 就可以了解一些brew常用的命令： 1234567891011121314151617181920212223Example usage: brew search [TEXT|/REGEX/] brew (info|home|options) [FORMULA...] brew install FORMULA... brew update brew upgrade [FORMULA...] brew uninstall FORMULA... brew list [FORMULA...]Troubleshooting: brew config brew doctor brew install -vd FORMULADevelopers: brew create [URL [--no-fetch]] brew edit [FORMULA...] https://docs.brew.sh/Formula-CookbookFurther help: man brew brew help [COMMAND] brew home","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"Homebrew","slug":"Homebrew","permalink":"http://zc95.github.io/tags/Homebrew/"},{"name":"brew","slug":"brew","permalink":"http://zc95.github.io/tags/brew/"},{"name":"telnet","slug":"telnet","permalink":"http://zc95.github.io/tags/telnet/"}]},{"title":"Node.js构建HTTP服务器","slug":"nodejs-HTTP","date":"2018-03-19T12:29:42.000Z","updated":"2018-03-21T14:40:50.273Z","comments":true,"path":"2018/03/19/nodejs-HTTP/","link":"","permalink":"http://zc95.github.io/2018/03/19/nodejs-HTTP/","excerpt":"Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. Node.js简介Node.js 是一个基于 Google Chrome V8 引擎 的 JavaScript 运行环境。Node.js使用后多种先进的技术，其中包括 事件驱动、非阻塞 I/O 模型，使其轻量又高效，受到众多开发者的追捧。 简单的说，Node.js 就是运行在服务端的 JavaScript ，可以稳定地在各种平台下运行，包括Linux、Windows、Mac OS X、Sun Os 和FreeBSD等众多平台。","text":"Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. Node.js简介Node.js 是一个基于 Google Chrome V8 引擎 的 JavaScript 运行环境。Node.js使用后多种先进的技术，其中包括 事件驱动、非阻塞 I/O 模型，使其轻量又高效，受到众多开发者的追捧。 简单的说，Node.js 就是运行在服务端的 JavaScript ，可以稳定地在各种平台下运行，包括Linux、Windows、Mac OS X、Sun Os 和FreeBSD等众多平台。 安装nodejs 点击 https://nodejs.org 进入nodejs官网 有两个版本：LTS和Current，LTS是长期支持版本，成熟可靠 next到底 打开终端，输入 node -v ，回车，如果出现类似 v6.11.4 的版本号就说明安装成功 构建一个HTTP服务器在如今web大行其道的时代，支撑无数网页运行的正是HTTP服务器。Node.js之所以受到大量web开发者的青睐，与Node.js有能力自己构建服务器是分不开的。 在根目录下新建 nodetest 文件夹 在 nodetest 下新建 HTTP 文件夹 在 HTTP 文件夹下新建一个 server.js 的文件 拷贝粘贴这段代码，保存： 1234567891011121314151617181920212223/** * 创建http服务器 *//* 引入http模块 */var http = require(\"http\");/* 创建HTTP服务器 */var server = http.createServer(function(request, response) &#123; /* 设置相应的头部 */ response.writeHead(200, &#123; \"content-Type\" : \"text/plain\" &#125;); /* 设置相应的数据 */ response.write(\"Welcome to Nodejs\"); response.end();&#125;);/* 设置服务器端口 */server.listen(8000, function()&#123; console.log(\"Creat server on http://127.0.0.1:8000/\");&#125;) 打开终端 输入 cd nodetest/HTTP 输入 node server.js ，返回 Creat server on http://127.0.0.1:8000/ 打开浏览器输入 http://127.0.0.1:8000/ 或者 http://localhost:8000 Welcome to Nodejs 文件模块上面说到的HTTP服务器知识实现了将一串字符串发送给服务器。很明显，如果服务器只能发送一些字符串，那几乎是远远不够的，因此我们要做一些扩展，通过文件模块将文件读取并发送给服务器是一个不错的选择，在nodetest文件夹下新建 fsModule.js : 1234567891011121314151617181920212223242526272829/** * fs模块 *//* 引入http模块 */var http = require(\"http\");/* 引入fs模块 */var fs = require(\"fs\");/* 创建HTTP服务器 */var server = http.createServer(function(request, response) &#123; /* 设置响应的头部 */ response.writeHead(200, &#123; \"content-Type\" : \"text/html\" &#125;); /* 读取文件数据 */ var data = fs.readFileSync(\"./index.html\"); /* 设置响应的数据 */ response.write(data); response.end();&#125;);/* 设置服务器端口 */server.listen(8000, function()&#123; console.log(\"Creat server on http://127.0.0.1:8000/\");&#125;) 同时在同级目录中创建一个名为 index.html 的文件，写入以下代码： 123456789101112&lt;! doctype &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;fs module&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;fs文件模块&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; node fsModule.js 运行，在浏览器中打开 http://localhost:8000 ，Node.js已经把index这个文件发送到客户端了； 需要提及的是，这里HTTP服务器在发送给浏览器的头部信息中将 content-type修改为了 text/html 。 content-type的人作用就是用来表示客户端或者服务器传输数据的类型，服务器或者客客户端通过这个值来做相应的解析。如果这个值改为原来的 text/plain ，浏览器将显示index.html的所有源代码，这显然不是我们想要的。 HTTP服务器的路由控制上一节中的服务器虽然已经可以通过读取文件数据来发送给客户端了，但你并没有做任何的路由控制，在浏览器中输入任何URL都将返回同样的内容，简单来说，路由就是URL到函数的映射。 要做到路由控制，通过上面的学习可以预想到修改content-type就可以了，这里假定只需要处理html、js、css和图片文件，创建一个名为 mime.js 的文件： 12345678910module.exports = &#123; \".html\" : \"text/html\", \".css\" : \"text/css\", \".js\" : \"text/javascript\", \".gif\" : \"image/gif\", \".ico\" : \"image/x-icon\", \".jpeg\" : \"image/jpeg\", \".jpg\" : \"image/jpeg\", \".png\" : \"image/png\",&#125; 创建一个名为 fsModule2.js 的文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 这里通过路径处理判断来返回不同的资源，从而做到简单的路由控制 *//* 引入http模块 */var http = require(\"http\");/* 引入fs模块 */var fs = require(\"fs\");/* 引入url模块 */var url = require(\"url\");/* 引入mime文件 */var mime = require(\"./mime.js\");/* 引入path模块 */var path = require(\"path\");/* 创建HTTP服务器 */var server = http.createServer(function(request, response) &#123; var filePath = \".\"+url.parse(request.url).pathname; if(filePath === \"./\")&#123; filePath = './index.html' &#125; /* 判断相应的文件是否存在 */ fs.exists(filePath,function(exists)&#123; /* 存在则返回相应文件数据 */ if(exists)&#123; var data = fs.readFileSync(filePath); var contentType = mime[path.extname(filePath)]; response.writeHead(200,&#123; \"content-type\": contentType &#125;); response.write(data); response.end(); &#125;else&#123; response.end(\"404\"); &#125; &#125;)&#125;);/* 设置服务器端口 */server.listen(8000, function()&#123; console.log(\"Creat server on http://127.0.0.1:8000/\");&#125;) 这里通过对路径处理判断来返回不同的资源，从而做到简单的路由控制。 LINK 本章github源码：https://github.com/zc95/nodeTest/tree/master/HTTP 《Node.js构建TCP服务器和TCP客户端》：https://zc95.github.io/2018/03/20/nodejs-TCP/","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://zc95.github.io/tags/Node-js/"},{"name":"本地服务器","slug":"本地服务器","permalink":"http://zc95.github.io/tags/本地服务器/"}]},{"title":"ES6入门","slug":"es6-webpack","date":"2018-03-13T13:42:52.000Z","updated":"2018-03-20T13:32:31.632Z","comments":true,"path":"2018/03/13/es6-webpack/","link":"","permalink":"http://zc95.github.io/2018/03/13/es6-webpack/","excerpt":"github：https://github.com/zc95/es6-webpack webpack搭建ES6环境首先下载源码 1git clone https://github.com/zc95/es6-webpack.git 然后安装 1234cd es6-webpacknpm installnpm install webpack -gnpm install webpack-dev-server -g 最后运行 12cd es6-webpacknpm start","text":"github：https://github.com/zc95/es6-webpack webpack搭建ES6环境首先下载源码 1git clone https://github.com/zc95/es6-webpack.git 然后安装 1234cd es6-webpacknpm installnpm install webpack -gnpm install webpack-dev-server -g 最后运行 12cd es6-webpacknpm start es6基础常量123456// ES5 中常量的写法Object.defineProperty(window, \"PI2\", &#123; value: 3.1415926, writable: false,&#125;) 123// ES6 的常量写法const PI = 3.1415926 箭头函数1234567// ES3,ES5var evens = [1, 2, 3, 4, 5];var odds = evens.map(function(v) &#123; return v + 1&#125;); console.log(evens, odds);&#125;; 1234// ES6let evens = [1, 2, 3, 4, 5];let odds = evens.map(v =&gt; v + 1);console.log(evens, odds); this的指向 1234567891011121314// ES3,ES5中 this 的指向是 该函数被调用的对象 var factory = function() &#123; this.a = 'a'; this.b = 'b'; this.c = &#123; a: 'a+', b: function() &#123; return this.a &#125; &#125; &#125; console.log(new factory().c.b());&#125;; 123456789101112// ES6箭头函数中 this 的指向是 定义时this的指向var factory = function() &#123; this.a = 'a'; this.b = 'b'; this.c = &#123; a: 'a+', b: () =&gt; &#123; return this.a &#125; &#125; &#125; console.log(new factory().c.b()); 默认参数默认参数 1234567891011// ES5\\ES3 默认参数的写法 function f(x, y, z) &#123; if (y === undefined) &#123; y = 7; &#125; if (z === undefined) &#123; z = 42 &#125; return x + y + z &#125; console.log(f(1, 3)); 12345// ES6 默认参数 function f(x, y = 7, z = 42) &#123; return x + y + z &#125; console.log(f(1, 3)); 可变参数 12345678910// ES3,ES5 可变参数 function f() &#123; var a = Array.prototype.slice.call(arguments); var sum = 0; a.forEach(function(item) &#123; sum += item * 1; &#125;) return sum &#125; console.log(f(1, 2, 3, 6)); 123456789// ES6 可变参数function f(...a) &#123; var sum = 0; a.forEach(item =&gt; &#123; sum += item * 1 &#125;); return sum &#125; console.log(f(1, 2, 3, 6)); 合并数组 1234// ES5 合并数组 var params = ['hello', true, 7]; var other = [1, 2].concat(params); console.log(other); 123456// ES6 利用扩展运算符合并数组 var params = ['hello', true, 7]; var other = [ 1, 2, ...params ]; console.log(other); 对象代理1234567891011121314151617181920212223242526// ES3,ES5 数据保护 var Person = function() &#123; var data = &#123; name: 'es3', sex: 'male', age: 15 &#125; this.get = function(key) &#123; return data[key] &#125; this.set = function(key, value) &#123; if (key !== 'sex') &#123; data[key] = value &#125; &#125; &#125; // 声明一个实例 var person = new Person(); // 读取 console.table(&#123;name: person.get('name'), sex: person.get('sex'), age: person.get('age')&#125;); // 修改 person.set('name', 'es3-cname'); console.table(&#123;name: person.get('name'), sex: person.get('sex'), age: person.get('age')&#125;); person.set('sex', 'female'); console.table(&#123;name: person.get('name'), sex: person.get('sex'), age: person.get('age')&#125;); 1234567891011121314151617181920// ES5 var Person = &#123; name: 'es5', age: 15 &#125;; Object.defineProperty(Person, 'sex', &#123; writable: false, value: 'male' &#125;); console.table(&#123;name: Person.name, age: Person.age, sex: Person.sex&#125;); Person.name = 'es5-cname'; console.table(&#123;name: Person.name, age: Person.age, sex: Person.sex&#125;); try &#123; Person.sex = 'female'; console.table(&#123;name: Person.name, age: Person.age, sex: Person.sex&#125;); &#125; catch (e) &#123; console.log(e); &#125; 12345678910111213141516171819202122232425262728293031// ES6 let Person = &#123; name: 'es6', sex: 'male', age: 15 &#125;; let person = new Proxy(Person, &#123; get(target, key) &#123; return target[key] &#125;, set(target,key,value)&#123; if(key!=='sex')&#123; target[key]=value; &#125; &#125; &#125;); console.table(&#123; name:person.name, sex:person.sex, age:person.age &#125;); try &#123; person.sex='female'; &#125; catch (e) &#123; console.log(e); &#125; finally &#123; &#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://zc95.github.io/tags/ES6/"},{"name":"webpack","slug":"webpack","permalink":"http://zc95.github.io/tags/webpack/"}]},{"title":"撸了一个canvas手写板","slug":"canvasPalette","date":"2018-03-08T15:15:11.000Z","updated":"2018-03-20T13:32:54.416Z","comments":true,"path":"2018/03/08/canvasPalette/","link":"","permalink":"http://zc95.github.io/2018/03/08/canvasPalette/","excerpt":"用 canvas 写了一个手写板，功能：画笔粗细、橡皮擦大小、画笔颜色、清空画布、历史操作等 canvas手写板 demo github 扫一扫","text":"用 canvas 写了一个手写板，功能：画笔粗细、橡皮擦大小、画笔颜色、清空画布、历史操作等 canvas手写板 demo github 扫一扫","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://zc95.github.io/tags/canvas/"},{"name":"material design","slug":"material-design","permalink":"http://zc95.github.io/tags/material-design/"}]},{"title":"直播平台的弹幕功能","slug":"liveVideo","date":"2018-02-21T04:51:05.000Z","updated":"2018-03-20T13:33:15.758Z","comments":true,"path":"2018/02/21/liveVideo/","link":"","permalink":"http://zc95.github.io/2018/02/21/liveVideo/","excerpt":"类似直播平台的弹幕功能（微信上有bug） demo github 扫一扫","text":"类似直播平台的弹幕功能（微信上有bug） demo github 扫一扫 QQ、微信内置浏览器 X5内核的坑进入页面video自动全屏、自动播放然而我并不需要这样，解决方法：给video标签加上 x5-playsinline=”” playsinline=”” webkit-playsinline=”” 就ok 123&lt;video src=\"http://huya-w10.huya.com/migrate/1714/3601054/1300/328ac8830192294f41c33ccc1f61d199.mp4\" controls=\"\" x5-playsinline=\"\" playsinline=\"\" webkit-playsinline=\"\" poster=\"\" preload=\"auto\"&gt;&lt;/video&gt; video层级默认最高z-index怎么设置都无效，所以微信或者qq扫出来的页面弹幕都是看不到的，在video下面了。。。 暂时没法解决，有空再看吧","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"video","slug":"video","permalink":"http://zc95.github.io/tags/video/"},{"name":"X5内核","slug":"X5内核","permalink":"http://zc95.github.io/tags/X5内核/"}]},{"title":"自己写了个音乐播放器","slug":"musicPlayer","date":"2018-02-21T04:45:29.000Z","updated":"2018-03-20T13:33:31.498Z","comments":true,"path":"2018/02/21/musicPlayer/","link":"","permalink":"http://zc95.github.io/2018/02/21/musicPlayer/","excerpt":"material design风格的音乐播放器 demo github 扫一扫","text":"material design风格的音乐播放器 demo github 扫一扫 HTML 5 audio标签定义和用法 标签定义声音，比如音乐或其他音频流，是 HTML 5 的新标签。 实例123&lt;audio src=\"https://music.163.com/song/media/outer/url?id=451703096.mp3\"&gt;您的浏览器不支持 audio 标签。&lt;/audio&gt; 提示和注释可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。 属性 属性 值 描述 autoplay autoplay 如果出现该属性，则音频在就绪后马上播放。 controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。 loop loop 如果出现该属性，则每当音频结束时重新开始播放。 preload preload 如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。 src url 要播放的音频的 URL。 Javascript控制html5 Audio标签javascript动态创建audio标签123var audio=document.creatElement(\"audio\");audio.src=\"audio/source.ogg\";//路径audio.play(); or 12audio=new Audio(\"audio/source.ogg\");//路径audio.play(); 预加载我们可以通过preload=”auto”来实现音频的自动加载，但是我们无法知道音频加载的进度 这时候可以用canplaythrough来完成 12345var audio = document.createElement(\"audio\");audio.src = \"https://music.163.com/song/media/outer/url?id=451703096.mp3\";audio.addEventListener(\"canplaythrough\", function () &#123;truealert('音频文件已经准备好，随时待命');&#125;, false); 第一次运行时间会长一些，第二次运行由于文件已经缓存到本地，所以会直接弹出提示框。 javascript控制audio的播放，暂停，停止1234567891011121314function aPlay() &#123;trueaudio.play();&#125;function aPause() &#123;trueaudio.pause();&#125;function aStop() &#123;trueaudio.currentTime = 0;trueaudio.pause();&#125;function aSkip() &#123;trueaudio.currentTime = 50;trueaudio.play(); &#125; 1234&lt;input type=\"button\" onclick=\"aPlay();\" value=\"播放音频\"&gt;&lt;input type=\"button\" onclick=\"aPause();\" value=\"暂停音频\"&gt;&lt;input type=\"button\" onclick=\"aStop();\" value=\"停止音频\"&gt;&lt;input type=\"button\" onclick=\"aSkip();\" value=\"跳到第50秒\"&gt; javascript控制audio的声音大小 audio.volume = 0;//表示静音 audio.volume = 1; //表示声音最大 audio.volume //返回当前音量，声音值在0-1之间 javascript控制audio的快进，快退，以及显示进度与时长 audio.currentTime //控制audio的进度 audio.duration //返回当前音量的总时长","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"material design","slug":"material-design","permalink":"http://zc95.github.io/tags/material-design/"}]},{"title":"教你下载会员歌曲","slug":"musicLink","date":"2018-02-19T15:19:04.000Z","updated":"2018-03-20T13:33:47.658Z","comments":true,"path":"2018/02/19/musicLink/","link":"","permalink":"http://zc95.github.io/2018/02/19/musicLink/","excerpt":"教你找歌曲的外链（要会员的歌曲都能下载🤪） 什么是歌曲的外链？我们手机里的歌曲都是下载好的mp3文件，比如说散就散.mp3， 而外链就比如 https://music.163.com/song/media/outer/url?id=523251118.mp3 这样链接的形式。 怎么免费下载会员歌曲？你应该注意到了《说散就散》在qq音乐和网易云都是要vip才能下载","text":"教你找歌曲的外链（要会员的歌曲都能下载🤪） 什么是歌曲的外链？我们手机里的歌曲都是下载好的mp3文件，比如说散就散.mp3， 而外链就比如 https://music.163.com/song/media/outer/url?id=523251118.mp3 这样链接的形式。 怎么免费下载会员歌曲？你应该注意到了《说散就散》在qq音乐和网易云都是要vip才能下载 这里以网易云音乐的网页版为例说一下”破解“的方法 这个外链下载会员歌曲的方法也是最近撸一个播放器的时候发现的 https://zc95.github.io/demo/music （还在改进，下次再说吧 ，逃。。。） 废话少说，开始了第一步打开你电脑上的浏览器，输入 http://music.163.com ，网易云音乐官网，输入 “说散就散” 搜索，点第一个要钱的原唱！ 第二步到了 http://music.163.com/#/song?id=523251118 这个页面 这个什么 生成外链播放器 不用管，就是个iframe（一般用来博客里），点了提示没版权，放弃。。。 还有下载按钮，点了提示下载PC端和app，肯定还是要会员。。。放弃 重点是url，有个?id = xxxxx ，原来百度云网页版的每首歌都有自己的id标识 第三步从url得到这首歌的id是 523251118 所以这首歌的外链就是 https://music.163.com/song/media/outer/url?id=523251118.mp3 ，之后找到别的歌，把这个链接的id替换了就行，除了那种网易云没播放版权的，所有的都可以。 第四步打开电脑里的浏览器，输入 https://music.163.com/song/media/outer/url?id=523251118.mp3 回车，这时候url被解析成好长的一段，不用管它，有上面的链接就足够了，点html5 video标签上的下载按钮就行啦（如下），移动端和Safari的video应该是没有下载按钮的。。。 第五步如果是安卓机的就直接把这首歌导入到手机里去，qq音乐、网易云都会自动加到列表里去。 如果是iphone，，，那就没啥吊用了。。。。 最后说一下，有很多方法下载这种会员歌曲，，发现这种方法是因为最近在手撸一个音乐播放器，需要用到这样的链接https://zc95.github.io/demo/music 不然才不费这么大劲。。毕竟我有破解版😂😂😂","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"歌曲","slug":"歌曲","permalink":"http://zc95.github.io/tags/歌曲/"}]},{"title":"Rich Text Format","slug":"RTF","date":"2018-02-06T15:20:53.000Z","updated":"2018-02-10T12:47:08.084Z","comments":true,"path":"2018/02/06/RTF/","link":"","permalink":"http://zc95.github.io/2018/02/06/RTF/","excerpt":"自己写的一个移动端的富文本编辑器 Link demo github","text":"自己写的一个移动端的富文本编辑器 Link demo github","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"一行代码实现星级评分","slug":"star-rating","date":"2018-01-23T13:03:13.000Z","updated":"2018-01-30T15:23:57.113Z","comments":true,"path":"2018/01/23/star-rating/","link":"","permalink":"http://zc95.github.io/2018/01/23/star-rating/","excerpt":"实现原理 Link demo github","text":"实现原理 Link demo github 主要代码css12345678910.score_wrapper &#123; display:inline-block; font-size: 45px; cursor: pointer; color: #dc2020; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none; &#125; html1&lt;div class=\"score_wrapper\"&gt;&lt;/div&gt; javascript123456789101112131415161718192021222324252627$(function () &#123; ScoreInit(3); //初始化，参数是0～5的数字，代表星数，传空默认0颗星&#125;)//点击function ScoreInit(e) &#123; Score((e == null) ? 0 : e); //传空默认0颗星 $(\".score_wrapper\").bind('click', function (e) &#123; var eachWidth = $(\".score_wrapper\").width() / 5; //计算出每个星星的长度 var X = e.pageX - $(this).offset().left; //距离父容器的偏移距离 var score = Math.floor(X / eachWidth) + 1; //分数 Score((getScore() == score) ? 0 : score); //取消评分 &#125;)&#125;//评分function Score(rate) &#123; $(\".score_wrapper\").html(\"★★★★★☆☆☆☆☆\".slice(5 - rate, 10 - rate));&#125;//获取评分function getScore() &#123; var str = $(\".score_wrapper\").html(), num = 0; for (var i = 0; i &lt; str.length; i++) &#123; if (str[i] == \"★\") &#123; num++ &#125; &#125; return num;&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"水平垂直居中","slug":"centerAndmiddle","date":"2018-01-10T13:17:24.000Z","updated":"2018-01-10T14:26:16.028Z","comments":true,"path":"2018/01/10/centerAndmiddle/","link":"","permalink":"http://zc95.github.io/2018/01/10/centerAndmiddle/","excerpt":"水平垂直居中（已知宽高）方法很多，这里就说一个不常见的 123456&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718.father &#123; position: relative; width: 300px; height: 300px; border: 1px solid black;&#125;.son &#123; position: absolute; width: 60px; height: 60px; top: 0; left: 0; bottom: 0; right: 0; margin: auto; border: 1px solid gray;&#125;","text":"水平垂直居中（已知宽高）方法很多，这里就说一个不常见的 123456&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718.father &#123; position: relative; width: 300px; height: 300px; border: 1px solid black;&#125;.son &#123; position: absolute; width: 60px; height: 60px; top: 0; left: 0; bottom: 0; right: 0; margin: auto; border: 1px solid gray;&#125; 水平垂直居中（宽高不确定/伪元素）用伪元素和 inline-block / vertical-align 可以实现水平垂直居中 123456&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223.father &#123; position:fixed; top:0; right:0; left:0; bottom:0; text-align: center; border: 1px solid black;&#125;.father:before &#123; content: ''; display: inline-block; height: 100%; vertical-align: middle; margin-right: -0.25em; /*去空隙*/&#125;.son &#123; display: inline-block; vertical-align: middle; border: 1px solid gray;&#125; 水平垂直居中（宽高不确定/flex）css弹性布局（flex） 123456&lt;div class=\"father\"&gt; &lt;div class=\"son\" style=\"display:inline-block;\"&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678910.father &#123; height: 300px; width: 100%; display: flex; align-items: center; /*定义body的元素垂直居中*/ justify-content: center; /*定义body的里的元素水平居中*/&#125;.son&#123; border:1px solid gray;&#125; 水平垂直居中（宽高不确定/transform）CSS3的transform，通过设置div的transform: translate(-50%,-50%)，使得div向上平移（translate）自身高度的一半(50%)、自身宽度的一半(50%) 1234&lt;div class=\"son\"&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt;&lt;/div&gt; 12345678910.son &#123; position: absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%); border: 1px solid gray;&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"},{"name":"水平垂直居中","slug":"水平垂直居中","permalink":"http://zc95.github.io/tags/水平垂直居中/"}]},{"title":"ToDo 待办事宜app","slug":"ToDo","date":"2018-01-07T10:29:58.000Z","updated":"2018-01-07T12:54:37.260Z","comments":true,"path":"2018/01/07/ToDo/","link":"","permalink":"http://zc95.github.io/2018/01/07/ToDo/","excerpt":"ToDo最近做事情总是丢三落四，老忘记一些重要的事情，就突发奇想写了这个 ToDo 待办事宜的app。 项目地址 github地址","text":"ToDo最近做事情总是丢三落四，老忘记一些重要的事情，就突发奇想写了这个 ToDo 待办事宜的app。 项目地址 github地址 主要功能 可以添加待办事项到首页中，数据都是保存在本地localStorage的，只要不是手动删除或者换了设备，数据是永久保存的 点击事项可以将待办事项的状态改为 选中 和 未选中 ，每次改变状态都会保存到localStorage，每天的开始都可以点 重置所有状态 的按钮来设置所有的待办事项为未选中 可以删除已添加的待办事项或者彻底删除所有本地localStorage数据 可以复制项目链接在自己的浏览器中打开，然后添加到桌面，方便使用；https://htmlpreview.github.io/?https://github.com/zc95/ToDo/blob/master/index.html","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"localStorage","slug":"localStorage","permalink":"http://zc95.github.io/tags/localStorage/"}]},{"title":"VMware服务器虚拟化","slug":"VMware","date":"2017-12-26T12:49:24.000Z","updated":"2017-12-26T13:10:59.659Z","comments":true,"path":"2017/12/26/VMware/","link":"","permalink":"http://zc95.github.io/2017/12/26/VMware/","excerpt":"今天去机房打了一天酱油，听到了看到了一些没接触过的东西，做个简单的整理。 VMware服务器虚拟化VMware官网 大多数服务器的容量利用率不足 15%，这不仅导致了服务器数量剧增，还增加了复杂性。实现服务器虚拟化后，多个操作系统可以作为虚拟机在单台物理服务器上运行，并且每个操作系统都可以访问底层服务器的计算资源，从而解决效率低下问题。接下来将服务器集群聚合为一项整合资源，这可以提高整体效率并降低成本。服务器虚拟化还可以加快工作负载部署速度、提高应用性能以及改善可用性。","text":"今天去机房打了一天酱油，听到了看到了一些没接触过的东西，做个简单的整理。 VMware服务器虚拟化VMware官网 大多数服务器的容量利用率不足 15%，这不仅导致了服务器数量剧增，还增加了复杂性。实现服务器虚拟化后，多个操作系统可以作为虚拟机在单台物理服务器上运行，并且每个操作系统都可以访问底层服务器的计算资源，从而解决效率低下问题。接下来将服务器集群聚合为一项整合资源，这可以提高整体效率并降低成本。服务器虚拟化还可以加快工作负载部署速度、提高应用性能以及改善可用性。 虚拟化的优势虚拟化可以提高 IT 部门的敏捷性、灵活性和可扩展性，同时大幅节约成本。工作负载的部署速度更快、性能和可用性得到提升、运维实现自动化，所有这一切不仅简化了 IT 管理，还降低了拥有成本和运维成本。其他优势包括： 降低资金成本和运维成本。 最大限度地减少或消除停机。 提高 IT 部门的工作效率、效益、敏捷性和响应能力。 更快地调配应用和资源。 支持业务连续性与灾难恢复。 简化数据中心管理。 构建真正的软件定义的数据中心 VMware vSphere client用来连接VMware ESXi主机和vCenter server，业内最完整、 最强健的虚拟化平台。创建资源池来管理计算、 网络和存储容量与易用性，并提供最高水平的服务，每个应用程序工作负载以最低的总成本。VSphere — — 取决于世界上要求最苛刻的数据中心虚拟化您业务关键型应用程序为空前的灵活性和可靠性。 UPS电源百度百科 UPS电源一般指不间断电源。 UPS（Uninterruptible Power System/Uninterruptible Power Supply），即不间断电源，是将蓄电池（多为铅酸免维护蓄电池）与主机相连接，通过主机逆变器等模块电路将直流电转换成市电的系统设备。主要用于给单台计算机、计算机网络系统或其它电力电子设备如电磁阀、压力变送器等提供稳定、不间断的电力供应。当市电输入正常时，UPS 将市电稳压后供应给负载使用，此时的UPS就是一台交流式电稳压器，同时它还向机内电池充电；当市电中断（事故停电）时， UPS 立即将电池的直流电能，通过逆变器切换转换的方法向负载继续供应220V交流电，使负载维持正常工作并保护负载软、硬件不受损坏。UPS 设备通常对电压过高或电压过低都能提供保护。 特点 UPS是针对中国电网环境和网络监控及网络系统、医疗系统等对电源的可靠性要求，克服中、大型计算机网络系统集中供电所造成的供电电网环境日益恶劣的问题，以全新的数字技术研制出的第三代工频纯在线式智能型UPS。直流电源，是维持电路中形成稳恒电流的装置。如干电池、蓄电池、直流发电机等。 UPS和直流电源是企业重要的供电保障设备，传统的维护管理包括：①日常巡检外观，定期更换电池、滤波电容、风机等易损件，大修时做电池活化等；②改造或采用换代设备，使用高级工具测试电池性能。这种管理方式企业投入成本高，维护人员工作量大，不易实时掌握设备运行状态和关键数据，设备事故预防能力低。实施在线维护管理可避免传统方式的不足之处，获得良好效益。 UPS的中文意思为“不间断电源”，是英语“Uninterruptible Power System/Uninterruptible Power Supply”的缩写，它可以保障计算机系统在停电之后继续工作一段时间以使用户能够紧急存盘，使用户不致因停电而影响工作或丢失数据。 交换机百度百科 交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机。其他常见的还有电话语音交换机、光纤交换机等。 图片上是 Cisco Catalyst 4500-E Series ，Cisco Catalyst 4500-X 系列交换机 概念交换（switching）是按照通信两端传输信息的需要，用人工或设备自动完成的方法，把要传输的信息送到符合要求的相应路由上的技术的统称。根据工作位置的不同，可以分为广域网交换机和局域网交换机。广义的交换机（switch）就是一种在通信系统中完成信息交换功能的设备。 在计算机网络系统中，交换概念的提出改进了共享工作模式。我们以前介绍过的HUB集线器就是一种共享设备，HUB本身不能识别目的地址，当同一局域网内的A主机给B主机传输数据时，数据包在以HUB为架构的网络上是以广播方式传输的，由每一台终端通过验证数据包头的地址信息来确定是否接收。也就是说，在这种工作方式下，同一时刻网络上只能传输一组数据帧的通讯，如果发生碰撞还得重试。这种方式就是共享网络带宽。 hub百度百科 HUB是一个多端口的转发器，在以HUB为中心设备时，即使网络中某条线路产生了故障，并不影响其它线路的工作。所以HUB在局域网中得到了广泛的应用。大多数的时候它用在星型与树型网络拓扑结构中，以RJ45接口与各主机相连（也有BNC接口），HUB按照不同的说法有很多种类。 HUB按照对输入信号的处理方式上，可以分为无源HUB、有源HUB、智能HUB。 磁盘阵列百度百科 磁盘阵列（Redundant Arrays of Independent Disks，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。 磁盘阵列是由很多价格较便宜的磁盘，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。利用这项技术，将数据切割成许多区段，分别存放在各个硬盘上。 磁盘阵列还能利用同位检查（Parity Check）的观念，在数组中任意一个硬盘故障时，仍可读出数据，在数据重构时，将数据经计算后重新置入新硬盘中。 堡垒机百度百科 堡垒机，即在一个特定的网络环境下，为了保障网络和数据不受来自外部和内部用户的入侵和破坏，而运用各种技术手段实时收集和监控网络环境中每一个组成部分的系统状态、安全事件、网络活动，以便集中报警、及时处理及审计定责。 产生原因随着企事业单位IT系统的不断发展，网络规模和设备数量迅速扩大，日趋复杂的IT系统与不同背景的运维人员的行为给信息系统安全带来较大风险，主要表现在： 多个用户使用同一个账号。这种情况主要出现在同一工作组中，由于工作需要，同时系统管理账号唯一，因此只能多用户共享同一账号。如果发生安全事故，不仅难以定位账号的实际使用者和责任人，而且无法对账号的使用范围进行有效控制，存在较大安全风险和隐患。 一个用户使用多个账号。目前，一个维护人员使用多个账号是较为普遍的情况，用户需要记忆多套口令同时在多套主机系统、网络设备之间切换，降低工作效率，增加工作复杂度。如下图所示： 缺少统一的权限管理平台，权限管理日趋繁重和无序；而且维护人员的权限大多是粗放管理，无法基于最小权限分配原则的用户权限管理，难以实现更细粒度的命令级权限控制，系统安全性无法充分保证。 无法制定统一的访问审计策略，审计粒度粗。各网络设备、主机系统、数据库是分别单独审计记录访问行为，由于没有统一审计策略，并且各系统自身审计日志内容深浅不一，难以及时通过系统自身审计发现违规操作行为和追查取证。 传统的网络安全审计系统无法对维护人员经常使用的SSH、RDP等加密、图形操作协议进行内容审计。 核心功能单点登录功能支持对X11、linux、unix、数据库、网络设备、安全设备等一系列授权账号进行密码的自动化周期更改，简化密码管理，让使用者无需记忆众多系统密码，即可实现自动登录目标设备，便捷安全。[1] 账号管理设备支持统一账户管理策略，能够实现对所有服务器、网络设备、安全设备等账号进行集中管理，完成对账号整个生命周期的监控，并且可以对设备进行特殊角色设置如：审计巡检员、运维操作员、设备管理员等自定义设置，以满足审计需求 身份认证设备提供统一的认证接口，对用户进行认证，支持身份认证模式包括 动态口令、静态密码、硬件key 、生物特征等多种认证方式，设备具有灵活的定制接口，可以与其他第三方认证服务器之间结合；安全的认证模式，有效提高了认证的安全性和可靠性。 资源授权设备提供基于用户、目标设备、时间、协议类型IP、行为等要素实现细粒度的操作授权，最大限度保护用户资源的安全 访问控制设备支持对不同用户进行不同策略的制定，细粒度的访问控制能够最大限度的保护用户资源的安全，严防非法、越权访问事件的发生。 操作审计设备能够对字符串、图形、文件传输、数据库等全程操作行为审计；通过设备录像方式实时监控运维人员对操作系统、安全设备、网络设备、数据库等进行的各种操作，对违规行为进行事中控制。对终端指令信息能够进行精确搜索，进行录像精确定位。[2]","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"VMware","slug":"VMware","permalink":"http://zc95.github.io/tags/VMware/"},{"name":"服务器虚拟化","slug":"服务器虚拟化","permalink":"http://zc95.github.io/tags/服务器虚拟化/"},{"name":"堡垒机","slug":"堡垒机","permalink":"http://zc95.github.io/tags/堡垒机/"},{"name":"磁盘阵列","slug":"磁盘阵列","permalink":"http://zc95.github.io/tags/磁盘阵列/"},{"name":"交换机","slug":"交换机","permalink":"http://zc95.github.io/tags/交换机/"}]},{"title":"JavaScript闭包","slug":"javascriptClosure","date":"2017-12-21T12:48:17.000Z","updated":"2017-12-26T13:11:21.185Z","comments":true,"path":"2017/12/21/javascriptClosure/","link":"","permalink":"http://zc95.github.io/2017/12/21/javascriptClosure/","excerpt":"对于JavaScript的程序员来说，闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 MDN Closures 变量的作用域变量的作用域无非就是两种：全局变量和局部变量。当在函数中声明一个变量的时候，如果用关键字var来声明此变量，那么它就是局部变量，如果没有var那么就会成为全局变量。一般不建议用这种方式定义全局变量。而是用var将变量声明在函数的外面。 12345var name = '小张'; // 全局变量function func() &#123; var name = '小明'; // 局部变量 age = 12; // 全局变量，建议少用这种全局变量的定义方式&#125;","text":"对于JavaScript的程序员来说，闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 MDN Closures 变量的作用域变量的作用域无非就是两种：全局变量和局部变量。当在函数中声明一个变量的时候，如果用关键字var来声明此变量，那么它就是局部变量，如果没有var那么就会成为全局变量。一般不建议用这种方式定义全局变量。而是用var将变量声明在函数的外面。 12345var name = '小张'; // 全局变量function func() &#123; var name = '小明'; // 局部变量 age = 12; // 全局变量，建议少用这种全局变量的定义方式&#125; 在JavaScript中，函数可以用来创造函数作用域。函数内部可以看到外面的变量，而外面看不到函数里的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，直到搜索到全局变量为止。 123456789101112var a = 1;var func1 = function()&#123; var b = 2; var func2 = function()&#123; var c = 3; console.log( b ); // 2 console.log( a ); // 1 &#125; func2(); console.log( c ); // 报错：c is not defined&#125;;func1(); 那么能不能从函数外部来访问局部变量呢？答案是可以。 1234567var func = function() &#123; var number = 6; return function() &#123; return number; &#125; &#125;;console.log( func()() ); // 6 变量的生存周期全局变量的生存周期是永久的，除非我们主动的销毁这个全局变量。而对于局部变量来说，当退出函数时，这些局部变量就失去了生存的环境，所以会随着函数调用的结束而被销毁。那么是否可以让局部变量在函数调用结束的时候不被销毁呢？来看下面这个例子： 1234567891011var func = function() &#123; var a = 1; return function() &#123; a++; console.log( a ); &#125; &#125;;var f = func();f(); // 2f(); // 3f(); // 4 从上面这个输出结果，我们可以看到局部变量a并没有随着f()的调用而被销毁。这是因为全局变量f保存着对func里面匿名函数的引用。而这个匿名函数是可以访问到局部变量a的，所以自然a也被保存下来了。所以这种情况下局部变量的生存周期就得以延续。上面这个匿名函数其实就是一个闭包。再来看一个闭包的经典应用。 1234567// 假设有5个divvar nodes = document.getElementsByTagName( 'div' );for ( var i = 0, l = nodes.length; i &lt; l; i++ ) &#123; nodes[i].onclick = function() &#123; console.log( i ); &#125;&#125; 当真正执行这段代码的时候，发现无论点击那个div，最后打印的结果都是4。这是因为onclick事件是异步触发的，当事件触发的时候，for循环早已经结束，此时变量i的值已经是4。解决方案可以是用闭包把每次的i都保存起来： 1234567for ( var i = 0, l = nodes.length; i &lt; l; i++ ) &#123; (function( i ) &#123; nodes[i].onclick = function() &#123; console.log( i ); &#125; &#125;)( i );&#125; 同理，我们编写一段代码用来判断对象类型： 12345678910var Type = &#123;&#125;;for ( var i = 0, type; type = [ 'String', 'Array', 'Number' ][ i++ ]; ) &#123; (function( type ) &#123; Type[ 'is' + type ] = function( obj ) &#123; return Object.prototype.toString.call( obj ) === '[object ' + type + ']'; &#125; &#125;)( type );&#125;Type.isArray( [] ); // trueType.isString( 'str' ); // true 什么是闭包官方的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因为这些变量也是该表达式的一部分。这个概念不好理解，我们可以简单得理解成闭包就是能够访问函数内部变量的函数。 闭包的作用 可以在函数外部访问在函数内部定义的局部变量 延续局部变量的生存周期 封装变量闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。假设有一个计算乘积的函数： 12345678var mult = function() &#123; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return a;&#125;;mult(2, 3, 4); // 24 mult函数接受一些Number类型的参数，并且返回他们的乘积。现再我们觉得对于那些相同参数来说，每次再进行计算是一种浪费，所以我们决定加入缓存机制来提高函数性能： 123456789101112var cache = &#123;&#125;;var mult = function() &#123; var args = Array.prototype.join.call( arguments, '' ); if ( cache[ args ] ) &#123; return cache[ args ]; &#125; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return cache[ args ] = a;&#125;; 我们看到cache这个变量仅仅在mult函数中被使用，所以为了避免cache污染全局变量，我们将它放到mult函数里面 1234567891011121314var mult = (function() &#123; var cache = &#123;&#125;; return function() &#123; var args = Array.prototype.join.call( arguments, '' ); if ( cache[ args ] ) &#123; return cache[ args ]; &#125; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return cache[ args ] = a; &#125;&#125;)(); 提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有利于代码的复用，如果这些小函数有一个良好的命名，那么它们本身就起到了一个很好的注释作用。 1234567891011121314151617var mult = (function() &#123; var cache = &#123;&#125;; var calculate = function() &#123; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return a; &#125;; return function() &#123; var args = Array.prototype.join.call( arguments, '' ); if ( cache[ args ] ) &#123; return cache[ args ]; &#125; return cache[ args ] = calculate.apply( null, arguments ); &#125;&#125;)(); 闭包与内存管理局部变量本来应该在函数退出的时候就被结束引用，但如果局部变量被封装在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上来看，闭包确实会使一些数据无法被及时销毁。如果将来需要回收这些变量，我们可以手动把这些变量设为null。跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域中保存着一些DOM节点，这个时候就有可能造成内存泄露。在IE9之前的浏览器中，由于BOM和DOM中的对象是使用C++对象以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是引用计数策略。在基于引用计数的垃圾收集机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。但我们只要把循环引用中的对象设为null即可解决这个问题。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://zc95.github.io/tags/正则表达式/"},{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"}]},{"title":"正则表达式","slug":"RegularExpression","date":"2017-12-20T10:48:26.000Z","updated":"2017-12-21T12:41:12.998Z","comments":true,"path":"2017/12/20/RegularExpression/","link":"","permalink":"http://zc95.github.io/2017/12/20/RegularExpression/","excerpt":"PART 1-为什么使用正则表达式？ 测试字符串内的模式 例如，可以测试输入字符串，以查看字符串内是否出现电话号码或信用卡号码模式。这称为数据验证 替换文本 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它 基于模式匹配从字符串中提取子字符串 可以查找文档内或输入域内特定的文本","text":"PART 1-为什么使用正则表达式？ 测试字符串内的模式 例如，可以测试输入字符串，以查看字符串内是否出现电话号码或信用卡号码模式。这称为数据验证 替换文本 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它 基于模式匹配从字符串中提取子字符串 可以查找文档内或输入域内特定的文本 PART 2-练习正则表达式我们可以在console控制台，regexper 或者 IDE 去练习正则表达式 推荐一个JS正则可视化的在线工具，简单易懂：regexper.com 现在大部分IDE都会支持正则表达式匹配，如sublime： PART 3-举个🌰实例 ^[0-9]+abc$ ^ 为匹配输入字符串的开始位置 [0-9]+ 匹配单个数字，+ 匹配一个或者多个 abc$ 匹配字母 abc 结尾 $ 为匹配输入字符串的结束位置 匹配以数字开头，并以abc结尾的字符串： 12345var str = \"123abc\";var patt1 = /^[0-9]+abc$/;document.write(str.match(patt1));==&gt; 123ABC PART 4-基本正则字符基础字符含义MDN Regular Expressions 字符 描述 \\ 转意，即通常在”\\”后面的字符不按原来意义解释，如/b/匹配字符”b”，当b前面加了反斜杠后/\\b/，转意为匹配一个单词的边界。 ^ 匹配输入的开始 例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。 当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。补充字符集合一节有详细介绍和示例。 $ 匹配输入的结束。 例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。 * 匹配前面元字符0次或多次，/ba*/ 将匹配b,ba,baa,baaa ，相当于{0, } 例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西。 + 匹配前面元字符1次或多次，/ba+/将匹配ba,baa,baaa，相当于{1, } 例如，/a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。 ? 匹配前面元字符0次或1次，相当于 {0,1} 例如，/e?le?/ 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’ 如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。 例如，对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。 还可以运用于先行断言，如本表的 x(?=y) 和 x(?!y) 条目中所述。 . 匹配除换行符之外的任何单个字符 例如，/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。 x&#124;y 匹配x或y {n} 精确匹配n次 {n,} 匹配n次以上 {n,m} 匹配n-m次 [^xyz ] 字符集(character set)，匹配这个集合中的任一一个字符(或元字符) [\\b] 匹配一个退格符 \\b 匹配一个单词的边界 \\B 匹配一个非单词边界 \\cX 这儿，X是一个控制符，/\\cM/匹配Ctrl-M \\d 匹配一个数字，/\\d/ = /[0-9]/ \\D 匹配一个非字数字符，/\\D/ = /[ ^0-9]/ \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\s 匹配一个空白字符，包括\\n,\\r,\\f,\\t,\\v等 \\S 匹配一个非空白字符，等于 /[ ^\\n\\f\\r\\t\\v]/ \\t 匹配一个制表符 \\v 匹配一个重直制表符 \\w 匹配字母或数字或下划线，等于[a-zA-Z_0-9] ( 能不能匹配汉字要视你的操作系统和你的应用环境而定 \\W 匹配一个不可以组成单词的字符，如[\\W]匹配”5.98”中的，等于 [ ^a-zA-Z0-9] PART 5-使用正则表达式正则表达式可以被用于RegExp的exec和test方法以及 String的match、replace、search和split方法。这些方法在JavaScript 手册中有详细的解释。 方法 描述 exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。 test 一个在字符串中测试是否匹配的RegExp方法，它返回true或false。 match 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。 search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://zc95.github.io/tags/正则表达式/"}]},{"title":"loading加载等待框","slug":"loading","date":"2017-11-30T11:07:04.000Z","updated":"2017-12-21T12:08:52.817Z","comments":true,"path":"2017/11/30/loading/","link":"","permalink":"http://zc95.github.io/2017/11/30/loading/","excerpt":"链接 demo地址 github地址","text":"链接 demo地址 github地址 调用 LoadShow(); LoadHide(); 主要代码JS1234567891011function LoadShow() &#123; if ($(\"#loading_wrapper\").length &gt; 0) &#123; return false; &#125; var str = \"&lt;div id='loading_wrapper' class='loaders_wrapper'&gt;&lt;div class='loader'&gt;&lt;div class='loader-inner ball-spin-fade-loader'&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\"; $(\"body\").append(str); $(\"#loading_wrapper\").show();&#125;function LoadHide() &#123; $(\"#loading_wrapper\").hide().remove();&#125; CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/*在线预览等待框*/.loaders_wrapper &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; filter: alpha(opacity=50); opacity: 0.4; color: #fff; font-size: 14px; font-family: 'Source Sans Pro'; display: none; z-index: 99999;&#125;.loaders_wrapper .loader &#123; max-width: 70px; height: 70px; position: absolute; left: 50%; top: 50%; margin-left: -35px; margin-top: -35px;&#125;@-webkit-keyframes ball-spin-fade-loader &#123; 50% &#123; opacity: 0.3; -webkit-transform: scale(0.4); transform: scale(0.4); &#125; 100% &#123; opacity: 1; -webkit-transform: scale(1); transform: scale(1); &#125;&#125;@keyframes ball-spin-fade-loader &#123; 50% &#123; opacity: 0.3; -webkit-transform: scale(0.4); transform: scale(0.4); &#125; 100% &#123; opacity: 1; -webkit-transform: scale(1); transform: scale(1); &#125;&#125;.ball-spin-fade-loader &#123; position: relative;&#125;.ball-spin-fade-loader &gt; div:nth-child(1) &#123; top: 25px; left: 0; -webkit-animation: ball-spin-fade-loader 1s 0s infinite linear; animation: ball-spin-fade-loader 1s 0s infinite linear;&#125;.ball-spin-fade-loader &gt; div:nth-child(2) &#123; top: 17.04545px; left: 17.04545px; -webkit-animation: ball-spin-fade-loader 1s 0.12s infinite linear; animation: ball-spin-fade-loader 1s 0.12s infinite linear;&#125;.ball-spin-fade-loader &gt; div:nth-child(3) &#123; top: 0; left: 25px; -webkit-animation: ball-spin-fade-loader 1s 0.24s infinite linear; animation: ball-spin-fade-loader 1s 0.24s infinite linear;&#125;.ball-spin-fade-loader &gt; div:nth-child(4) &#123; top: -17.04545px; left: 17.04545px; -webkit-animation: ball-spin-fade-loader 1s 0.36s infinite linear; animation: ball-spin-fade-loader 1s 0.36s infinite linear;&#125;.ball-spin-fade-loader &gt; div:nth-child(5) &#123; top: -25px; left: 0; -webkit-animation: ball-spin-fade-loader 1s 0.48s infinite linear; animation: ball-spin-fade-loader 1s 0.48s infinite linear;&#125;.ball-spin-fade-loader &gt; div:nth-child(6) &#123; top: -17.04545px; left: -17.04545px; -webkit-animation: ball-spin-fade-loader 1s 0.6s infinite linear; animation: ball-spin-fade-loader 1s 0.6s infinite linear;&#125;.ball-spin-fade-loader &gt; div:nth-child(7) &#123; top: 0; left: -25px; -webkit-animation: ball-spin-fade-loader 1s 0.72s infinite linear; animation: ball-spin-fade-loader 1s 0.72s infinite linear;&#125;.ball-spin-fade-loader &gt; div:nth-child(8) &#123; top: 17.04545px; left: -17.04545px; -webkit-animation: ball-spin-fade-loader 1s 0.84s infinite linear; animation: ball-spin-fade-loader 1s 0.84s infinite linear;&#125;.ball-spin-fade-loader &gt; div &#123; background-color: #fff; width: 15px; height: 15px; border-radius: 100%!important; margin: 2px; -webkit-animation-fill-mode: both; animation-fill-mode: both; position: absolute;&#125;/*在线预览等待框*/","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"用最简单的代码实现点击查看大图","slug":"enlargeImg","date":"2017-11-29T13:03:34.000Z","updated":"2017-12-21T12:42:50.170Z","comments":true,"path":"2017/11/29/enlargeImg/","link":"","permalink":"http://zc95.github.io/2017/11/29/enlargeImg/","excerpt":"今天做了个点击查看大图的功能，只需要给img加一个class，不用写额外的html代码 链接 demo地址 github地址","text":"今天做了个点击查看大图的功能，只需要给img加一个class，不用写额外的html代码 链接 demo地址 github地址 核心代码 html部分12&lt;img class=\"enlargeImg\" width=\"80\" src=\"https://zc95.github.io/img/avatar.png\"title=\"点击查看大图\" /&gt; 重点： img标签 class=”enlargeImg” 限制图片宽度或高度为”小图片”，width=”80” src有值 title=”点击查看大图” css部分12345678910111213141516171819.enlargeImg_wrapper &#123; display: none; position: fixed; z-index: 999; top: 0; right: 0; bottom: 0; left: 0; background-repeat: no-repeat; background-attachment: fixed; background-position: center; background-color: rgba(52, 52, 52, 0.8); background-size: 50%;&#125;img:hover,.enlargeImg_wrapper:hover &#123; cursor: pointer;&#125; 重点： 半透明遮罩层 background-color: rgba(52, 52, 52, 0.8); 水平垂直居中 background-position: center; 放大后的图片大小 background-size: 50%; 如果受页面中别的定位元素的z-index影响，改z-index的值就行 js部分12345678910111213141516$(function() &#123; enlargeImg();&#125;)//查看大图function enlargeImg() &#123; $(\".enlargeImg\").click(function() &#123; $(this).after(\"&lt;div onclick='closeImg()' class='enlargeImg_wrapper'&gt;&lt;/div&gt;\"); var imgSrc = $(this).attr('src'); $(\".enlargeImg_wrapper\").css(\"background-image\", \"url(\" + imgSrc + \")\"); $('.enlargeImg_wrapper').fadeIn(200); &#125;)&#125;//关闭并移除图层function closeImg() &#123; $('.enlargeImg_wrapper').fadeOut(200).remove();&#125; 重点： 点击class为 enlargeImg 的图片时获取它的路径，var imgSrc = $(this).attr(‘src’); 创建遮罩层，$(this).after(““); 赋值给 enlargeImg_wrapper ，$(“.enlargeImg_wrapper”).css(“background-image”, “url(“ + imgSrc + “)”); 关闭遮罩层时移除遮罩层，$(‘.enlargeImg_wrapper’).fadeOut(200).remove();","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"更改hosts文件来更好地使用github","slug":"hostsChange","date":"2017-11-28T15:49:00.000Z","updated":"2017-12-21T12:12:16.566Z","comments":true,"path":"2017/11/28/hostsChange/","link":"","permalink":"http://zc95.github.io/2017/11/28/hostsChange/","excerpt":"最近可能是网不太好，hexo d的时候总是提交不了，很苦恼，试了n多种方法。。。 hexo d时报错1234fatal: unable to access'https://github.com/zc95/zc95.github.io.git/ ': Could notresolve host: github.comFATAL Something's wrong.Maybe you can find the solution here:http:hexo.io/docs/troubleshooting.html... 命令行终端 ping github.com打开命令行终端，输入 ping github.com 并回车 ping github.com","text":"最近可能是网不太好，hexo d的时候总是提交不了，很苦恼，试了n多种方法。。。 hexo d时报错1234fatal: unable to access'https://github.com/zc95/zc95.github.io.git/ ': Could notresolve host: github.comFATAL Something's wrong.Maybe you can find the solution here:http:hexo.io/docs/troubleshooting.html... 命令行终端 ping github.com打开命令行终端，输入 ping github.com 并回车 ping github.com 如果像下面这样ping不出，就继续往下看吧 12345678910ping github.comPING github.com (192.30.255.113): 56 data bytesRequest timeoutRequest timeout for icmp_seq 0Request timeout for icmp_seq 1Request timeout for icmp_seq 2Request timeout for icmp_seq 3Request timeout for icmp_seq 4Request timeout for icmp_seq 5... Ping github.com 打开链接 http://ping.chinaz.com 输入 github.com ,点击Ping检测 选择一条TTL值最小的ip地址，例如：192.30.255.113 修改hosts 点击Finder - 前往 - 前往文件夹… - 输入 /etc/hosts 点击前往 找到hosts文件，修改hosts文件需要管理员权限，所以不能单纯修改，先按住hosts文件拖到桌面，双击打开桌面上的hosts文件 在 127.0.0.1 localhost 下面另起一行输入 192.30.255.113 github.com ，保存并退出 将桌面的hosts文件拖回直原来的位置，他会提示你 修改”etc”需要管理员密码 ，点击”鉴定”，会提示你是否覆盖原文件，点击”是”，输入密码或指纹，ok了 再次在命令行终端 ping github.com 就能看到ping成功了 可以愉快的deploy了 FAQ什么是hosts？ Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 每次改完配置需要重启机器吗？ 不需要，它实质上是个文本文件，当计算机需要解析地址时，会首先检查此文件，读取后再确定是本地解析还是要发送到DNS服务器来解析。改后，只要再上网，就会生效。 hosts文件在哪里?1234Linux:/etc/hostsMac OS X:/etc/hostsAndroid:/etc/hostsWindows:C:/windows/System32/drivers/etc/hosts hosts文件规则?12345#ip地址 域名127.0.0.1 localhost192.30.255.113 github.com255.255.255.255 broadcasthost::1 localhost","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"github","slug":"github","permalink":"http://zc95.github.io/tags/github/"},{"name":"hosts","slug":"hosts","permalink":"http://zc95.github.io/tags/hosts/"}]},{"title":"关于float清除浮动和inline-block出现空隙的问题","slug":"floatAndInlineBlock","date":"2017-11-26T15:21:45.000Z","updated":"2018-01-10T13:27:57.923Z","comments":true,"path":"2017/11/26/floatAndInlineBlock/","link":"","permalink":"http://zc95.github.io/2017/11/26/floatAndInlineBlock/","excerpt":"最近在写项目的时候手写了一个简单选项卡，遇到这类布局，最常见、最快速的布局方式就是display:inline-block;和float:left; 但我们都知道 display:inline-block 布局会出现空隙的问题，float:left 又要清除浮动，本文就这两个问题整理出解决方案。","text":"最近在写项目的时候手写了一个简单选项卡，遇到这类布局，最常见、最快速的布局方式就是display:inline-block;和float:left; 但我们都知道 display:inline-block 布局会出现空隙的问题，float:left 又要清除浮动，本文就这两个问题整理出解决方案。 display:inline-block去掉空隙移除标签间的空格123&lt;ul class=\"tab-wrapper\"&gt; &lt;li class=\"tab-item active\"&gt;项目一&lt;/li&gt;&lt;li class=\"tab-item\"&gt;项目二&lt;/li&gt;&lt;li class=\"tab-item\"&gt;项目三&lt;/li&gt;&lt;li class=\"tab-item\"&gt;项目四&lt;/li&gt;&lt;/ul&gt; 这个方法是我最初学html时知道的方法，当时觉得挺方便的，现在工作了觉得这个方法好蠢😂，一个代码格式化就能毁了它，这样不易维护的代码太脆弱了； 去掉闭合标签123456&lt;ul class=\"tab-wrapper\"&gt; &lt;li class=\"tab-item active\"&gt;项目一 &lt;li class=\"tab-item\"&gt;项目二 &lt;li class=\"tab-item\"&gt;项目三 &lt;li class=\"tab-item\"&gt;项目四&lt;/ul&gt; 这个方法算是种好方法，最后一个li的闭合标签可有可无，也能很好的解决空隙问题，但依然还是代码不易维护的问题。 font-size:0;123456&lt;ul class=\"tab-wrapper\"&gt; &lt;li class=\"tab-item active\"&gt;项目一&lt;/li&gt; &lt;li class=\"tab-item\"&gt;项目二&lt;/li&gt; &lt;li class=\"tab-item\"&gt;项目三&lt;/li&gt; &lt;li class=\"tab-item\"&gt;项目四&lt;/li&gt;&lt;/ul&gt; 123456789.tab-wrapper&#123; font-size:0; /*父容器font-size为0*/ -webkit-text-size-adjust:none; /*Chrome有最小字体大小限制，考虑到兼容性需要取消字体大小限制*/&#125;.tab-wrapper .tab-item&#123; display:inline-block; font-size:13px; /*这里比较重要，因为子元素会继承父元素的字体大小，这里要恢复正常font-size*/ padding:5px 12px;&#125; 这个方法方法好理解，比较主流的解决方案； float 清除浮动空标签 123456&lt;div class=\"box-wrapper\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div style=\"clear:both;\"&gt;&lt;/div&gt;&lt;/div&gt; 最佳方法1234567891011121314/* 全浏览器通用的clearfix方案【推荐 *//* 引入了zoom以支持IE6/7 *//* 同时加入:before以解决现代浏览器上边距折叠的问题 */.clearfix:before,.clearfix:after &#123; display: table; content: \" \";&#125;.clearfix:after &#123; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"基于 GitHub Issues 的评论系统：gitment","slug":"gitment","date":"2017-11-23T15:47:12.000Z","updated":"2017-12-21T12:43:24.821Z","comments":true,"path":"2017/11/23/gitment/","link":"","permalink":"http://zc95.github.io/2017/11/23/gitment/","excerpt":"如何为hexo博客添加评论功能多说、友言、Disqus、livere(来比力)、gitment、畅言、valine基本都可以实现，但有些已经关闭，有些需要翻墙 本文讲的是一款基于 GitHub Issues 的评论系统：gitment 。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown语法 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。","text":"如何为hexo博客添加评论功能多说、友言、Disqus、livere(来比力)、gitment、畅言、valine基本都可以实现，但有些已经关闭，有些需要翻墙 本文讲的是一款基于 GitHub Issues 的评论系统：gitment 。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown语法 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 gitmentPC端 移动端 基础配置打开博客主题文件夹下的 _config.yml 文件，以我的为例： 12345678comment: type: gitment # 启用哪种评论系统 gitment: githubID: zc95 # 你的GitHub名称 repo: zc95.github.io # 你的GitHub名称.github.io ClientID: ********* ClientSecret: ********* lazy: false # 这个我也不清楚 大概是懒加载的意思吧 githubID 和 repo 都有了，就剩 ClientID 和 ClientSecret 了 注册OAuth Application通过地址OAuth Application注册传送门申请配置，注册一个新的 OAuth Application，其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://zc95.github.io） 获取ClientID与ClientSecret 总结 优点 界面​简洁 与github绑定，方便注册，不用依赖脚本或插件 评论会出现在github项目中的Issues里，方便管理 支持Markdown全部语法和html标签（这个很厉害） 缺点 ​每篇文章都需要手动点击initialize comments按钮来初始化评论，否则不能评论； 不支持图片（可以尝试用markdown或者img标签来实现）和表情（emoji可以用） 只能支持github登陆 最后更新最后还是选择了livere 来必力，注册登陆需要翻墙（或许因为我网不好。。），一旦注册之后评论之类的就不需翻墙了，支持QQ、微信、微博、百度等登陆方式，本页拉到最底下就是来必力了，体验还是可以的。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://zc95.github.io/tags/Hexo/"},{"name":"gitment","slug":"gitment","permalink":"http://zc95.github.io/tags/gitment/"},{"name":"Issues","slug":"Issues","permalink":"http://zc95.github.io/tags/Issues/"}]},{"title":"我的收藏","slug":"Collection","date":"2017-11-21T11:30:45.000Z","updated":"2017-12-21T12:13:56.048Z","comments":true,"path":"2017/11/21/Collection/","link":"","permalink":"http://zc95.github.io/2017/11/21/Collection/","excerpt":"我的博客https://zc95.github.io工具jsrun在线代码编辑tinypng压缩图片Google翻译msdn.itellyouMDN文档","text":"我的博客https://zc95.github.io工具jsrun在线代码编辑tinypng压缩图片Google翻译msdn.itellyouMDN文档 前端插件&amp;框架echartslayui阿里巴巴矢量图标图学习网站freecodecamp慕课网前端菜鸟教程","categories":[{"name":"汇总篇","slug":"汇总篇","permalink":"http://zc95.github.io/categories/汇总篇/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"http://zc95.github.io/tags/收藏/"},{"name":"前端必备","slug":"前端必备","permalink":"http://zc95.github.io/tags/前端必备/"}]},{"title":"数组复习","slug":"arrayReview","date":"2017-11-21T10:44:45.000Z","updated":"2017-12-21T12:14:17.731Z","comments":true,"path":"2017/11/21/arrayReview/","link":"","permalink":"http://zc95.github.io/2017/11/21/arrayReview/","excerpt":"检测数组typeof12var ary = [1,23,4];console.log(typeof ary); //输出结果是Object instanceof12var ary = [1,23,4];console.log(ary instanceof Array)//true;","text":"检测数组typeof12var ary = [1,23,4];console.log(typeof ary); //输出结果是Object instanceof12var ary = [1,23,4];console.log(ary instanceof Array)//true; 原型链方法123var ary = [1,23,4];console.log(ary.__proto__.constructor==Array);//trueconsole.log(ary.constructor==Array)//true 这两段代码是一样的 以上三种方法都不太好，instanceof 和 constructor 判断的变量，必须在当前页面声明的，比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个arr，并将其赋值给父页面的一个变量，这时判断该变量，Array == object.constructor;会返回false； 正确方法12345var ary = [1,2,3,4];function isArray(e)&#123;return Object.prototype.toString.call(e)=='[object Array]';&#125;console.log(isArray(ary)); 自己封装的基本数据类型验证123456789101112131415161718192021222324252627282930var type = &#123; isObj: function(o) &#123; return Object.prototype.toString.call(o) == \"[object Object]\"; &#125;, isArray: function(o) &#123; return Object.prototype.toString.call(o) == \"[object Array]\"; &#125;, isNull: function(o) &#123; return Object.prototype.toString.call(o) == \"[object Null]\"; &#125;, isUndefined: function(o) &#123; return Object.prototype.toString.call(o) == \"[object Undefined]\"; &#125;, isBoolean: function(o) &#123; return Object.prototype.toString.call(o) == \"[object Boolean]\"; &#125;, isString: function(o) &#123; return Object.prototype.toString.call(o) == \"[object String]\"; &#125;, isNumber: function(o) &#123; return Object.prototype.toString.call(o) == \"[object Number]\"; &#125;, isDocument: function() &#123; return Object.prototype.toString.call(o) == \"[object Document]\" || \"[object HTMLDocument]\"; &#125;&#125;------------------------------&gt;console.log(type.isArray([1,2,3]));&gt;true push()和pop() push() 向数组末尾添加任意个项并返回新数组的长度 pop() 从数组末尾移除最后一项，减少数组的length值 （返回的是移除的项） shift()和unshift() unshift() 向数组前端添加任意个项并返回新数组的长度 shift() 从数组前端移除第一项，减少数组的length值 （返回的是移除的项） 重排序 sort() reverse()12345function compare(a,b)&#123; return a-b;//升序 //return b-a; 或者在升序方法之后使用reverse()反转数组&#125;arr.sort(compare); 操作方法 concat() slice() splice()concat()concat() 方法用于连接两个或多个数组，不会改变原始数组。 slice()slice() 方法可从已有的数组中返回选定的元素，不会改变原始数组。 arrayObject.slice(start,end) 参数 描述 start 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 splice()splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目，会改变原始数组。 arrayObject.splice(index,howmany,item1,…..,itemX) 参数 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX 可选。向数组添加的新项目。 位置方法indexOf() indexOF() 从前往后查找，返回首次出现的位置（没有返回-1） lastindexOf() lastindexOf() 从后往前查找，返回首次出现的位置（没有返回-1） 迭代方法 迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。 every(): 对数组中的每一项运行给定的函数，如果该函数对每一项都返回true，则结果返回true。 filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 forEach(): 对数组中的每一项运行给定函数，这个方法没有返回值。 map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some(): 对数组中的每一项运行给定函数，如果该函数任意一项返回true，则返回true。 every()和some()123456789var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var everyResult = numbers.every(function(item, index, array) &#123; return (item &gt; 2);&#125;);var someResult = numbers.some(function(item) &#123; return (item &gt; 2);&#125;);console.log(everyResult); //falseconsole.log(someResult); //true filter()123456var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var filterResult = numbers.filter(function(item) &#123; return (item &gt; 2);&#125;);console.log(filterResult); \\\\[3, 4, 5, 4, 3] map()123456var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var mapResult = numbers.map(function(item) &#123; return (item * 2);&#125;);console.log(mapResult); //[2, 4, 6, 8, 10, 8, 6, 4, 2] forEach()1234var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.forEach(function(item, index, arr) &#123; //这里执行一些操作&#125;);","categories":[{"name":"汇总篇","slug":"汇总篇","permalink":"http://zc95.github.io/categories/汇总篇/"}],"tags":[{"name":"array","slug":"array","permalink":"http://zc95.github.io/tags/array/"}]},{"title":"自定义range滑块","slug":"rangeUI","date":"2017-11-17T11:06:48.000Z","updated":"2017-12-21T12:14:34.300Z","comments":true,"path":"2017/11/17/rangeUI/","link":"","permalink":"http://zc95.github.io/2017/11/17/rangeUI/","excerpt":"Range 链接 demo地址 github地址 简易版demo地址","text":"Range 链接 demo地址 github地址 简易版demo地址 导入CSS和JS（github地址里有）https://github.com/zc95/RangeSlider/blob/master/myCSS.css 12345678910111213141516171819202122232425262728293031323334353637383940p &#123; font-family: \"微软雅黑\"; letter-spacing: -1px; text-shadow: -2px -1px 1px #fff, 1px 2px 2px rgba(0, 0, 0, 0.2); font-weight: 300; font-size: 36px; margin: 10px;&#125;input[type=range] &#123;true-webkit-appearance: none;truewidth: 300px;trueborder-radius: 10px; /*这个属性设置使填充进度条时的图形为圆角*/truebackground: -webkit-linear-gradient(#2EB969, #2EB969) no-repeat;/*进度条的颜色*/truebackground-size: 0% 100%;&#125;input[type=range]:focus &#123;trueoutline: none;&#125;input[type=range]:hover &#123;truecursor:pointer;&#125;input[type=range]::-webkit-slider-runnable-track &#123;trueheight: 6px;trueborder-radius: 10px; /*将轨道设为圆角的*/ box-shadow: 0.2px 0.2px 1px 0.8px #cec8c8 inset; /*添加底部阴影*/&#125;input[type=range]::-webkit-slider-thumb &#123;true-webkit-appearance: none; cursor: pointer; height: 20px; width: 20px; margin-top:-6px; border-radius: 50%; background-color:white; box-shadow: 0px 0px 3px 1px #DEDEDE;&#125; ​ https://github.com/zc95/RangeSlider/blob/master/myJS.js 12345678910111213141516171819202122232425262728293031323334353637383940414243$.fn.RangeSlider = function(cfg)&#123; var userAgent = navigator.userAgent; var isWebkit = (userAgent.indexOf(\"AppleWebKit\") &gt;= 0); var isIE = isIE(); function isIE() &#123; var isIE = false; if (window.ActiveXObject || \"ActiveXObject\" in window) &#123; isIE = true; &#125; else &#123; isIE = (userAgent.indexOf(\"compatible\") &gt; -1 &amp;&amp; userAgent.indexOf(\"MSIE\") &gt; -1 &amp;&amp; !(userAgent.indexOf(\"Opera\") &gt; -1)); isIE = false; &#125; return isIE; &#125; this.sliderCfg = &#123; min: cfg &amp;&amp; !isNaN(parseFloat(cfg.min)) ? Number(cfg.min) : null, max: cfg &amp;&amp; !isNaN(parseFloat(cfg.max)) ? Number(cfg.max) : null, step: cfg &amp;&amp; Number(cfg.step) ? cfg.step : 1, callback: cfg &amp;&amp; cfg.callback ? cfg.callback : null &#125;; var $input = $(this); var min = this.sliderCfg.min; var max = this.sliderCfg.max; var step = this.sliderCfg.step; var callback = this.sliderCfg.callback; $input.attr('min', min).attr('max', max).attr('step', step); var event = null; if (isIE) &#123; event = \"change\"; &#125; else &#123; event = \"input\"; &#125; $input.bind(event, function(e)&#123; $input.attr('value', this.value); if (isWebkit) &#123; $input.css( 'background-size', this.value + '% 100%' ); &#125; if ($.isFunction(callback)) &#123; callback(this); &#125; &#125;);&#125;; ​ 使用1234&lt;p&gt; 进度条&amp;emsp;&lt;span id=\"num\"&gt;0&lt;/span&gt;%&lt;/p&gt;&lt;input type=\"range\" value=\"0\"&gt; 12345678910$(function() &#123; $('input').RangeSlider(&#123; step: 0.1, callback: change &#125;);&#125;);var change = function($input) &#123; /*内容可自行定义*/ $(\"#num\").text($('input').val());&#125;","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"column","slug":"column","date":"2017-11-10T16:30:14.000Z","updated":"2017-12-21T12:15:00.202Z","comments":true,"path":"2017/11/11/column/","link":"","permalink":"http://zc95.github.io/2017/11/11/column/","excerpt":"CSS3多列CSS3 可以将文本内容设计成像报纸一样的多列布局，如下实例： CSS3 多列属性 column-count column-gap column-rule-style column-rule-width column-rule-color column-rule column-span column-width","text":"CSS3多列CSS3 可以将文本内容设计成像报纸一样的多列布局，如下实例： CSS3 多列属性 column-count column-gap column-rule-style column-rule-width column-rule-color column-rule column-span column-width CSS3 创建多列column-count 属性指定了需要分割的列数 以下实例将 &lt;div&gt; 元素中的文本分为 3 列： 123456.newspaper&#123;true-moz-column-count:3; /* Firefox */true-webkit-column-count:3; /* Safari and Chrome */truecolumn-count:3;&#125; 1&lt;div class=\"newspaper\"&gt;....................&lt;/div&gt; 尝试一下 » CSS3 多列中列与列间的间隙column-gap 属性指定了列与列间的间隙 以下实例指定了列与列间的间隙为 40 像素： 12345678910.newspaper&#123;true-moz-column-count:3; /* Firefox */true-webkit-column-count:3; /* Safari and Chrome */truecolumn-count:3;true-moz-column-gap:40px; /* Firefox */true-webkit-column-gap:40px; /* Safari and Chrome */truecolumn-gap:40px;&#125; 1&lt;div class=\"newspaper\"&gt;....................&lt;/div&gt; 尝试一下 » CSS3 列边框column-rule-style 属性指定了列与列间的边框样式： 123456.newspaper&#123;true-webkit-column-rule-style: solid; /* Chrome, Safari, Opera */ -moz-column-rule-style: solid; /* Firefox */ column-rule-style: solid;&#125; 尝试一下 » column-rule-width 属性指定了两列的边框厚度： 12345div &#123; -webkit-column-rule-width: 1px; /* Chrome, Safari, Opera */ -moz-column-rule-width: 1px; /* Firefox */ column-rule-width: 1px;&#125; 尝试一下 » column-rule-color 属性指定了两列的边框颜色： 12345div &#123; -webkit-column-rule-color: lightblue; /* Chrome, Safari, Opera */ -moz-column-rule-color: lightblue; /* Firefox */ column-rule-color: lightblue;&#125; 尝试一下 » column-rule 属性是 column-rule-* 所有属性的简写。 以下实例设置了列直接的边框的厚度，样式及颜色： 12345div &#123; -webkit-column-rule: 1px solid lightblue; /* Chrome, Safari, Opera */ -moz-column-rule: 1px solid lightblue; /* Firefox */ column-rule: 1px solid lightblue;&#125; 尝试一下 » 指定元素跨越多少列以下实例指定 &lt;h2&gt; 元素跨越所有列： 1234h2 &#123; -webkit-column-span: all; /* Chrome, Safari, Opera */ column-span: all;&#125; 尝试一下 » 指定列的宽度column-width 属性指定了列的宽度。 1234div &#123; -webkit-column-width: 100px; /* Chrome, Safari, Opera */ column-width: 100px;&#125; 尝试一下 » CSS3 多列属性下表列出了所有 CSS3 的多列属性： 属性 描述 column-count 指定元素应该被分割的列数。 column-fill 指定如何填充列 column-gap 指定列与列之间的间隙 column-rule 所有 column-rule-* 属性的简写 column-rule-color 指定两列间边框的颜色 column-rule-style 指定两列间边框的样式 column-rule-width 指定两列间边框的厚度 column-span 指定元素要跨越多少列 column-width 指定列的宽度 columns 设置 column-width 和 column-count 的简写","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"css3","slug":"css3","permalink":"http://zc95.github.io/tags/css3/"},{"name":"布局","slug":"布局","permalink":"http://zc95.github.io/tags/布局/"}]},{"title":"类似Windows文件的布局问题","slug":"AdaptiveLayout","date":"2017-11-03T10:40:24.000Z","updated":"2017-12-21T12:15:20.306Z","comments":true,"path":"2017/11/03/AdaptiveLayout/","link":"","permalink":"http://zc95.github.io/2017/11/03/AdaptiveLayout/","excerpt":"问题如何做到类似windows文件的布局：无论如何改变窗口（屏幕）的大小，文件或者文件夹的大小都是固定的，不同的是一行显示的数目会有所变化； 百分比布局首先这类布局，肯定会先想到百分比的方法（最快的方法），在不同手机上看的话当然没区别，比如一行显示4个的话，那么一个就是25%，但如果放到ipad或者电脑上来看的话，就大的有些恐怖了 百分比加@media布局同上，我们可以用@media的方法来解决不同类型设备的差异问题，也就是多写几行css的问题","text":"问题如何做到类似windows文件的布局：无论如何改变窗口（屏幕）的大小，文件或者文件夹的大小都是固定的，不同的是一行显示的数目会有所变化； 百分比布局首先这类布局，肯定会先想到百分比的方法（最快的方法），在不同手机上看的话当然没区别，比如一行显示4个的话，那么一个就是25%，但如果放到ipad或者电脑上来看的话，就大的有些恐怖了 百分比加@media布局同上，我们可以用@media的方法来解决不同类型设备的差异问题，也就是多写几行css的问题 我的方法var eachWidth = $(document).width() / Math.floor($(document).width() / 80); 假如我想每个div都在80px左右，那么一行就可以放 $(document).width() / 80 个，用 Math.floor 向下取整之后可以去掉不满一个的零头，再用屏幕宽度除以这个取整后的个数，就能得到长度在80±10的eachWidth值了 下面是在控制台的不同手机屏幕大小下console出来的数据： 1234567891011121314$(document).width() / Math.floor($(document).width() / 80) //iPad--&gt; 85.33333333333333$(document).width() / Math.floor($(document).width() / 80) //iPhone 6 Plus--&gt; 82.8$(document).width() / Math.floor($(document).width() / 80) //iPhone 6--&gt; 93.75$(document).width() / Math.floor($(document).width() / 80) //iPhone 5--&gt; 80$(document).width() / Math.floor($(document).width() / 80) //Nexus 6P--&gt; 82.4 效果图 移动端 iPad","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"},{"name":"页面布局","slug":"页面布局","permalink":"http://zc95.github.io/tags/页面布局/"}]},{"title":"原生javascript和jquery的用法对比","slug":"jsAndJq","date":"2017-10-25T04:39:12.000Z","updated":"2017-12-26T13:11:47.795Z","comments":true,"path":"2017/10/25/jsAndJq/","link":"","permalink":"http://zc95.github.io/2017/10/25/jsAndJq/","excerpt":"选取元素12345678910// jQueryvar els = $('.el');// Nativevar els = document.querySelectorAll('.el');// Shorthandvar $ = function (el) &#123; return document.querySelectorAll(el);&#125; querySelectorAll方法返回的是NodeList对象，需要转换为数组。 1myList = Array.prototype.slice.call(myNodeList)","text":"选取元素12345678910// jQueryvar els = $('.el');// Nativevar els = document.querySelectorAll('.el');// Shorthandvar $ = function (el) &#123; return document.querySelectorAll(el);&#125; querySelectorAll方法返回的是NodeList对象，需要转换为数组。 1myList = Array.prototype.slice.call(myNodeList) 创建元素12345// jQueryvar newEl = $('&lt;div&gt;&lt;/div&gt;');// Nativevar newEl = document.createElement('div'); 添加事件1234567891011// jQuery$('.el').on('event', function() &#123;&#125;);// Native[].forEach.call(document.querySelectorAll('.el'), function (el) &#123; el.addEventListener('event', function() &#123; &#125;, false);&#125;); get/set属性1234567// jQuery$('.el').filter(':first').attr('key', 'value');$('.el').filter(':first').attr('key');// Nativedocument.querySelector('.el').setAttribute('key', 'value');document.querySelector('.el').getAttribute('key'); 添加和移除样式ClassDOM元素本身有一个可读写的className属性，可以用来操作class。 HTML 5还提供一个classList对象，功能更强大（IE 9不支持）。 123456789// jQuery$('.el').addClass('class');$('.el').removeClass('class');$('.el').toggleClass('class');// Nativedocument.querySelector('.el').classList.add('class');document.querySelector('.el').classList.remove('class');document.querySelector('.el').classList.toggle('class'); 追加元素尾部追加元素： 12345// jQuery$('.el').append($('&lt;div/&gt;'));// Nativedocument.querySelector('.el').appendChild(document.createElement('div')); 头部追加元素： 123456//jQuery$(‘.el’).prepend('&lt;div&gt;&lt;/div&gt;')//Nativevar parent = document.querySelector('.el');parent.insertBefore(\"&lt;div&gt;&lt;/div&gt;\",parent.childNodes[0]) 克隆元素12345// jQueryvar clonedEl = $('.el').clone();// Nativevar clonedEl = document.querySelector('.el').cloneNode(true); 移除元素123456789101112Remove// jQuery$('.el').remove();// Nativeremove('.el');function remove(el) &#123; var toRemove = document.querySelector(el); toRemove.parentNode.removeChild(toRemove);&#125; 获取父级元素12345// jQuery$('.el').parent();// Nativedocument.querySelector('.el').parentNode; 获取上一个/下一个元素（Prev/next element）1234567// jQuery$('.el').prev();$('.el').next();// Nativedocument.querySelector('.el').previousElementSibling;document.querySelector('.el').nextElementSibling; XHR and AJAX123456789101112131415161718192021222324252627// jQuery$.get('url', function (data) &#123;&#125;);$.post('url', &#123;data: data&#125;, function (data) &#123;&#125;);// Native// getvar xhr = new XMLHttpRequest();xhr.open('GET', url);xhr.onreadystatechange = function (data) &#123;&#125;xhr.send();// postvar xhr = new XMLHttpRequest()xhr.open('POST', url);xhr.onreadystatechange = function (data) &#123;&#125;xhr.send(&#123;data: data&#125;); 清空子元素123456//jQuery$(\"#elementID\").empty()//Nativevar element = document.getElementById(\"elementID\")while(element.firstChild) element.removeChild(element.firstChild); 检查是否有子元素12345//jQueryif (!$(\"#elementID\").is(\":empty\"))&#123;&#125;//Nativeif (document.getElementById(\"elementID\").hasChildNodes())&#123;&#125; $(document).readyDOM加载完成，会触发DOMContentLoaded事件，等同于jQuery的$(document).ready方法。 123document.addEventListener(\"DOMContentLoaded\", function() &#123; // ...&#125;); 数据储存jQuery对象可以储存数据。 12$(\"body\").data(\"foo\", 52);$(\"body\").data(\"foo\"); HTML 5有一个dataset对象，也有类似的功能（IE 10不支持），不过只能保存字符串。 12element.dataset.user = JSON.stringify(user);element.dataset.score = score; 动画jQuery的animate方法，用于生成动画效果。 1$foo.animate('slow', &#123; x: '+=10px' &#125;) jQuery的动画效果，很大部分基于DOM。但是目前，CSS 3的动画远比DOM强大，所以可以把动画效果写进CSS，然后通过操作DOM元素的class，来展示动画。 1foo.classList.add('animate') 如果需要对动画使用回调函数，CSS 3也定义了相应的事件。 12el.addEventListener(\"webkitTransitionEnd\", transitionEnded);el.addEventListener(\"transitionend\", transitionEnded);","categories":[{"name":"汇总篇","slug":"汇总篇","permalink":"http://zc95.github.io/categories/汇总篇/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://zc95.github.io/tags/jquery/"}]},{"title":"css换行问题","slug":"wordBreak","date":"2017-10-25T04:27:15.000Z","updated":"2017-12-21T12:15:55.326Z","comments":true,"path":"2017/10/25/wordBreak/","link":"","permalink":"http://zc95.github.io/2017/10/25/wordBreak/","excerpt":"css实现强制不换行/自动换行/强制换行 强制换行按单词自动换行 p { word-wrap:break-word; } 强制按英文字母断行 需要将行内元素设置为块级元素 p { word-break:break-all; }","text":"css实现强制不换行/自动换行/强制换行 强制换行按单词自动换行 p { word-wrap:break-word; } 强制按英文字母断行 需要将行内元素设置为块级元素 p { word-break:break-all; } 强制不换行强制不换行 p { white-space:nowrap; } 超出显示省略号 p { white-space:nowrap; text-overflow:ellipsis; overflow:hidden; } 一定要给文字的父容器 如果父容器是行级，一定要转成块级（一定要是 block，设置为 inline-block 无效） white-space: normal pre nowrap pre-wrap pre-line inherit ; white-space 属性设置如何处理元素内的空白 normal 默认。多个空白或者多个换行将被当一个空白或一个换行处理- pre 空白和换行会被浏览器保留。其行为方式类似 HTML 中的 pre 标签- nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止- pre-wrap 保留空白符序列，但是正常地进行换行 - pre-line 合并空白符序列，但是保留换行符- inherit 规定应该从父元素继承 white-space 属性的值word-break: normal break-all keep-all ; word-break 属性用来标明怎么样进行单词内的断句 normal：使用浏览器默认的换行规则- break-all:允许再单词内换行 - keep-all:只能在半角空格或连字符处换行","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"表头固定","slug":"amazingTable","date":"2017-10-23T16:15:16.000Z","updated":"2017-12-21T12:16:19.880Z","comments":true,"path":"2017/10/24/amazingTable/","link":"","permalink":"http://zc95.github.io/2017/10/24/amazingTable/","excerpt":"table的表头固定 ——— 上下滚动表头固定，左右滚动表头跟随滚动 关于表格固定如果数据不是很多，一般都是用两个表格，一个放thead，另一个放tbody，这个没难度就不再赘述了 如果数据很多就要考虑左右滚动的情况了","text":"table的表头固定 ——— 上下滚动表头固定，左右滚动表头跟随滚动 关于表格固定如果数据不是很多，一般都是用两个表格，一个放thead，另一个放tbody，这个没难度就不再赘述了 如果数据很多就要考虑左右滚动的情况了 方法一demo: http://jsrun.net/biiKp/show 同样是两个table，一个放thead，另一个放tbody，用两个div分别包裹起来 这两个div依赖于他们的的父容器进行absolute定位 theadDiv { position: absolute; left: 0; right: 0; overflow: hidden; //这里hidden是用于隐藏滚动条} tbodyDiv { position: absolute; top: 35px; left: 0; right: 0; bottom: 0; overflow: auto;} 给放置thead的div添加样式 overflow: hidden; ，表头不需要看到滚动条 给放置tbody的div添加样式 overflow: auto; ，表的主体需要滚动条 这时只需要在滚动下面的tbody时，同样滚动上面的thead就行 $(‘#tbodyDiv’).on(‘scroll’, function () { $(“#theadDiv”).scrollLeft($(‘#tbodyDiv’).scrollLeft()); }); }) 方法二demo: http://jsrun.net/2iiKp/show 大概思路就是 容器A 下面有 容器1（放置thead） 和 容器2（放置tbody） x轴滚动条属于 容器A ，滚动 容器1（放置thead） 和 容器2（放置tbody） y轴属于 容器2 ，滚动 tbody 这个方法有缺陷，就是y轴的滚动条必须要当x轴滚到最右边才看得到，当然Mac下无差（Mac下的滚动条不滚动的时候是隐藏的，而win系统下就会影响美观，但都不影响操作，毕竟我们有鼠标滚轮）","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"DOM","slug":"DOM","date":"2017-10-21T06:37:42.000Z","updated":"2017-12-21T12:16:39.916Z","comments":true,"path":"2017/10/21/DOM/","link":"","permalink":"http://zc95.github.io/2017/10/21/DOM/","excerpt":"为什么我们要尽量少的去操作DOM结构？ 前言在前端开发的过程中，javascript极为重要的一个功能就是对DOM对象的操作，无论增删改查在前端页面操作这一范围内都是比较消耗性能的。如何高效率的，便捷的操作DOM，这就是本文要讲述的，希望看完全文，你能知道如何更高效的通过原生js以及jQuery操作DOM元素。 性能影响 DOM修改导致的页面重绘repaint、重构reflow，重新排版是用户阻塞的操作，同时，如果频繁重排，CPU使用率也会猛涨 repaint意味着样式的改变比如div调整了背景色等，但是位置不变，只改变我们操作的元素 reflow意味着结构的改变，比如一堆元素堆叠，改变其中一个的宽高，那么相应的所有元素的位置都要改变 所以通常来看repaint的代价要远小于reflow，速度也更快","text":"为什么我们要尽量少的去操作DOM结构？ 前言在前端开发的过程中，javascript极为重要的一个功能就是对DOM对象的操作，无论增删改查在前端页面操作这一范围内都是比较消耗性能的。如何高效率的，便捷的操作DOM，这就是本文要讲述的，希望看完全文，你能知道如何更高效的通过原生js以及jQuery操作DOM元素。 性能影响 DOM修改导致的页面重绘repaint、重构reflow，重新排版是用户阻塞的操作，同时，如果频繁重排，CPU使用率也会猛涨 repaint意味着样式的改变比如div调整了背景色等，但是位置不变，只改变我们操作的元素 reflow意味着结构的改变，比如一堆元素堆叠，改变其中一个的宽高，那么相应的所有元素的位置都要改变 所以通常来看repaint的代价要远小于reflow，速度也更快 如何避免 能放到DOM操作之外的操作就放到外面，DOM操作要尽量少这是一个不好的事例： 12345var $obj = $(\"#obj\");var data = [&#123;\"id\":0,\"name\":\"a\"&#125;,&#123;\"id\":1,\"name\":\"b\"&#125;];for (var i = 0; i &lt; data.length; i++) &#123; $obj.append('&lt;option value=\"'+data[i].id+'\"&gt;'+data[i].name+'&lt;/option&gt;');&#125;; 更好的做法，使用容器存放临时变更，最后再一次性更新DOM： 1234567var $obj = $(\"#obj\");var data = [&#123;\"id\":0,\"name\":\"a\"&#125;,&#123;\"id\":1,\"name\":\"b\"&#125;];var tempStr = \"\";for (var i = 0; i &lt; data.length; i++) &#123; tempStr +=('&lt;option value=\"'+data[i].id+'\"&gt;'+data[i].name+'&lt;/option&gt;');&#125;;$obj.html(tempStr); 大范围操作先把容器隐藏，在其中操作完成后再显示这个也算是优化的一种，这原理涉及到浏览器加载和渲染的原理,简单说就是隐藏的元素其中不会产生reflow 样式操作不要注意修改属性，直接替换class这个还是比较容易理解的，你逐一修改要访问很多次，而替换class就相当于批量操作了，访问一次DOM就可以了,当然性能提高了 总结对于性能方面，平时应注意积累。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"},{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://zc95.github.io/tags/jquery/"},{"name":"DOM操作","slug":"DOM操作","permalink":"http://zc95.github.io/tags/DOM操作/"},{"name":"循环","slug":"循环","permalink":"http://zc95.github.io/tags/循环/"},{"name":"渲染","slug":"渲染","permalink":"http://zc95.github.io/tags/渲染/"},{"name":"性能","slug":"性能","permalink":"http://zc95.github.io/tags/性能/"}]},{"title":"文本框模糊查询","slug":"input","date":"2017-10-21T05:14:08.000Z","updated":"2018-02-12T13:52:49.367Z","comments":true,"path":"2017/10/21/input/","link":"","permalink":"http://zc95.github.io/2017/10/21/input/","excerpt":"文本框模糊匹配(纯html+css+jquery简单实现) ，自己写的一个小组件。 链接 demo地址 github地址 开始使用 引入css、jQuery 和 js（github里面有） 123$('#id').FuzzyQuery(&#123; 'msg': msg &#125;);","text":"文本框模糊匹配(纯html+css+jquery简单实现) ，自己写的一个小组件。 链接 demo地址 github地址 开始使用 引入css、jQuery 和 js（github里面有） 123$('#id').FuzzyQuery(&#123; 'msg': msg &#125;); 参数配置msg 是json数据（必须），fontSize 是模糊查询项的字体大小，height 是模糊查询项的高度12345$('#Name').FuzzyQuery(&#123; 'msg': msg, 'fontSize': '13px', 'height': '30px' &#125;); msg格式示例name 是文本，id 是标识1msg = [&#123; \"name\": \"苏州大学\", \"id\": \"szdx\" &#125;, &#123; \"name\": \"北京大学\", \"id\": \"bjdx\" &#125;, &#123; \"name\": \"南京大学\", \"id\": \"njdx\" &#125;, &#123; \"name\": \"清华大学\", \"id\": \"qhdx\" &#125;, &#123; \"name\": \"复旦大学\", \"id\": \"fddx\" &#125;, &#123; \"name\": \"浙江大学\", \"id\": \"zjdx\" &#125;, &#123; \"name\": \"上海交通大学\", \"id\": \"shjtdx\" &#125;, &#123; \"name\": \"武汉大学\", \"id\": \"whdx\" &#125;, &#123; \"name\": \"中国人民大学\", \"id\": \"zgrmdx\" &#125;, &#123; \"name\": \"中国科学技术大学\", \"id\": \"zgkxjsdx\" &#125;, &#123; \"name\": \"北京师范大学\", \"id\": \"bjsfdx\" &#125;]; html和CSS部分的一些细节 outline: none; outline （轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，为了美观应该去掉 box-sizing:border-box; 这可令浏览器呈现出带有指定宽度和高度的框，并把边框和内边距放入框中。 autocomplete=”off” autocomplete是form表单的属性，默认为on，其含义代表是否让浏览器自动记录之前输入的值，应该关闭记录","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"},{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://zc95.github.io/tags/jquery/"}]},{"title":"在Mac下通过Hexo在Github上搭建博客（入门篇）","slug":"hexoBlog","date":"2017-10-20T13:48:28.000Z","updated":"2017-12-21T12:17:50.595Z","comments":true,"path":"2017/10/20/hexoBlog/","link":"","permalink":"http://zc95.github.io/2017/10/20/hexoBlog/","excerpt":"Hexo 快速，简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。Hexo支持Github Flavored Markdown的所有功能，甚至可以整合Octopress的大多数插件，并自己也拥有强大的插件系统。 Hexo github Node.js Git markdown themes bash命令 npm SSH 什么是Hexo？ Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 Markdown（或其他渲染引擎，之后会解释什么是Markdown）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 前期准备安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js （安装Recommended For Most Users那个版本） Git","text":"Hexo 快速，简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。Hexo支持Github Flavored Markdown的所有功能，甚至可以整合Octopress的大多数插件，并自己也拥有强大的插件系统。 Hexo github Node.js Git markdown themes bash命令 npm SSH 什么是Hexo？ Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 Markdown（或其他渲染引擎，之后会解释什么是Markdown）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 前期准备安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js （安装Recommended For Most Users那个版本） Git 安装Hexo 当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：命令就是你的Launchpad里叫 终端 的app，相当于win的cmd以下出现的$都不是命令的一部分 $ npm install -g hexo-cli全局安装 hexo 模块， 如果下面的操作报错则需要卸载 hexo：$ npm uninstall hexo 再重新安装 hexo：$ sudo npm install -g hexo输入管理员密码（Mac登录密码）即开始安装 创建博客目录初始化, 在指定目录中创建文件目录，以 blog 为例： $ hexo init blog blog是你建立的文件夹名称，cd到blog文件夹下，安装npm： $ cd blog $ npm install 创建一篇新文章以创建博客 firstBlog为例，标题中包含空格需要用引号将标题引起来 $ hexo new firstBlog执行该命令后在source/_posts目录下生成文件 生成博客页面 $ hexo generate执行该命令后会生成public目录 $ hexo sever执行命令后启动服务，访问http://localhost:4000/可查看博客 注意： 之后每次修改完你的博客或者配置内容，都需要用$ hexo sever来开启hexo服务器预览 按 Ctrl+C 停止服务器，以便于进行其他操作 关联Github在进行这一步时你需要一个github账号，到 github官网 用邮箱注册就行，名字尽量简短有意义，我的github地址：https://github.com/zc95 创建仓库登录你的Github帐号，新建仓库，一定要是名为 用户名.github.io 的固定写法（如 zc95.github.io ），我的仓库地址：https://github.com/zc95/zc95.github.io 上传到 github首次使用配置： $ npm install hexo-deplorer-git –save安装 hexo-deplorer-git 打开新建的blog文件夹，找到 _config.yml 配置文件，用记事本打开，Ctrl+F来搜索deploy，type改为git，repository改为你自己的仓库地址，在配置博客站点的_config.yml文件时（包括theme主题站点中的_config.yml），在所有的冒号: 后边都要加一个空格，否则执行hexo命令会报错，切记 切记 deploy:type: gitrepository: 你的仓库地址branch: master ok，可以尽情装逼了。。。 hexo g == hexo generate #生成页面文件 hexo s == hexo server #启动服务预览 hexo d == hexo deploy # 部署到GitHub 常用命令 git clone #克隆主题时用到 cd blog #进入blog文件夹 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g == hexo generate #生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy # 部署 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d #你应该看得懂… 关于作者1234var author = &#123; Name : \"张成\", Blog : \"http://zc95.github.io\"&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://zc95.github.io/tags/Hexo/"},{"name":"github","slug":"github","permalink":"http://zc95.github.io/tags/github/"},{"name":"Node.js","slug":"Node-js","permalink":"http://zc95.github.io/tags/Node-js/"},{"name":"markdown","slug":"markdown","permalink":"http://zc95.github.io/tags/markdown/"},{"name":"npm","slug":"npm","permalink":"http://zc95.github.io/tags/npm/"},{"name":"博客","slug":"博客","permalink":"http://zc95.github.io/tags/博客/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-18T16:10:04.000Z","updated":"2017-12-21T12:18:09.638Z","comments":true,"path":"2017/10/19/hello-world/","link":"","permalink":"http://zc95.github.io/2017/10/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}