{"meta":{"title":"张成的博客","subtitle":null,"description":null,"author":"张成","url":"http://zc95.github.io"},"pages":[{"title":"关于我","date":"2018-02-16T04:22:33.622Z","updated":"2018-02-16T04:22:33.614Z","comments":true,"path":"about/index.html","permalink":"http://zc95.github.io/about/index.html","excerpt":"","text":"姓名：张成 生日：1995/07 坐标：苏州 大学：南京大学 GitHub地址：https://github.com/zc95 邮件：571346800@qq.com QQ: 571346800 var zhangcheng = { \"Name\": \"zhangcheng\", \"Birth\": \"1995/7/3\", \"University\": \"Nanjin university\", \"Location\": \"SIP\", \"Blog\": \"https://zc95.github.io\", \"Github\": \"https://github.com/zc95\", \"QQ\": \"571346800\", \"Mail\": \"571346800@qq.com\", \"Tel\": \"17751435450\" }; console.table(zhangcheng); 关于博客 Hexo官网 博客地址： https://zc95.github.io 我搭建Hexo的过程： https://zc95.github.io/2017/10/20/hexoBlog/ theme： hexo-theme-melody 评论： 用过 gitment 和 livere ，现在关闭评论了 统计数据：不蒜子 内置搜索：hexo-generator-json-content"},{"title":"热门文章","date":"2018-02-10T13:17:54.140Z","updated":"2018-02-10T13:17:40.335Z","comments":true,"path":"topPosts/index.html","permalink":"http://zc95.github.io/topPosts/index.html","excerpt":"","text":"javascript知识碎片 ToDo 待办事宜app 水平垂直居中 一行代码实现星级评分 关于float清除浮动和inline-block出现空隙的问题 VMware服务器虚拟化 用最简单的代码实现点击查看大图 在Mac下通过Hexo在Github上搭建博客（入门篇）"},{"title":"timeline","date":"2018-01-24T14:38:23.427Z","updated":"2017-10-20T16:03:38.000Z","comments":true,"path":"timeline/index.html","permalink":"http://zc95.github.io/timeline/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-24T14:36:58.716Z","updated":"2018-01-24T14:36:58.704Z","comments":true,"path":"tags/index.html","permalink":"http://zc95.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2017-11-30T11:37:25.996Z","updated":"2017-11-30T11:37:25.982Z","comments":true,"path":"links/index.html","permalink":"http://zc95.github.io/links/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-02-10T13:16:30.404Z","updated":"2018-02-10T13:16:30.398Z","comments":true,"path":"categories/index.html","permalink":"http://zc95.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Rich Text Format","slug":"RTF","date":"2018-02-06T15:20:53.000Z","updated":"2018-02-10T12:47:08.084Z","comments":true,"path":"2018/02/06/RTF/","link":"","permalink":"http://zc95.github.io/2018/02/06/RTF/","excerpt":"自己写的一个移动端的富文本编辑器 Link demo github","text":"自己写的一个移动端的富文本编辑器 Link demo github","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"html&css知识碎片","slug":"htmlAndCss","date":"2018-01-25T12:56:30.000Z","updated":"2018-01-25T13:04:49.394Z","comments":true,"path":"2018/01/25/htmlAndCss/","link":"","permalink":"http://zc95.github.io/2018/01/25/htmlAndCss/","excerpt":"记录每天学到的知识点或者遇到的问题 在 github 和 博客 同步更新","text":"记录每天学到的知识点或者遇到的问题 在 github 和 博客 同步更新 input只能输入数字12&lt;input type=\"number\"/&gt;&lt;!-- 这个方法可以输入E和e (原因是e在数学上代表2.71828，所以它也还是一个数字) --&gt; 12&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^\\d]/g,'') \" /&gt;&lt;!-- 输入非数字后被移除 --&gt; 模糊效果（毛玻璃）12345678.blur &#123; filter: url(blur.svg#blur); /* FireFox, Chrome, Opera */ -webkit-filter: blur(10px); /* Chrome, Opera */ -moz-filter: blur(10px); -ms-filter: blur(10px); filter: blur(10px); filter: progid:DXImageTransform.Microsoft.Blur(PixelRadius=10, MakeShadow=false); /* IE6~IE9 */&#125; a标签的一些用法1234&lt;a href=\"javascript:void(alert('Warning!!!'))\"&gt;点我弹窗&lt;/a&gt;&lt;a href=\"javascript:void(0)\"&gt;点我没效果&lt;/a&gt;&lt;a href=\"#pos\"&gt;点我定位到指定位置&lt;/a&gt;&lt;a href=\"#\"&gt;点我定位到顶部&lt;/a&gt; 清除浮动https://zc95.github.io/2017/11/26/floatAndInlineBlock/ 1234567891011121314/* 全浏览器通用的clearfix方案【推荐 *//* 引入了zoom以支持IE6/7 *//* 同时加入:before以解决现代浏览器上边距折叠的问题 */.clearfix:before,.clearfix:after &#123; display: table; content: \" \";&#125;.clearfix:after &#123; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125; inline-block的空隙https://zc95.github.io/2017/11/26/floatAndInlineBlock/ 123456&lt;ul class=\"tab-wrapper\"&gt; &lt;li class=\"tab-item active\"&gt;项目一&lt;/li&gt; &lt;li class=\"tab-item\"&gt;项目二&lt;/li&gt; &lt;li class=\"tab-item\"&gt;项目三&lt;/li&gt; &lt;li class=\"tab-item\"&gt;项目四&lt;/li&gt;&lt;/ul&gt; 123456789.tab-wrapper&#123; font-size:0; /*父容器font-size为0*/ -webkit-text-size-adjust:none; /*Chrome有最小字体大小限制，考虑到兼容性需要取消字体大小限制*/&#125;.tab-wrapper .tab-item&#123; display:inline-block; font-size:13px; /*这里比较重要，因为子元素会继承父元素的字体大小，这里要恢复正常font-size*/ padding:5px 12px;&#125; 阻止页面的表单元素自动联想填满1&lt;form id=\"Content\" autocomplete=\"off\"&gt; 选择器的权重123在写侧边栏点击变色的时候可以选择为li的点击事件加上addClass('active')和removeClass('active'),但是在样式表里你不能直接写.active的样式注意看看之前有没有写过li的样式，比如你点击的这个li上级的class为.side，假如之前写过.side&gt;li&#123; background-color:red; &#125;的样式，点击虽然可以为li加上class，但是.active&#123; background-color:black; &#125;的样式不能体现，这时候这样写就行了.side&gt;.active&#123; background-color:black; &#125;，因为子元素选择器的权重比较高，会覆盖其他单独class的样式 隐藏侧边导航的滚动条1::-webkit-scrollbar&#123;width:0px;&#125; /*隐藏侧边导航的滚动条，只支持webkit内核的浏览器*/ 防止用户选中文字12345678body&#123;-webkit-touch-callout: none;-webkit-user-select: none;-khtml-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;&#125; 阴影和背景渐变色1234阴影：div&#123;box-shadow: 10px 10px 5px #888888;&#125;背景渐变色：background: -webkit-gradient(linear, 0% 0%, 0% 100%, from(white), to(#cdcdcd)); 悬浮放大123456.wrapper img&#123;transition: transform 0.7s ;&#125;.wrapper:hover img&#123;transform: scale(1.08,1.08);&#125; 超出的部分省略号https://zc95.github.io/2017/10/25/wordBreak 12345p &#123; white-space:nowrap; text-overflow:ellipsis; overflow:hidden; &#125;","categories":[{"name":"汇总篇","slug":"汇总篇","permalink":"http://zc95.github.io/categories/汇总篇/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"一行代码实现星级评分","slug":"star-rating","date":"2018-01-23T13:03:13.000Z","updated":"2018-01-30T15:23:57.113Z","comments":true,"path":"2018/01/23/star-rating/","link":"","permalink":"http://zc95.github.io/2018/01/23/star-rating/","excerpt":"实现原理 Link demo github","text":"实现原理 Link demo github 主要代码css12345678910.score_wrapper &#123; display:inline-block; font-size: 45px; cursor: pointer; color: #dc2020; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none; &#125; html1&lt;div class=\"score_wrapper\"&gt;&lt;/div&gt; javascript123456789101112131415161718192021222324252627$(function () &#123; ScoreInit(3); //初始化，参数是0～5的数字，代表星数，传空默认0颗星&#125;)//点击function ScoreInit(e) &#123; Score((e == null) ? 0 : e); //传空默认0颗星 $(\".score_wrapper\").bind('click', function (e) &#123; var eachWidth = $(\".score_wrapper\").width() / 5; //计算出每个星星的长度 var X = e.pageX - $(this).offset().left; //距离父容器的偏移距离 var score = Math.floor(X / eachWidth) + 1; //分数 Score((getScore() == score) ? 0 : score); //取消评分 &#125;)&#125;//评分function Score(rate) &#123; $(\".score_wrapper\").html(\"★★★★★☆☆☆☆☆\".slice(5 - rate, 10 - rate));&#125;//获取评分function getScore() &#123; var str = $(\".score_wrapper\").html(), num = 0; for (var i = 0; i &lt; str.length; i++) &#123; if (str[i] == \"★\") &#123; num++ &#125; &#125; return num;&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"nodejs搭建本地服务器环境","slug":"nodejsFirstTry","date":"2018-01-11T10:09:48.000Z","updated":"2018-01-11T10:51:45.085Z","comments":true,"path":"2018/01/11/nodejsFirstTry/","link":"","permalink":"http://zc95.github.io/2018/01/11/nodejsFirstTry/","excerpt":"Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. Node.js® 是一个基于 Chrome V8 引擎的 JavaScript 运行时。 Node.js 使用高效、轻量级的事件驱动、非阻塞 I/O 模型。它的包生态系统，npm，是目前世界上最大的开源库生态系统。 安装nodejs 点击 https://nodejs.org 进入nodejs官网 有两个版本：LTS和Current，LTS是长期支持版本，成熟可靠 next到底 打开终端，输入 node -v ，回车，如果出现类似这样 v6.11.4 的版本号就说明安装成功","text":"Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. Node.js® 是一个基于 Chrome V8 引擎的 JavaScript 运行时。 Node.js 使用高效、轻量级的事件驱动、非阻塞 I/O 模型。它的包生态系统，npm，是目前世界上最大的开源库生态系统。 安装nodejs 点击 https://nodejs.org 进入nodejs官网 有两个版本：LTS和Current，LTS是长期支持版本，成熟可靠 next到底 打开终端，输入 node -v ，回车，如果出现类似这样 v6.11.4 的版本号就说明安装成功 开始 在根目录下新建一个 nodetest 的文件夹 在 nodetest 下新建一个 server.js 的文件 拷贝粘贴这段代码，保存： 123456789var http = require(\"http\");http.createServer(function(request, response) &#123; response.writeHead(200, &#123; \"Content-Type\" : \"text/plain\" &#125;); response.write(\"Welcome to Nodejs\"); response.end();&#125;).listen(8000, \"127.0.0.1\");console.log(\"Creat server on http://127.0.0.1:8000/\"); 打开终端 输入 cd nodetest 回车，ls 回车，确保返回的是你新建的那个 server.js 文件 输入 node nodetest server.js 回车，返回 Creat server on http://127.0.0.1:8000/ 打开浏览器输入 http://127.0.0.1:8000/ 或者 http://localhost:8000 Welcome to Nodejs","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://zc95.github.io/tags/nodejs/"},{"name":"node.js","slug":"node-js","permalink":"http://zc95.github.io/tags/node-js/"},{"name":"本地服务器","slug":"本地服务器","permalink":"http://zc95.github.io/tags/本地服务器/"}]},{"title":"水平垂直居中","slug":"centerAndmiddle","date":"2018-01-10T13:17:24.000Z","updated":"2018-01-10T14:26:16.028Z","comments":true,"path":"2018/01/10/centerAndmiddle/","link":"","permalink":"http://zc95.github.io/2018/01/10/centerAndmiddle/","excerpt":"水平垂直居中（已知宽高）方法很多，这里就说一个不常见的 123456&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718.father &#123; position: relative; width: 300px; height: 300px; border: 1px solid black;&#125;.son &#123; position: absolute; width: 60px; height: 60px; top: 0; left: 0; bottom: 0; right: 0; margin: auto; border: 1px solid gray;&#125;","text":"水平垂直居中（已知宽高）方法很多，这里就说一个不常见的 123456&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718.father &#123; position: relative; width: 300px; height: 300px; border: 1px solid black;&#125;.son &#123; position: absolute; width: 60px; height: 60px; top: 0; left: 0; bottom: 0; right: 0; margin: auto; border: 1px solid gray;&#125; 水平垂直居中（宽高不确定/伪元素）用伪元素和 inline-block / vertical-align 可以实现水平垂直居中 123456&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223.father &#123; position:fixed; top:0; right:0; left:0; bottom:0; text-align: center; border: 1px solid black;&#125;.father:before &#123; content: ''; display: inline-block; height: 100%; vertical-align: middle; margin-right: -0.25em; /*去空隙*/&#125;.son &#123; display: inline-block; vertical-align: middle; border: 1px solid gray;&#125; 水平垂直居中（宽高不确定/flex）css弹性布局（flex） 123456&lt;div class=\"father\"&gt; &lt;div class=\"son\" style=\"display:inline-block;\"&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678910.father &#123; height: 300px; width: 100%; display: flex; align-items: center; /*定义body的元素垂直居中*/ justify-content: center; /*定义body的里的元素水平居中*/&#125;.son&#123; border:1px solid gray;&#125; 水平垂直居中（宽高不确定/transform）CSS3的transform，通过设置div的transform: translate(-50%,-50%)，使得div向上平移（translate）自身高度的一半(50%)、自身宽度的一半(50%) 1234&lt;div class=\"son\"&gt; &lt;p&gt;zc95.github.io&lt;/p&gt; &lt;p&gt;zc95.github.io&lt;/p&gt;&lt;/div&gt; 12345678910.son &#123; position: absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%); border: 1px solid gray;&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"},{"name":"水平垂直居中","slug":"水平垂直居中","permalink":"http://zc95.github.io/tags/水平垂直居中/"}]},{"title":"ToDo 待办事宜app","slug":"ToDo","date":"2018-01-07T10:29:58.000Z","updated":"2018-01-07T12:54:37.260Z","comments":true,"path":"2018/01/07/ToDo/","link":"","permalink":"http://zc95.github.io/2018/01/07/ToDo/","excerpt":"ToDo最近做事情总是丢三落四，老忘记一些重要的事情，就突发奇想写了这个 ToDo 待办事宜的app。 项目地址 github地址","text":"ToDo最近做事情总是丢三落四，老忘记一些重要的事情，就突发奇想写了这个 ToDo 待办事宜的app。 项目地址 github地址 主要功能 可以添加待办事项到首页中，数据都是保存在本地localStorage的，只要不是手动删除或者换了设备，数据是永久保存的 点击事项可以将待办事项的状态改为 选中 和 未选中 ，每次改变状态都会保存到localStorage，每天的开始都可以点 重置所有状态 的按钮来设置所有的待办事项为未选中 可以删除已添加的待办事项或者彻底删除所有本地localStorage数据 可以复制项目链接在自己的浏览器中打开，然后添加到桌面，方便使用；https://htmlpreview.github.io/?https://github.com/zc95/ToDo/blob/master/index.html","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"localStorage","slug":"localStorage","permalink":"http://zc95.github.io/tags/localStorage/"}]},{"title":"VMware服务器虚拟化","slug":"VMware","date":"2017-12-26T12:49:24.000Z","updated":"2017-12-26T13:10:59.659Z","comments":true,"path":"2017/12/26/VMware/","link":"","permalink":"http://zc95.github.io/2017/12/26/VMware/","excerpt":"今天去机房打了一天酱油，听到了看到了一些没接触过的东西，做个简单的整理。 VMware服务器虚拟化VMware官网 大多数服务器的容量利用率不足 15%，这不仅导致了服务器数量剧增，还增加了复杂性。实现服务器虚拟化后，多个操作系统可以作为虚拟机在单台物理服务器上运行，并且每个操作系统都可以访问底层服务器的计算资源，从而解决效率低下问题。接下来将服务器集群聚合为一项整合资源，这可以提高整体效率并降低成本。服务器虚拟化还可以加快工作负载部署速度、提高应用性能以及改善可用性。","text":"今天去机房打了一天酱油，听到了看到了一些没接触过的东西，做个简单的整理。 VMware服务器虚拟化VMware官网 大多数服务器的容量利用率不足 15%，这不仅导致了服务器数量剧增，还增加了复杂性。实现服务器虚拟化后，多个操作系统可以作为虚拟机在单台物理服务器上运行，并且每个操作系统都可以访问底层服务器的计算资源，从而解决效率低下问题。接下来将服务器集群聚合为一项整合资源，这可以提高整体效率并降低成本。服务器虚拟化还可以加快工作负载部署速度、提高应用性能以及改善可用性。 虚拟化的优势虚拟化可以提高 IT 部门的敏捷性、灵活性和可扩展性，同时大幅节约成本。工作负载的部署速度更快、性能和可用性得到提升、运维实现自动化，所有这一切不仅简化了 IT 管理，还降低了拥有成本和运维成本。其他优势包括： 降低资金成本和运维成本。 最大限度地减少或消除停机。 提高 IT 部门的工作效率、效益、敏捷性和响应能力。 更快地调配应用和资源。 支持业务连续性与灾难恢复。 简化数据中心管理。 构建真正的软件定义的数据中心 VMware vSphere client用来连接VMware ESXi主机和vCenter server，业内最完整、 最强健的虚拟化平台。创建资源池来管理计算、 网络和存储容量与易用性，并提供最高水平的服务，每个应用程序工作负载以最低的总成本。VSphere — — 取决于世界上要求最苛刻的数据中心虚拟化您业务关键型应用程序为空前的灵活性和可靠性。 UPS电源百度百科 UPS电源一般指不间断电源。 UPS（Uninterruptible Power System/Uninterruptible Power Supply），即不间断电源，是将蓄电池（多为铅酸免维护蓄电池）与主机相连接，通过主机逆变器等模块电路将直流电转换成市电的系统设备。主要用于给单台计算机、计算机网络系统或其它电力电子设备如电磁阀、压力变送器等提供稳定、不间断的电力供应。当市电输入正常时，UPS 将市电稳压后供应给负载使用，此时的UPS就是一台交流式电稳压器，同时它还向机内电池充电；当市电中断（事故停电）时， UPS 立即将电池的直流电能，通过逆变器切换转换的方法向负载继续供应220V交流电，使负载维持正常工作并保护负载软、硬件不受损坏。UPS 设备通常对电压过高或电压过低都能提供保护。 特点 UPS是针对中国电网环境和网络监控及网络系统、医疗系统等对电源的可靠性要求，克服中、大型计算机网络系统集中供电所造成的供电电网环境日益恶劣的问题，以全新的数字技术研制出的第三代工频纯在线式智能型UPS。直流电源，是维持电路中形成稳恒电流的装置。如干电池、蓄电池、直流发电机等。 UPS和直流电源是企业重要的供电保障设备，传统的维护管理包括：①日常巡检外观，定期更换电池、滤波电容、风机等易损件，大修时做电池活化等；②改造或采用换代设备，使用高级工具测试电池性能。这种管理方式企业投入成本高，维护人员工作量大，不易实时掌握设备运行状态和关键数据，设备事故预防能力低。实施在线维护管理可避免传统方式的不足之处，获得良好效益。 UPS的中文意思为“不间断电源”，是英语“Uninterruptible Power System/Uninterruptible Power Supply”的缩写，它可以保障计算机系统在停电之后继续工作一段时间以使用户能够紧急存盘，使用户不致因停电而影响工作或丢失数据。 交换机百度百科 交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机。其他常见的还有电话语音交换机、光纤交换机等。 图片上是 Cisco Catalyst 4500-E Series ，Cisco Catalyst 4500-X 系列交换机 概念交换（switching）是按照通信两端传输信息的需要，用人工或设备自动完成的方法，把要传输的信息送到符合要求的相应路由上的技术的统称。根据工作位置的不同，可以分为广域网交换机和局域网交换机。广义的交换机（switch）就是一种在通信系统中完成信息交换功能的设备。 在计算机网络系统中，交换概念的提出改进了共享工作模式。我们以前介绍过的HUB集线器就是一种共享设备，HUB本身不能识别目的地址，当同一局域网内的A主机给B主机传输数据时，数据包在以HUB为架构的网络上是以广播方式传输的，由每一台终端通过验证数据包头的地址信息来确定是否接收。也就是说，在这种工作方式下，同一时刻网络上只能传输一组数据帧的通讯，如果发生碰撞还得重试。这种方式就是共享网络带宽。 hub百度百科 HUB是一个多端口的转发器，在以HUB为中心设备时，即使网络中某条线路产生了故障，并不影响其它线路的工作。所以HUB在局域网中得到了广泛的应用。大多数的时候它用在星型与树型网络拓扑结构中，以RJ45接口与各主机相连（也有BNC接口），HUB按照不同的说法有很多种类。 HUB按照对输入信号的处理方式上，可以分为无源HUB、有源HUB、智能HUB。 磁盘阵列百度百科 磁盘阵列（Redundant Arrays of Independent Disks，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。 磁盘阵列是由很多价格较便宜的磁盘，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。利用这项技术，将数据切割成许多区段，分别存放在各个硬盘上。 磁盘阵列还能利用同位检查（Parity Check）的观念，在数组中任意一个硬盘故障时，仍可读出数据，在数据重构时，将数据经计算后重新置入新硬盘中。 堡垒机百度百科 堡垒机，即在一个特定的网络环境下，为了保障网络和数据不受来自外部和内部用户的入侵和破坏，而运用各种技术手段实时收集和监控网络环境中每一个组成部分的系统状态、安全事件、网络活动，以便集中报警、及时处理及审计定责。 产生原因随着企事业单位IT系统的不断发展，网络规模和设备数量迅速扩大，日趋复杂的IT系统与不同背景的运维人员的行为给信息系统安全带来较大风险，主要表现在： 多个用户使用同一个账号。这种情况主要出现在同一工作组中，由于工作需要，同时系统管理账号唯一，因此只能多用户共享同一账号。如果发生安全事故，不仅难以定位账号的实际使用者和责任人，而且无法对账号的使用范围进行有效控制，存在较大安全风险和隐患。 一个用户使用多个账号。目前，一个维护人员使用多个账号是较为普遍的情况，用户需要记忆多套口令同时在多套主机系统、网络设备之间切换，降低工作效率，增加工作复杂度。如下图所示： 缺少统一的权限管理平台，权限管理日趋繁重和无序；而且维护人员的权限大多是粗放管理，无法基于最小权限分配原则的用户权限管理，难以实现更细粒度的命令级权限控制，系统安全性无法充分保证。 无法制定统一的访问审计策略，审计粒度粗。各网络设备、主机系统、数据库是分别单独审计记录访问行为，由于没有统一审计策略，并且各系统自身审计日志内容深浅不一，难以及时通过系统自身审计发现违规操作行为和追查取证。 传统的网络安全审计系统无法对维护人员经常使用的SSH、RDP等加密、图形操作协议进行内容审计。 核心功能单点登录功能支持对X11、linux、unix、数据库、网络设备、安全设备等一系列授权账号进行密码的自动化周期更改，简化密码管理，让使用者无需记忆众多系统密码，即可实现自动登录目标设备，便捷安全。[1] 账号管理设备支持统一账户管理策略，能够实现对所有服务器、网络设备、安全设备等账号进行集中管理，完成对账号整个生命周期的监控，并且可以对设备进行特殊角色设置如：审计巡检员、运维操作员、设备管理员等自定义设置，以满足审计需求 身份认证设备提供统一的认证接口，对用户进行认证，支持身份认证模式包括 动态口令、静态密码、硬件key 、生物特征等多种认证方式，设备具有灵活的定制接口，可以与其他第三方认证服务器之间结合；安全的认证模式，有效提高了认证的安全性和可靠性。 资源授权设备提供基于用户、目标设备、时间、协议类型IP、行为等要素实现细粒度的操作授权，最大限度保护用户资源的安全 访问控制设备支持对不同用户进行不同策略的制定，细粒度的访问控制能够最大限度的保护用户资源的安全，严防非法、越权访问事件的发生。 操作审计设备能够对字符串、图形、文件传输、数据库等全程操作行为审计；通过设备录像方式实时监控运维人员对操作系统、安全设备、网络设备、数据库等进行的各种操作，对违规行为进行事中控制。对终端指令信息能够进行精确搜索，进行录像精确定位。[2]","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"VMware","slug":"VMware","permalink":"http://zc95.github.io/tags/VMware/"},{"name":"服务器虚拟化","slug":"服务器虚拟化","permalink":"http://zc95.github.io/tags/服务器虚拟化/"},{"name":"堡垒机","slug":"堡垒机","permalink":"http://zc95.github.io/tags/堡垒机/"},{"name":"磁盘阵列","slug":"磁盘阵列","permalink":"http://zc95.github.io/tags/磁盘阵列/"},{"name":"交换机","slug":"交换机","permalink":"http://zc95.github.io/tags/交换机/"}]},{"title":"JavaScript闭包","slug":"javascriptClosure","date":"2017-12-21T12:48:17.000Z","updated":"2017-12-26T13:11:21.185Z","comments":true,"path":"2017/12/21/javascriptClosure/","link":"","permalink":"http://zc95.github.io/2017/12/21/javascriptClosure/","excerpt":"对于JavaScript的程序员来说，闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 MDN Closures 变量的作用域变量的作用域无非就是两种：全局变量和局部变量。当在函数中声明一个变量的时候，如果用关键字var来声明此变量，那么它就是局部变量，如果没有var那么就会成为全局变量。一般不建议用这种方式定义全局变量。而是用var将变量声明在函数的外面。 12345var name = '小张'; // 全局变量function func() &#123; var name = '小明'; // 局部变量 age = 12; // 全局变量，建议少用这种全局变量的定义方式&#125;","text":"对于JavaScript的程序员来说，闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 MDN Closures 变量的作用域变量的作用域无非就是两种：全局变量和局部变量。当在函数中声明一个变量的时候，如果用关键字var来声明此变量，那么它就是局部变量，如果没有var那么就会成为全局变量。一般不建议用这种方式定义全局变量。而是用var将变量声明在函数的外面。 12345var name = '小张'; // 全局变量function func() &#123; var name = '小明'; // 局部变量 age = 12; // 全局变量，建议少用这种全局变量的定义方式&#125; 在JavaScript中，函数可以用来创造函数作用域。函数内部可以看到外面的变量，而外面看不到函数里的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，直到搜索到全局变量为止。 123456789101112var a = 1;var func1 = function()&#123; var b = 2; var func2 = function()&#123; var c = 3; console.log( b ); // 2 console.log( a ); // 1 &#125; func2(); console.log( c ); // 报错：c is not defined&#125;;func1(); 那么能不能从函数外部来访问局部变量呢？答案是可以。 1234567var func = function() &#123; var number = 6; return function() &#123; return number; &#125; &#125;;console.log( func()() ); // 6 变量的生存周期全局变量的生存周期是永久的，除非我们主动的销毁这个全局变量。而对于局部变量来说，当退出函数时，这些局部变量就失去了生存的环境，所以会随着函数调用的结束而被销毁。那么是否可以让局部变量在函数调用结束的时候不被销毁呢？来看下面这个例子： 1234567891011var func = function() &#123; var a = 1; return function() &#123; a++; console.log( a ); &#125; &#125;;var f = func();f(); // 2f(); // 3f(); // 4 从上面这个输出结果，我们可以看到局部变量a并没有随着f()的调用而被销毁。这是因为全局变量f保存着对func里面匿名函数的引用。而这个匿名函数是可以访问到局部变量a的，所以自然a也被保存下来了。所以这种情况下局部变量的生存周期就得以延续。上面这个匿名函数其实就是一个闭包。再来看一个闭包的经典应用。 1234567// 假设有5个divvar nodes = document.getElementsByTagName( 'div' );for ( var i = 0, l = nodes.length; i &lt; l; i++ ) &#123; nodes[i].onclick = function() &#123; console.log( i ); &#125;&#125; 当真正执行这段代码的时候，发现无论点击那个div，最后打印的结果都是4。这是因为onclick事件是异步触发的，当事件触发的时候，for循环早已经结束，此时变量i的值已经是4。解决方案可以是用闭包把每次的i都保存起来： 1234567for ( var i = 0, l = nodes.length; i &lt; l; i++ ) &#123; (function( i ) &#123; nodes[i].onclick = function() &#123; console.log( i ); &#125; &#125;)( i );&#125; 同理，我们编写一段代码用来判断对象类型： 12345678910var Type = &#123;&#125;;for ( var i = 0, type; type = [ 'String', 'Array', 'Number' ][ i++ ]; ) &#123; (function( type ) &#123; Type[ 'is' + type ] = function( obj ) &#123; return Object.prototype.toString.call( obj ) === '[object ' + type + ']'; &#125; &#125;)( type );&#125;Type.isArray( [] ); // trueType.isString( 'str' ); // true 什么是闭包官方的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因为这些变量也是该表达式的一部分。这个概念不好理解，我们可以简单得理解成闭包就是能够访问函数内部变量的函数。 闭包的作用 可以在函数外部访问在函数内部定义的局部变量 延续局部变量的生存周期 封装变量闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。假设有一个计算乘积的函数： 12345678var mult = function() &#123; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return a;&#125;;mult(2, 3, 4); // 24 mult函数接受一些Number类型的参数，并且返回他们的乘积。现再我们觉得对于那些相同参数来说，每次再进行计算是一种浪费，所以我们决定加入缓存机制来提高函数性能： 123456789101112var cache = &#123;&#125;;var mult = function() &#123; var args = Array.prototype.join.call( arguments, '' ); if ( cache[ args ] ) &#123; return cache[ args ]; &#125; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return cache[ args ] = a;&#125;; 我们看到cache这个变量仅仅在mult函数中被使用，所以为了避免cache污染全局变量，我们将它放到mult函数里面 1234567891011121314var mult = (function() &#123; var cache = &#123;&#125;; return function() &#123; var args = Array.prototype.join.call( arguments, '' ); if ( cache[ args ] ) &#123; return cache[ args ]; &#125; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return cache[ args ] = a; &#125;&#125;)(); 提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有利于代码的复用，如果这些小函数有一个良好的命名，那么它们本身就起到了一个很好的注释作用。 1234567891011121314151617var mult = (function() &#123; var cache = &#123;&#125;; var calculate = function() &#123; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ ) &#123; a = a * arguments[i]; &#125; return a; &#125;; return function() &#123; var args = Array.prototype.join.call( arguments, '' ); if ( cache[ args ] ) &#123; return cache[ args ]; &#125; return cache[ args ] = calculate.apply( null, arguments ); &#125;&#125;)(); 闭包与内存管理局部变量本来应该在函数退出的时候就被结束引用，但如果局部变量被封装在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上来看，闭包确实会使一些数据无法被及时销毁。如果将来需要回收这些变量，我们可以手动把这些变量设为null。跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域中保存着一些DOM节点，这个时候就有可能造成内存泄露。在IE9之前的浏览器中，由于BOM和DOM中的对象是使用C++对象以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是引用计数策略。在基于引用计数的垃圾收集机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。但我们只要把循环引用中的对象设为null即可解决这个问题。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://zc95.github.io/tags/正则表达式/"}]},{"title":"正则表达式","slug":"RegularExpression","date":"2017-12-20T10:48:26.000Z","updated":"2017-12-21T12:41:12.998Z","comments":true,"path":"2017/12/20/RegularExpression/","link":"","permalink":"http://zc95.github.io/2017/12/20/RegularExpression/","excerpt":"PART 1-为什么使用正则表达式？ 测试字符串内的模式 例如，可以测试输入字符串，以查看字符串内是否出现电话号码或信用卡号码模式。这称为数据验证 替换文本 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它 基于模式匹配从字符串中提取子字符串 可以查找文档内或输入域内特定的文本","text":"PART 1-为什么使用正则表达式？ 测试字符串内的模式 例如，可以测试输入字符串，以查看字符串内是否出现电话号码或信用卡号码模式。这称为数据验证 替换文本 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它 基于模式匹配从字符串中提取子字符串 可以查找文档内或输入域内特定的文本 PART 2-练习正则表达式我们可以在console控制台，regexper 或者 IDE 去练习正则表达式 推荐一个JS正则可视化的在线工具，简单易懂：regexper.com 现在大部分IDE都会支持正则表达式匹配，如sublime： PART 3-举个🌰实例 ^[0-9]+abc$ ^ 为匹配输入字符串的开始位置 [0-9]+ 匹配单个数字，+ 匹配一个或者多个 abc$ 匹配字母 abc 结尾 $ 为匹配输入字符串的结束位置 匹配以数字开头，并以abc结尾的字符串： 12345var str = \"123abc\";var patt1 = /^[0-9]+abc$/;document.write(str.match(patt1));==&gt; 123ABC PART 4-基本正则字符基础字符含义MDN Regular Expressions 字符 描述 \\ 转意，即通常在”\\”后面的字符不按原来意义解释，如/b/匹配字符”b”，当b前面加了反斜杠后/\\b/，转意为匹配一个单词的边界。 ^ 匹配输入的开始 例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。 当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。补充字符集合一节有详细介绍和示例。 $ 匹配输入的结束。 例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。 * 匹配前面元字符0次或多次，/ba*/ 将匹配b,ba,baa,baaa ，相当于{0, } 例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西。 + 匹配前面元字符1次或多次，/ba+/将匹配ba,baa,baaa，相当于{1, } 例如，/a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。 ? 匹配前面元字符0次或1次，相当于 {0,1} 例如，/e?le?/ 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’ 如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。 例如，对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。 还可以运用于先行断言，如本表的 x(?=y) 和 x(?!y) 条目中所述。 . 匹配除换行符之外的任何单个字符 例如，/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。 x&#124;y 匹配x或y {n} 精确匹配n次 {n,} 匹配n次以上 {n,m} 匹配n-m次 [^xyz ] 字符集(character set)，匹配这个集合中的任一一个字符(或元字符) [\\b] 匹配一个退格符 \\b 匹配一个单词的边界 \\B 匹配一个非单词边界 \\cX 这儿，X是一个控制符，/\\cM/匹配Ctrl-M \\d 匹配一个数字，/\\d/ = /[0-9]/ \\D 匹配一个非字数字符，/\\D/ = /[ ^0-9]/ \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\s 匹配一个空白字符，包括\\n,\\r,\\f,\\t,\\v等 \\S 匹配一个非空白字符，等于 /[ ^\\n\\f\\r\\t\\v]/ \\t 匹配一个制表符 \\v 匹配一个重直制表符 \\w 匹配字母或数字或下划线，等于[a-zA-Z_0-9] ( 能不能匹配汉字要视你的操作系统和你的应用环境而定 \\W 匹配一个不可以组成单词的字符，如[\\W]匹配”5.98”中的，等于 [ ^a-zA-Z0-9] PART 5-使用正则表达式正则表达式可以被用于RegExp的exec和test方法以及 String的match、replace、search和split方法。这些方法在JavaScript 手册中有详细的解释。 方法 描述 exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。 test 一个在字符串中测试是否匹配的RegExp方法，它返回true或false。 match 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。 search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://zc95.github.io/tags/正则表达式/"}]},{"title":"loading加载等待框","slug":"loading","date":"2017-11-30T11:07:04.000Z","updated":"2017-12-21T12:08:52.817Z","comments":true,"path":"2017/11/30/loading/","link":"","permalink":"http://zc95.github.io/2017/11/30/loading/","excerpt":"链接 demo地址 github地址","text":"链接 demo地址 github地址 调用 LoadShow(); LoadHide(); 主要代码JS1234567891011function LoadShow() &#123; if ($(\"#loading_wrapper\").length &gt; 0) &#123; return false; &#125; var str = \"&lt;div id='loading_wrapper' class='loaders_wrapper'&gt;&lt;div class='loader'&gt;&lt;div class='loader-inner ball-spin-fade-loader'&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\"; $(\"body\").append(str); $(\"#loading_wrapper\").show();&#125;function LoadHide() &#123; $(\"#loading_wrapper\").hide().remove();&#125; CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/*在线预览等待框*/.loaders_wrapper &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; filter: alpha(opacity=50); opacity: 0.4; color: #fff; font-size: 14px; font-family: 'Source Sans Pro'; display: none; z-index: 99999;&#125;.loaders_wrapper .loader &#123; max-width: 70px; height: 70px; position: absolute; left: 50%; top: 50%; margin-left: -35px; margin-top: -35px;&#125;@-webkit-keyframes ball-spin-fade-loader &#123; 50% &#123; opacity: 0.3; -webkit-transform: scale(0.4); transform: scale(0.4); &#125; 100% &#123; opacity: 1; -webkit-transform: scale(1); transform: scale(1); &#125;&#125;@keyframes ball-spin-fade-loader &#123; 50% &#123; opacity: 0.3; -webkit-transform: scale(0.4); transform: scale(0.4); &#125; 100% &#123; opacity: 1; -webkit-transform: scale(1); transform: scale(1); &#125;&#125;.ball-spin-fade-loader &#123; position: relative;&#125;.ball-spin-fade-loader &gt; div:nth-child(1) &#123; top: 25px; left: 0; -webkit-animation: ball-spin-fade-loader 1s 0s infinite linear; animation: ball-spin-fade-loader 1s 0s infinite linear;&#125;.ball-spin-fade-loader &gt; div:nth-child(2) &#123; top: 17.04545px; left: 17.04545px; -webkit-animation: ball-spin-fade-loader 1s 0.12s infinite linear; animation: ball-spin-fade-loader 1s 0.12s infinite linear;&#125;.ball-spin-fade-loader &gt; div:nth-child(3) &#123; top: 0; left: 25px; -webkit-animation: ball-spin-fade-loader 1s 0.24s infinite linear; animation: ball-spin-fade-loader 1s 0.24s infinite linear;&#125;.ball-spin-fade-loader &gt; div:nth-child(4) &#123; top: -17.04545px; left: 17.04545px; -webkit-animation: ball-spin-fade-loader 1s 0.36s infinite linear; animation: ball-spin-fade-loader 1s 0.36s infinite linear;&#125;.ball-spin-fade-loader &gt; div:nth-child(5) &#123; top: -25px; left: 0; -webkit-animation: ball-spin-fade-loader 1s 0.48s infinite linear; animation: ball-spin-fade-loader 1s 0.48s infinite linear;&#125;.ball-spin-fade-loader &gt; div:nth-child(6) &#123; top: -17.04545px; left: -17.04545px; -webkit-animation: ball-spin-fade-loader 1s 0.6s infinite linear; animation: ball-spin-fade-loader 1s 0.6s infinite linear;&#125;.ball-spin-fade-loader &gt; div:nth-child(7) &#123; top: 0; left: -25px; -webkit-animation: ball-spin-fade-loader 1s 0.72s infinite linear; animation: ball-spin-fade-loader 1s 0.72s infinite linear;&#125;.ball-spin-fade-loader &gt; div:nth-child(8) &#123; top: 17.04545px; left: -17.04545px; -webkit-animation: ball-spin-fade-loader 1s 0.84s infinite linear; animation: ball-spin-fade-loader 1s 0.84s infinite linear;&#125;.ball-spin-fade-loader &gt; div &#123; background-color: #fff; width: 15px; height: 15px; border-radius: 100%!important; margin: 2px; -webkit-animation-fill-mode: both; animation-fill-mode: both; position: absolute;&#125;/*在线预览等待框*/","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"用最简单的代码实现点击查看大图","slug":"enlargeImg","date":"2017-11-29T13:03:34.000Z","updated":"2017-12-21T12:42:50.170Z","comments":true,"path":"2017/11/29/enlargeImg/","link":"","permalink":"http://zc95.github.io/2017/11/29/enlargeImg/","excerpt":"今天做了个点击查看大图的功能，只需要给img加一个class，不用写额外的html代码 链接 demo地址 github地址","text":"今天做了个点击查看大图的功能，只需要给img加一个class，不用写额外的html代码 链接 demo地址 github地址 核心代码 html部分12&lt;img class=\"enlargeImg\" width=\"80\" src=\"https://zc95.github.io/img/avatar.png\"title=\"点击查看大图\" /&gt; 重点： img标签 class=”enlargeImg” 限制图片宽度或高度为”小图片”，width=”80” src有值 title=”点击查看大图” css部分12345678910111213141516171819.enlargeImg_wrapper &#123; display: none; position: fixed; z-index: 999; top: 0; right: 0; bottom: 0; left: 0; background-repeat: no-repeat; background-attachment: fixed; background-position: center; background-color: rgba(52, 52, 52, 0.8); background-size: 50%;&#125;img:hover,.enlargeImg_wrapper:hover &#123; cursor: pointer;&#125; 重点： 半透明遮罩层 background-color: rgba(52, 52, 52, 0.8); 水平垂直居中 background-position: center; 放大后的图片大小 background-size: 50%; 如果受页面中别的定位元素的z-index影响，改z-index的值就行 js部分12345678910111213141516$(function() &#123; enlargeImg();&#125;)//查看大图function enlargeImg() &#123; $(\".enlargeImg\").click(function() &#123; $(this).after(\"&lt;div onclick='closeImg()' class='enlargeImg_wrapper'&gt;&lt;/div&gt;\"); var imgSrc = $(this).attr('src'); $(\".enlargeImg_wrapper\").css(\"background-image\", \"url(\" + imgSrc + \")\"); $('.enlargeImg_wrapper').fadeIn(200); &#125;)&#125;//关闭并移除图层function closeImg() &#123; $('.enlargeImg_wrapper').fadeOut(200).remove();&#125; 重点： 点击class为 enlargeImg 的图片时获取它的路径，var imgSrc = $(this).attr(‘src’); 创建遮罩层，$(this).after(““); 赋值给 enlargeImg_wrapper ，$(“.enlargeImg_wrapper”).css(“background-image”, “url(“ + imgSrc + “)”); 关闭遮罩层时移除遮罩层，$(‘.enlargeImg_wrapper’).fadeOut(200).remove();","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"更改hosts文件来更好地使用github","slug":"hostsChange","date":"2017-11-28T15:49:00.000Z","updated":"2017-12-21T12:12:16.566Z","comments":true,"path":"2017/11/28/hostsChange/","link":"","permalink":"http://zc95.github.io/2017/11/28/hostsChange/","excerpt":"最近可能是网不太好，hexo d的时候总是提交不了，很苦恼，试了n多种方法。。。 hexo d时报错1234fatal: unable to access'https://github.com/zc95/zc95.github.io.git/ ': Could notresolve host: github.comFATAL Something's wrong.Maybe you can find the solution here:http:hexo.io/docs/troubleshooting.html... 命令行终端 ping github.com打开命令行终端，输入 ping github.com 并回车 ping github.com","text":"最近可能是网不太好，hexo d的时候总是提交不了，很苦恼，试了n多种方法。。。 hexo d时报错1234fatal: unable to access'https://github.com/zc95/zc95.github.io.git/ ': Could notresolve host: github.comFATAL Something's wrong.Maybe you can find the solution here:http:hexo.io/docs/troubleshooting.html... 命令行终端 ping github.com打开命令行终端，输入 ping github.com 并回车 ping github.com 如果像下面这样ping不出，就继续往下看吧 12345678910ping github.comPING github.com (192.30.255.113): 56 data bytesRequest timeoutRequest timeout for icmp_seq 0Request timeout for icmp_seq 1Request timeout for icmp_seq 2Request timeout for icmp_seq 3Request timeout for icmp_seq 4Request timeout for icmp_seq 5... Ping github.com 打开链接 http://ping.chinaz.com 输入 github.com ,点击Ping检测 选择一条TTL值最小的ip地址，例如：192.30.255.113 修改hosts 点击Finder - 前往 - 前往文件夹… - 输入 /etc/hosts 点击前往 找到hosts文件，修改hosts文件需要管理员权限，所以不能单纯修改，先按住hosts文件拖到桌面，双击打开桌面上的hosts文件 在 127.0.0.1 localhost 下面另起一行输入 192.30.255.113 github.com ，保存并退出 将桌面的hosts文件拖回直原来的位置，他会提示你 修改”etc”需要管理员密码 ，点击”鉴定”，会提示你是否覆盖原文件，点击”是”，输入密码或指纹，ok了 再次在命令行终端 ping github.com 就能看到ping成功了 可以愉快的deploy了 FAQ什么是hosts？ Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 每次改完配置需要重启机器吗？ 不需要，它实质上是个文本文件，当计算机需要解析地址时，会首先检查此文件，读取后再确定是本地解析还是要发送到DNS服务器来解析。改后，只要再上网，就会生效。 hosts文件在哪里?1234Linux:/etc/hostsMac OS X:/etc/hostsAndroid:/etc/hostsWindows:C:/windows/System32/drivers/etc/hosts hosts文件规则?12345#ip地址 域名127.0.0.1 localhost192.30.255.113 github.com255.255.255.255 broadcasthost::1 localhost","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"github","slug":"github","permalink":"http://zc95.github.io/tags/github/"},{"name":"hosts","slug":"hosts","permalink":"http://zc95.github.io/tags/hosts/"}]},{"title":"关于float清除浮动和inline-block出现空隙的问题","slug":"floatAndInlineBlock","date":"2017-11-26T15:21:45.000Z","updated":"2018-01-10T13:27:57.923Z","comments":true,"path":"2017/11/26/floatAndInlineBlock/","link":"","permalink":"http://zc95.github.io/2017/11/26/floatAndInlineBlock/","excerpt":"最近在写项目的时候手写了一个简单选项卡，遇到这类布局，最常见、最快速的布局方式就是display:inline-block;和float:left; 但我们都知道 display:inline-block 布局会出现空隙的问题，float:left 又要清除浮动，本文就这两个问题整理出解决方案。","text":"最近在写项目的时候手写了一个简单选项卡，遇到这类布局，最常见、最快速的布局方式就是display:inline-block;和float:left; 但我们都知道 display:inline-block 布局会出现空隙的问题，float:left 又要清除浮动，本文就这两个问题整理出解决方案。 display:inline-block去掉空隙移除标签间的空格123&lt;ul class=\"tab-wrapper\"&gt; &lt;li class=\"tab-item active\"&gt;项目一&lt;/li&gt;&lt;li class=\"tab-item\"&gt;项目二&lt;/li&gt;&lt;li class=\"tab-item\"&gt;项目三&lt;/li&gt;&lt;li class=\"tab-item\"&gt;项目四&lt;/li&gt;&lt;/ul&gt; 这个方法是我最初学html时知道的方法，当时觉得挺方便的，现在工作了觉得这个方法好蠢😂，一个代码格式化就能毁了它，这样不易维护的代码太脆弱了； 去掉闭合标签123456&lt;ul class=\"tab-wrapper\"&gt; &lt;li class=\"tab-item active\"&gt;项目一 &lt;li class=\"tab-item\"&gt;项目二 &lt;li class=\"tab-item\"&gt;项目三 &lt;li class=\"tab-item\"&gt;项目四&lt;/ul&gt; 这个方法算是种好方法，最后一个li的闭合标签可有可无，也能很好的解决空隙问题，但依然还是代码不易维护的问题。 font-size:0;123456&lt;ul class=\"tab-wrapper\"&gt; &lt;li class=\"tab-item active\"&gt;项目一&lt;/li&gt; &lt;li class=\"tab-item\"&gt;项目二&lt;/li&gt; &lt;li class=\"tab-item\"&gt;项目三&lt;/li&gt; &lt;li class=\"tab-item\"&gt;项目四&lt;/li&gt;&lt;/ul&gt; 123456789.tab-wrapper&#123; font-size:0; /*父容器font-size为0*/ -webkit-text-size-adjust:none; /*Chrome有最小字体大小限制，考虑到兼容性需要取消字体大小限制*/&#125;.tab-wrapper .tab-item&#123; display:inline-block; font-size:13px; /*这里比较重要，因为子元素会继承父元素的字体大小，这里要恢复正常font-size*/ padding:5px 12px;&#125; 这个方法方法好理解，比较主流的解决方案； float 清除浮动空标签 123456&lt;div class=\"box-wrapper\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div style=\"clear:both;\"&gt;&lt;/div&gt;&lt;/div&gt; 最佳方法1234567891011121314/* 全浏览器通用的clearfix方案【推荐 *//* 引入了zoom以支持IE6/7 *//* 同时加入:before以解决现代浏览器上边距折叠的问题 */.clearfix:before,.clearfix:after &#123; display: table; content: \" \";&#125;.clearfix:after &#123; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"基于 GitHub Issues 的评论系统：gitment","slug":"gitment","date":"2017-11-23T15:47:12.000Z","updated":"2017-12-21T12:43:24.821Z","comments":true,"path":"2017/11/23/gitment/","link":"","permalink":"http://zc95.github.io/2017/11/23/gitment/","excerpt":"如何为hexo博客添加评论功能多说、友言、Disqus、livere(来比力)、gitment、畅言、valine基本都可以实现，但有些已经关闭，有些需要翻墙 本文讲的是一款基于 GitHub Issues 的评论系统：gitment 。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown语法 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。","text":"如何为hexo博客添加评论功能多说、友言、Disqus、livere(来比力)、gitment、畅言、valine基本都可以实现，但有些已经关闭，有些需要翻墙 本文讲的是一款基于 GitHub Issues 的评论系统：gitment 。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown语法 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 gitmentPC端 移动端 基础配置打开博客主题文件夹下的 _config.yml 文件，以我的为例： 12345678comment: type: gitment # 启用哪种评论系统 gitment: githubID: zc95 # 你的GitHub名称 repo: zc95.github.io # 你的GitHub名称.github.io ClientID: ********* ClientSecret: ********* lazy: false # 这个我也不清楚 大概是懒加载的意思吧 githubID 和 repo 都有了，就剩 ClientID 和 ClientSecret 了 注册OAuth Application通过地址OAuth Application注册传送门申请配置，注册一个新的 OAuth Application，其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://zc95.github.io） 获取ClientID与ClientSecret 总结 优点 界面​简洁 与github绑定，方便注册，不用依赖脚本或插件 评论会出现在github项目中的Issues里，方便管理 支持Markdown全部语法和html标签（这个很厉害） 缺点 ​每篇文章都需要手动点击initialize comments按钮来初始化评论，否则不能评论； 不支持图片（可以尝试用markdown或者img标签来实现）和表情（emoji可以用） 只能支持github登陆 最后更新最后还是选择了livere 来必力，注册登陆需要翻墙（或许因为我网不好。。），一旦注册之后评论之类的就不需翻墙了，支持QQ、微信、微博、百度等登陆方式，本页拉到最底下就是来必力了，体验还是可以的。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://zc95.github.io/tags/Hexo/"},{"name":"gitment","slug":"gitment","permalink":"http://zc95.github.io/tags/gitment/"},{"name":"Issues","slug":"Issues","permalink":"http://zc95.github.io/tags/Issues/"}]},{"title":"我的收藏","slug":"Collection","date":"2017-11-21T11:30:45.000Z","updated":"2017-12-21T12:13:56.048Z","comments":true,"path":"2017/11/21/Collection/","link":"","permalink":"http://zc95.github.io/2017/11/21/Collection/","excerpt":"我的博客https://zc95.github.io工具jsrun在线代码编辑tinypng压缩图片Google翻译msdn.itellyouMDN文档","text":"我的博客https://zc95.github.io工具jsrun在线代码编辑tinypng压缩图片Google翻译msdn.itellyouMDN文档 前端插件&amp;框架echartslayui阿里巴巴矢量图标图学习网站freecodecamp慕课网前端菜鸟教程","categories":[{"name":"汇总篇","slug":"汇总篇","permalink":"http://zc95.github.io/categories/汇总篇/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"http://zc95.github.io/tags/收藏/"},{"name":"前端必备","slug":"前端必备","permalink":"http://zc95.github.io/tags/前端必备/"}]},{"title":"数组复习","slug":"arrayReview","date":"2017-11-21T10:44:45.000Z","updated":"2017-12-21T12:14:17.731Z","comments":true,"path":"2017/11/21/arrayReview/","link":"","permalink":"http://zc95.github.io/2017/11/21/arrayReview/","excerpt":"检测数组typeof12var ary = [1,23,4];console.log(typeof ary); //输出结果是Object instanceof12var ary = [1,23,4];console.log(ary instanceof Array)//true;","text":"检测数组typeof12var ary = [1,23,4];console.log(typeof ary); //输出结果是Object instanceof12var ary = [1,23,4];console.log(ary instanceof Array)//true; 原型链方法123var ary = [1,23,4];console.log(ary.__proto__.constructor==Array);//trueconsole.log(ary.constructor==Array)//true 这两段代码是一样的 以上三种方法都不太好，instanceof 和 constructor 判断的变量，必须在当前页面声明的，比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个arr，并将其赋值给父页面的一个变量，这时判断该变量，Array == object.constructor;会返回false； 正确方法12345var ary = [1,2,3,4];function isArray(e)&#123;return Object.prototype.toString.call(e)=='[object Array]';&#125;console.log(isArray(ary)); 自己封装的基本数据类型验证123456789101112131415161718192021222324252627282930var type = &#123; isObj: function(o) &#123; return Object.prototype.toString.call(o) == \"[object Object]\"; &#125;, isArray: function(o) &#123; return Object.prototype.toString.call(o) == \"[object Array]\"; &#125;, isNull: function(o) &#123; return Object.prototype.toString.call(o) == \"[object Null]\"; &#125;, isUndefined: function(o) &#123; return Object.prototype.toString.call(o) == \"[object Undefined]\"; &#125;, isBoolean: function(o) &#123; return Object.prototype.toString.call(o) == \"[object Boolean]\"; &#125;, isString: function(o) &#123; return Object.prototype.toString.call(o) == \"[object String]\"; &#125;, isNumber: function(o) &#123; return Object.prototype.toString.call(o) == \"[object Number]\"; &#125;, isDocument: function() &#123; return Object.prototype.toString.call(o) == \"[object Document]\" || \"[object HTMLDocument]\"; &#125;&#125;------------------------------&gt;console.log(type.isArray([1,2,3]));&gt;true push()和pop() push() 向数组末尾添加任意个项并返回新数组的长度 pop() 从数组末尾移除最后一项，减少数组的length值 （返回的是移除的项） shift()和unshift() unshift() 向数组前端添加任意个项并返回新数组的长度 shift() 从数组前端移除第一项，减少数组的length值 （返回的是移除的项） 重排序 sort() reverse()12345function compare(a,b)&#123; return a-b;//升序 //return b-a; 或者在升序方法之后使用reverse()反转数组&#125;arr.sort(compare); 操作方法 concat() slice() splice()concat()concat() 方法用于连接两个或多个数组，不会改变原始数组。 slice()slice() 方法可从已有的数组中返回选定的元素，不会改变原始数组。 arrayObject.slice(start,end) 参数 描述 start 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 splice()splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目，会改变原始数组。 arrayObject.splice(index,howmany,item1,…..,itemX) 参数 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX 可选。向数组添加的新项目。 位置方法indexOf() indexOF() 从前往后查找，返回首次出现的位置（没有返回-1） lastindexOf() lastindexOf() 从后往前查找，返回首次出现的位置（没有返回-1） 迭代方法 迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。 every(): 对数组中的每一项运行给定的函数，如果该函数对每一项都返回true，则结果返回true。 filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 forEach(): 对数组中的每一项运行给定函数，这个方法没有返回值。 map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some(): 对数组中的每一项运行给定函数，如果该函数任意一项返回true，则返回true。 every()和some()123456789var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var everyResult = numbers.every(function(item, index, array) &#123; return (item &gt; 2);&#125;);var someResult = numbers.some(function(item) &#123; return (item &gt; 2);&#125;);console.log(everyResult); //falseconsole.log(someResult); //true filter()123456var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var filterResult = numbers.filter(function(item) &#123; return (item &gt; 2);&#125;);console.log(filterResult); \\\\[3, 4, 5, 4, 3] map()123456var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var mapResult = numbers.map(function(item) &#123; return (item * 2);&#125;);console.log(mapResult); //[2, 4, 6, 8, 10, 8, 6, 4, 2] forEach()1234var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.forEach(function(item, index, arr) &#123; //这里执行一些操作&#125;);","categories":[{"name":"汇总篇","slug":"汇总篇","permalink":"http://zc95.github.io/categories/汇总篇/"}],"tags":[{"name":"array","slug":"array","permalink":"http://zc95.github.io/tags/array/"}]},{"title":"自定义range滑块","slug":"rangeUI","date":"2017-11-17T11:06:48.000Z","updated":"2017-12-21T12:14:34.300Z","comments":true,"path":"2017/11/17/rangeUI/","link":"","permalink":"http://zc95.github.io/2017/11/17/rangeUI/","excerpt":"Range 链接 demo地址 github地址 简易版demo地址","text":"Range 链接 demo地址 github地址 简易版demo地址 导入CSS和JS（github地址里有）https://github.com/zc95/RangeSlider/blob/master/myCSS.css 12345678910111213141516171819202122232425262728293031323334353637383940p &#123; font-family: \"微软雅黑\"; letter-spacing: -1px; text-shadow: -2px -1px 1px #fff, 1px 2px 2px rgba(0, 0, 0, 0.2); font-weight: 300; font-size: 36px; margin: 10px;&#125;input[type=range] &#123;true-webkit-appearance: none;truewidth: 300px;trueborder-radius: 10px; /*这个属性设置使填充进度条时的图形为圆角*/truebackground: -webkit-linear-gradient(#2EB969, #2EB969) no-repeat;/*进度条的颜色*/truebackground-size: 0% 100%;&#125;input[type=range]:focus &#123;trueoutline: none;&#125;input[type=range]:hover &#123;truecursor:pointer;&#125;input[type=range]::-webkit-slider-runnable-track &#123;trueheight: 6px;trueborder-radius: 10px; /*将轨道设为圆角的*/ box-shadow: 0.2px 0.2px 1px 0.8px #cec8c8 inset; /*添加底部阴影*/&#125;input[type=range]::-webkit-slider-thumb &#123;true-webkit-appearance: none; cursor: pointer; height: 20px; width: 20px; margin-top:-6px; border-radius: 50%; background-color:white; box-shadow: 0px 0px 3px 1px #DEDEDE;&#125; ​ https://github.com/zc95/RangeSlider/blob/master/myJS.js 12345678910111213141516171819202122232425262728293031323334353637383940414243$.fn.RangeSlider = function(cfg)&#123; var userAgent = navigator.userAgent; var isWebkit = (userAgent.indexOf(\"AppleWebKit\") &gt;= 0); var isIE = isIE(); function isIE() &#123; var isIE = false; if (window.ActiveXObject || \"ActiveXObject\" in window) &#123; isIE = true; &#125; else &#123; isIE = (userAgent.indexOf(\"compatible\") &gt; -1 &amp;&amp; userAgent.indexOf(\"MSIE\") &gt; -1 &amp;&amp; !(userAgent.indexOf(\"Opera\") &gt; -1)); isIE = false; &#125; return isIE; &#125; this.sliderCfg = &#123; min: cfg &amp;&amp; !isNaN(parseFloat(cfg.min)) ? Number(cfg.min) : null, max: cfg &amp;&amp; !isNaN(parseFloat(cfg.max)) ? Number(cfg.max) : null, step: cfg &amp;&amp; Number(cfg.step) ? cfg.step : 1, callback: cfg &amp;&amp; cfg.callback ? cfg.callback : null &#125;; var $input = $(this); var min = this.sliderCfg.min; var max = this.sliderCfg.max; var step = this.sliderCfg.step; var callback = this.sliderCfg.callback; $input.attr('min', min).attr('max', max).attr('step', step); var event = null; if (isIE) &#123; event = \"change\"; &#125; else &#123; event = \"input\"; &#125; $input.bind(event, function(e)&#123; $input.attr('value', this.value); if (isWebkit) &#123; $input.css( 'background-size', this.value + '% 100%' ); &#125; if ($.isFunction(callback)) &#123; callback(this); &#125; &#125;);&#125;; ​ 使用1234&lt;p&gt; 进度条&amp;emsp;&lt;span id=\"num\"&gt;0&lt;/span&gt;%&lt;/p&gt;&lt;input type=\"range\" value=\"0\"&gt; 12345678910$(function() &#123; $('input').RangeSlider(&#123; step: 0.1, callback: change &#125;);&#125;);var change = function($input) &#123; /*内容可自行定义*/ $(\"#num\").text($('input').val());&#125;","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"column","slug":"column","date":"2017-11-10T16:30:14.000Z","updated":"2017-12-21T12:15:00.202Z","comments":true,"path":"2017/11/11/column/","link":"","permalink":"http://zc95.github.io/2017/11/11/column/","excerpt":"CSS3多列CSS3 可以将文本内容设计成像报纸一样的多列布局，如下实例： CSS3 多列属性 column-count column-gap column-rule-style column-rule-width column-rule-color column-rule column-span column-width","text":"CSS3多列CSS3 可以将文本内容设计成像报纸一样的多列布局，如下实例： CSS3 多列属性 column-count column-gap column-rule-style column-rule-width column-rule-color column-rule column-span column-width CSS3 创建多列column-count 属性指定了需要分割的列数 以下实例将 &lt;div&gt; 元素中的文本分为 3 列： 123456.newspaper&#123;true-moz-column-count:3; /* Firefox */true-webkit-column-count:3; /* Safari and Chrome */truecolumn-count:3;&#125; 1&lt;div class=\"newspaper\"&gt;....................&lt;/div&gt; 尝试一下 » CSS3 多列中列与列间的间隙column-gap 属性指定了列与列间的间隙 以下实例指定了列与列间的间隙为 40 像素： 12345678910.newspaper&#123;true-moz-column-count:3; /* Firefox */true-webkit-column-count:3; /* Safari and Chrome */truecolumn-count:3;true-moz-column-gap:40px; /* Firefox */true-webkit-column-gap:40px; /* Safari and Chrome */truecolumn-gap:40px;&#125; 1&lt;div class=\"newspaper\"&gt;....................&lt;/div&gt; 尝试一下 » CSS3 列边框column-rule-style 属性指定了列与列间的边框样式： 123456.newspaper&#123;true-webkit-column-rule-style: solid; /* Chrome, Safari, Opera */ -moz-column-rule-style: solid; /* Firefox */ column-rule-style: solid;&#125; 尝试一下 » column-rule-width 属性指定了两列的边框厚度： 12345div &#123; -webkit-column-rule-width: 1px; /* Chrome, Safari, Opera */ -moz-column-rule-width: 1px; /* Firefox */ column-rule-width: 1px;&#125; 尝试一下 » column-rule-color 属性指定了两列的边框颜色： 12345div &#123; -webkit-column-rule-color: lightblue; /* Chrome, Safari, Opera */ -moz-column-rule-color: lightblue; /* Firefox */ column-rule-color: lightblue;&#125; 尝试一下 » column-rule 属性是 column-rule-* 所有属性的简写。 以下实例设置了列直接的边框的厚度，样式及颜色： 12345div &#123; -webkit-column-rule: 1px solid lightblue; /* Chrome, Safari, Opera */ -moz-column-rule: 1px solid lightblue; /* Firefox */ column-rule: 1px solid lightblue;&#125; 尝试一下 » 指定元素跨越多少列以下实例指定 &lt;h2&gt; 元素跨越所有列： 1234h2 &#123; -webkit-column-span: all; /* Chrome, Safari, Opera */ column-span: all;&#125; 尝试一下 » 指定列的宽度column-width 属性指定了列的宽度。 1234div &#123; -webkit-column-width: 100px; /* Chrome, Safari, Opera */ column-width: 100px;&#125; 尝试一下 » CSS3 多列属性下表列出了所有 CSS3 的多列属性： 属性 描述 column-count 指定元素应该被分割的列数。 column-fill 指定如何填充列 column-gap 指定列与列之间的间隙 column-rule 所有 column-rule-* 属性的简写 column-rule-color 指定两列间边框的颜色 column-rule-style 指定两列间边框的样式 column-rule-width 指定两列间边框的厚度 column-span 指定元素要跨越多少列 column-width 指定列的宽度 columns 设置 column-width 和 column-count 的简写","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"css3","slug":"css3","permalink":"http://zc95.github.io/tags/css3/"},{"name":"布局","slug":"布局","permalink":"http://zc95.github.io/tags/布局/"}]},{"title":"类似Windows文件的布局问题","slug":"AdaptiveLayout","date":"2017-11-03T10:40:24.000Z","updated":"2017-12-21T12:15:20.306Z","comments":true,"path":"2017/11/03/AdaptiveLayout/","link":"","permalink":"http://zc95.github.io/2017/11/03/AdaptiveLayout/","excerpt":"问题如何做到类似windows文件的布局：无论如何改变窗口（屏幕）的大小，文件或者文件夹的大小都是固定的，不同的是一行显示的数目会有所变化； 百分比布局首先这类布局，肯定会先想到百分比的方法（最快的方法），在不同手机上看的话当然没区别，比如一行显示4个的话，那么一个就是25%，但如果放到ipad或者电脑上来看的话，就大的有些恐怖了 百分比加@media布局同上，我们可以用@media的方法来解决不同类型设备的差异问题，也就是多写几行css的问题","text":"问题如何做到类似windows文件的布局：无论如何改变窗口（屏幕）的大小，文件或者文件夹的大小都是固定的，不同的是一行显示的数目会有所变化； 百分比布局首先这类布局，肯定会先想到百分比的方法（最快的方法），在不同手机上看的话当然没区别，比如一行显示4个的话，那么一个就是25%，但如果放到ipad或者电脑上来看的话，就大的有些恐怖了 百分比加@media布局同上，我们可以用@media的方法来解决不同类型设备的差异问题，也就是多写几行css的问题 我的方法var eachWidth = $(document).width() / Math.floor($(document).width() / 80); 假如我想每个div都在80px左右，那么一行就可以放 $(document).width() / 80 个，用 Math.floor 向下取整之后可以去掉不满一个的零头，再用屏幕宽度除以这个取整后的个数，就能得到长度在80±10的eachWidth值了 下面是在控制台的不同手机屏幕大小下console出来的数据： 1234567891011121314$(document).width() / Math.floor($(document).width() / 80) //iPad--&gt; 85.33333333333333$(document).width() / Math.floor($(document).width() / 80) //iPhone 6 Plus--&gt; 82.8$(document).width() / Math.floor($(document).width() / 80) //iPhone 6--&gt; 93.75$(document).width() / Math.floor($(document).width() / 80) //iPhone 5--&gt; 80$(document).width() / Math.floor($(document).width() / 80) //Nexus 6P--&gt; 82.4 效果图 移动端 iPad","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"},{"name":"页面布局","slug":"页面布局","permalink":"http://zc95.github.io/tags/页面布局/"}]},{"title":"原生javascript和jquery的用法对比","slug":"jsAndJq","date":"2017-10-25T04:39:12.000Z","updated":"2017-12-26T13:11:47.795Z","comments":true,"path":"2017/10/25/jsAndJq/","link":"","permalink":"http://zc95.github.io/2017/10/25/jsAndJq/","excerpt":"选取元素12345678910// jQueryvar els = $('.el');// Nativevar els = document.querySelectorAll('.el');// Shorthandvar $ = function (el) &#123; return document.querySelectorAll(el);&#125; querySelectorAll方法返回的是NodeList对象，需要转换为数组。 1myList = Array.prototype.slice.call(myNodeList)","text":"选取元素12345678910// jQueryvar els = $('.el');// Nativevar els = document.querySelectorAll('.el');// Shorthandvar $ = function (el) &#123; return document.querySelectorAll(el);&#125; querySelectorAll方法返回的是NodeList对象，需要转换为数组。 1myList = Array.prototype.slice.call(myNodeList) 创建元素12345// jQueryvar newEl = $('&lt;div&gt;&lt;/div&gt;');// Nativevar newEl = document.createElement('div'); 添加事件1234567891011// jQuery$('.el').on('event', function() &#123;&#125;);// Native[].forEach.call(document.querySelectorAll('.el'), function (el) &#123; el.addEventListener('event', function() &#123; &#125;, false);&#125;); get/set属性1234567// jQuery$('.el').filter(':first').attr('key', 'value');$('.el').filter(':first').attr('key');// Nativedocument.querySelector('.el').setAttribute('key', 'value');document.querySelector('.el').getAttribute('key'); 添加和移除样式ClassDOM元素本身有一个可读写的className属性，可以用来操作class。 HTML 5还提供一个classList对象，功能更强大（IE 9不支持）。 123456789// jQuery$('.el').addClass('class');$('.el').removeClass('class');$('.el').toggleClass('class');// Nativedocument.querySelector('.el').classList.add('class');document.querySelector('.el').classList.remove('class');document.querySelector('.el').classList.toggle('class'); 追加元素尾部追加元素： 12345// jQuery$('.el').append($('&lt;div/&gt;'));// Nativedocument.querySelector('.el').appendChild(document.createElement('div')); 头部追加元素： 123456//jQuery$(‘.el’).prepend('&lt;div&gt;&lt;/div&gt;')//Nativevar parent = document.querySelector('.el');parent.insertBefore(\"&lt;div&gt;&lt;/div&gt;\",parent.childNodes[0]) 克隆元素12345// jQueryvar clonedEl = $('.el').clone();// Nativevar clonedEl = document.querySelector('.el').cloneNode(true); 移除元素123456789101112Remove// jQuery$('.el').remove();// Nativeremove('.el');function remove(el) &#123; var toRemove = document.querySelector(el); toRemove.parentNode.removeChild(toRemove);&#125; 获取父级元素12345// jQuery$('.el').parent();// Nativedocument.querySelector('.el').parentNode; 获取上一个/下一个元素（Prev/next element）1234567// jQuery$('.el').prev();$('.el').next();// Nativedocument.querySelector('.el').previousElementSibling;document.querySelector('.el').nextElementSibling; XHR and AJAX123456789101112131415161718192021222324252627// jQuery$.get('url', function (data) &#123;&#125;);$.post('url', &#123;data: data&#125;, function (data) &#123;&#125;);// Native// getvar xhr = new XMLHttpRequest();xhr.open('GET', url);xhr.onreadystatechange = function (data) &#123;&#125;xhr.send();// postvar xhr = new XMLHttpRequest()xhr.open('POST', url);xhr.onreadystatechange = function (data) &#123;&#125;xhr.send(&#123;data: data&#125;); 清空子元素123456//jQuery$(\"#elementID\").empty()//Nativevar element = document.getElementById(\"elementID\")while(element.firstChild) element.removeChild(element.firstChild); 检查是否有子元素12345//jQueryif (!$(\"#elementID\").is(\":empty\"))&#123;&#125;//Nativeif (document.getElementById(\"elementID\").hasChildNodes())&#123;&#125; $(document).readyDOM加载完成，会触发DOMContentLoaded事件，等同于jQuery的$(document).ready方法。 123document.addEventListener(\"DOMContentLoaded\", function() &#123; // ...&#125;); 数据储存jQuery对象可以储存数据。 12$(\"body\").data(\"foo\", 52);$(\"body\").data(\"foo\"); HTML 5有一个dataset对象，也有类似的功能（IE 10不支持），不过只能保存字符串。 12element.dataset.user = JSON.stringify(user);element.dataset.score = score; 动画jQuery的animate方法，用于生成动画效果。 1$foo.animate('slow', &#123; x: '+=10px' &#125;) jQuery的动画效果，很大部分基于DOM。但是目前，CSS 3的动画远比DOM强大，所以可以把动画效果写进CSS，然后通过操作DOM元素的class，来展示动画。 1foo.classList.add('animate') 如果需要对动画使用回调函数，CSS 3也定义了相应的事件。 12el.addEventListener(\"webkitTransitionEnd\", transitionEnded);el.addEventListener(\"transitionend\", transitionEnded);","categories":[{"name":"汇总篇","slug":"汇总篇","permalink":"http://zc95.github.io/categories/汇总篇/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://zc95.github.io/tags/jquery/"}]},{"title":"css换行问题","slug":"wordBreak","date":"2017-10-25T04:27:15.000Z","updated":"2017-12-21T12:15:55.326Z","comments":true,"path":"2017/10/25/wordBreak/","link":"","permalink":"http://zc95.github.io/2017/10/25/wordBreak/","excerpt":"css实现强制不换行/自动换行/强制换行 强制换行按单词自动换行 p { word-wrap:break-word; } 强制按英文字母断行 需要将行内元素设置为块级元素 p { word-break:break-all; }","text":"css实现强制不换行/自动换行/强制换行 强制换行按单词自动换行 p { word-wrap:break-word; } 强制按英文字母断行 需要将行内元素设置为块级元素 p { word-break:break-all; } 强制不换行强制不换行 p { white-space:nowrap; } 超出显示省略号 p { white-space:nowrap; text-overflow:ellipsis; overflow:hidden; } 一定要给文字的父容器 如果父容器是行级，一定要转成块级（一定要是 block，设置为 inline-block 无效） white-space: normal pre nowrap pre-wrap pre-line inherit ; white-space 属性设置如何处理元素内的空白 normal 默认。多个空白或者多个换行将被当一个空白或一个换行处理- pre 空白和换行会被浏览器保留。其行为方式类似 HTML 中的 pre 标签- nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止- pre-wrap 保留空白符序列，但是正常地进行换行 - pre-line 合并空白符序列，但是保留换行符- inherit 规定应该从父元素继承 white-space 属性的值word-break: normal break-all keep-all ; word-break 属性用来标明怎么样进行单词内的断句 normal：使用浏览器默认的换行规则- break-all:允许再单词内换行 - keep-all:只能在半角空格或连字符处换行","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"}]},{"title":"表头固定","slug":"amazingTable","date":"2017-10-23T16:15:16.000Z","updated":"2017-12-21T12:16:19.880Z","comments":true,"path":"2017/10/24/amazingTable/","link":"","permalink":"http://zc95.github.io/2017/10/24/amazingTable/","excerpt":"table的表头固定 ——— 上下滚动表头固定，左右滚动表头跟随滚动 关于表格固定如果数据不是很多，一般都是用两个表格，一个放thead，另一个放tbody，这个没难度就不再赘述了 如果数据很多就要考虑左右滚动的情况了","text":"table的表头固定 ——— 上下滚动表头固定，左右滚动表头跟随滚动 关于表格固定如果数据不是很多，一般都是用两个表格，一个放thead，另一个放tbody，这个没难度就不再赘述了 如果数据很多就要考虑左右滚动的情况了 方法一demo: http://jsrun.net/biiKp/show 同样是两个table，一个放thead，另一个放tbody，用两个div分别包裹起来 这两个div依赖于他们的的父容器进行absolute定位 theadDiv { position: absolute; left: 0; right: 0; overflow: hidden; //这里hidden是用于隐藏滚动条} tbodyDiv { position: absolute; top: 35px; left: 0; right: 0; bottom: 0; overflow: auto;} 给放置thead的div添加样式 overflow: hidden; ，表头不需要看到滚动条 给放置tbody的div添加样式 overflow: auto; ，表的主体需要滚动条 这时只需要在滚动下面的tbody时，同样滚动上面的thead就行 $(‘#tbodyDiv’).on(‘scroll’, function () { $(“#theadDiv”).scrollLeft($(‘#tbodyDiv’).scrollLeft()); }); }) 方法二demo: http://jsrun.net/2iiKp/show 大概思路就是 容器A 下面有 容器1（放置thead） 和 容器2（放置tbody） x轴滚动条属于 容器A ，滚动 容器1（放置thead） 和 容器2（放置tbody） y轴属于 容器2 ，滚动 tbody 这个方法有缺陷，就是y轴的滚动条必须要当x轴滚到最右边才看得到，当然Mac下无差（Mac下的滚动条不滚动的时候是隐藏的，而win系统下就会影响美观，但都不影响操作，毕竟我们有鼠标滚轮）","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"}]},{"title":"DOM","slug":"DOM","date":"2017-10-21T06:37:42.000Z","updated":"2017-12-21T12:16:39.916Z","comments":true,"path":"2017/10/21/DOM/","link":"","permalink":"http://zc95.github.io/2017/10/21/DOM/","excerpt":"为什么我们要尽量少的去操作DOM结构？ 前言在前端开发的过程中，javascript极为重要的一个功能就是对DOM对象的操作，无论增删改查在前端页面操作这一范围内都是比较消耗性能的。如何高效率的，便捷的操作DOM，这就是本文要讲述的，希望看完全文，你能知道如何更高效的通过原生js以及jQuery操作DOM元素。 性能影响 DOM修改导致的页面重绘repaint、重构reflow，重新排版是用户阻塞的操作，同时，如果频繁重排，CPU使用率也会猛涨 repaint意味着样式的改变比如div调整了背景色等，但是位置不变，只改变我们操作的元素 reflow意味着结构的改变，比如一堆元素堆叠，改变其中一个的宽高，那么相应的所有元素的位置都要改变 所以通常来看repaint的代价要远小于reflow，速度也更快","text":"为什么我们要尽量少的去操作DOM结构？ 前言在前端开发的过程中，javascript极为重要的一个功能就是对DOM对象的操作，无论增删改查在前端页面操作这一范围内都是比较消耗性能的。如何高效率的，便捷的操作DOM，这就是本文要讲述的，希望看完全文，你能知道如何更高效的通过原生js以及jQuery操作DOM元素。 性能影响 DOM修改导致的页面重绘repaint、重构reflow，重新排版是用户阻塞的操作，同时，如果频繁重排，CPU使用率也会猛涨 repaint意味着样式的改变比如div调整了背景色等，但是位置不变，只改变我们操作的元素 reflow意味着结构的改变，比如一堆元素堆叠，改变其中一个的宽高，那么相应的所有元素的位置都要改变 所以通常来看repaint的代价要远小于reflow，速度也更快 如何避免 能放到DOM操作之外的操作就放到外面，DOM操作要尽量少这是一个不好的事例： 12345var $obj = $(\"#obj\");var data = [&#123;\"id\":0,\"name\":\"a\"&#125;,&#123;\"id\":1,\"name\":\"b\"&#125;];for (var i = 0; i &lt; data.length; i++) &#123; $obj.append('&lt;option value=\"'+data[i].id+'\"&gt;'+data[i].name+'&lt;/option&gt;');&#125;; 更好的做法，使用容器存放临时变更，最后再一次性更新DOM： 1234567var $obj = $(\"#obj\");var data = [&#123;\"id\":0,\"name\":\"a\"&#125;,&#123;\"id\":1,\"name\":\"b\"&#125;];var tempStr = \"\";for (var i = 0; i &lt; data.length; i++) &#123; tempStr +=('&lt;option value=\"'+data[i].id+'\"&gt;'+data[i].name+'&lt;/option&gt;');&#125;;$obj.html(tempStr); 大范围操作先把容器隐藏，在其中操作完成后再显示这个也算是优化的一种，这原理涉及到浏览器加载和渲染的原理,简单说就是隐藏的元素其中不会产生reflow 样式操作不要注意修改属性，直接替换class这个还是比较容易理解的，你逐一修改要访问很多次，而替换class就相当于批量操作了，访问一次DOM就可以了,当然性能提高了 总结对于性能方面，平时应注意积累。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"},{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://zc95.github.io/tags/jquery/"},{"name":"DOM操作","slug":"DOM操作","permalink":"http://zc95.github.io/tags/DOM操作/"},{"name":"循环","slug":"循环","permalink":"http://zc95.github.io/tags/循环/"},{"name":"渲染","slug":"渲染","permalink":"http://zc95.github.io/tags/渲染/"},{"name":"性能","slug":"性能","permalink":"http://zc95.github.io/tags/性能/"}]},{"title":"文本框模糊查询","slug":"input","date":"2017-10-21T05:14:08.000Z","updated":"2018-02-12T13:52:49.367Z","comments":true,"path":"2017/10/21/input/","link":"","permalink":"http://zc95.github.io/2017/10/21/input/","excerpt":"文本框模糊匹配(纯html+css+jquery简单实现) ，自己写的一个小组件。 链接 demo地址 github地址 开始使用 引入css、jQuery 和 js（github里面有） 123$('#id').FuzzyQuery(&#123; 'msg': msg &#125;);","text":"文本框模糊匹配(纯html+css+jquery简单实现) ，自己写的一个小组件。 链接 demo地址 github地址 开始使用 引入css、jQuery 和 js（github里面有） 123$('#id').FuzzyQuery(&#123; 'msg': msg &#125;); 参数配置msg 是json数据（必须），fontSize 是模糊查询项的字体大小，height 是模糊查询项的高度12345$('#Name').FuzzyQuery(&#123; 'msg': msg, 'fontSize': '13px', 'height': '30px' &#125;); msg格式示例name 是文本，id 是标识1msg = [&#123; \"name\": \"苏州大学\", \"id\": \"szdx\" &#125;, &#123; \"name\": \"北京大学\", \"id\": \"bjdx\" &#125;, &#123; \"name\": \"南京大学\", \"id\": \"njdx\" &#125;, &#123; \"name\": \"清华大学\", \"id\": \"qhdx\" &#125;, &#123; \"name\": \"复旦大学\", \"id\": \"fddx\" &#125;, &#123; \"name\": \"浙江大学\", \"id\": \"zjdx\" &#125;, &#123; \"name\": \"上海交通大学\", \"id\": \"shjtdx\" &#125;, &#123; \"name\": \"武汉大学\", \"id\": \"whdx\" &#125;, &#123; \"name\": \"中国人民大学\", \"id\": \"zgrmdx\" &#125;, &#123; \"name\": \"中国科学技术大学\", \"id\": \"zgkxjsdx\" &#125;, &#123; \"name\": \"北京师范大学\", \"id\": \"bjsfdx\" &#125;]; html和CSS部分的一些细节 outline: none; outline （轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，为了美观应该去掉 box-sizing:border-box; 这可令浏览器呈现出带有指定宽度和高度的框，并把边框和内边距放入框中。 autocomplete=”off” autocomplete是form表单的属性，默认为on，其含义代表是否让浏览器自动记录之前输入的值，应该关闭记录","categories":[{"name":"demo","slug":"demo","permalink":"http://zc95.github.io/categories/demo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://zc95.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"http://zc95.github.io/tags/html/"},{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://zc95.github.io/tags/jquery/"}]},{"title":"javascript知识碎片","slug":"javascript","date":"2017-10-21T04:14:08.000Z","updated":"2018-02-08T11:31:27.881Z","comments":true,"path":"2017/10/21/javascript/","link":"","permalink":"http://zc95.github.io/2017/10/21/javascript/","excerpt":"记录每天学到的知识点或者遇到的问题 在 github 和 博客 同步更新","text":"记录每天学到的知识点或者遇到的问题 在 github 和 博客 同步更新 监听文本框输入比如模糊搜索时监听文本框输入，我们如果用 onchange ，那就只能在失去焦点的时候才能触发；如果用 onkeyup / onkeypress / onkeydown 这些，每次键盘按下弹起都会触发，这也不是我们想要的； 现在用oninput可以解决这些问题，还有onpropertychange（IE专用） onsearch 事件onsearch 事件在用户按下”ENTER（回车）” 按键或点击移动端键盘的放大镜（搜索）按钮时触发1&lt;input type=\"search\" onsearch=\"myFunction()\"&gt; HTML 5 autocomplete 属性autocomplete 属性规定表单是否应该启用自动完成功能。自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。1&lt;form autocomplete=\"on|off\"&gt; contenteditable=”true”div设置contenteditable=”true”，contenteditable 属性规定是否可编辑元素的内容。1&lt;p contenteditable=\"true\"&gt;这是一段可编辑的段落。请试着编辑该文本。&lt;/p&gt; javascript浅拷贝和深拷贝对于字符串类型，浅复制是对值的复制，对于对象来说，浅复制是对对象地址的复制，并没有开辟新的栈，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变，而深复制则是开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。 浅拷贝（shallow copy）1234var arr = ['a','b','c','d']; //原数组var temp = arr; //新的临时数组temp[1] = \"hello\"; //改变新数组的值//现在temp是[\"a\", \"hello\", \"c\", \"d\"]，原数组arr也是[\"a\", \"hello\", \"c\", \"d\"] 深拷贝（deep copy）jquery的 $.extend() 第一个参数是布尔值，用来设置是否深度拷贝的123var arr = ['a','b','c','d'];var shallowtemp = $.extend([],arr); //浅拷贝var deeptemp = $.extend(true,[],arr); //深拷贝 还有一些奇葩又简单粗暴的姿势，有局限性，慎用。。。123var temp = JSON.parse(JSON.stringify(arr)); （不过这有局限性,原型链没了，所属的类没了）var temp = arr.slice(0); （只适合数组这种简单的拷贝，不适合json对象之类）var temp = arr.concat([]); （只适合数组这种简单的拷贝，不适合json对象之类） js删除数组某元素的方法splice这种方式数组长度相应改变,但是原来的数组索引也相应改变123var arr = ['a','b','c','d'];arr.splice(arr.indexOf('b'),1);//splice结果返回[\"b\"]，原数组变成[\"a\", \"c\", \"d\"] deletedelete删除掉数组中的元素后，会把该下标出的值置为 undefined ,数组的长度不会变123var arr = ['a','b','c','d'];delete arr[1];//delete返回true，原数组变成[\"a\", empty, \"c\", \"d\"]，arr[1]返回undefined pdf.js在 ios10 的app中无法打开github：https://github.com/mozilla/pdf.js解决方法 修改/web/compatibility.js：123456var isIPhone = /iPhone/.test(navigator.userAgent);var isIPad = /iPad/.test(navigator.userAgent);if (isSafari || isOldAndroid || isIPhone || isIPad) &#123; PDFJS.disableRange = true; PDFJS.disableStream = true;&#125; input只能输入数字12&lt;input type=\"number\"/&gt;&lt;!-- 这个方法可以输入E和e (原因是e在数学上代表2.71828，所以它也还是一个数字) --&gt; 12&lt;input type=\"text\" onkeyup=\"value=value.replace(/[^\\d]/g,'')\" /&gt;&lt;input type=\"text\" onkeyup=\"value=value.replace(/\\D/g,'')\" /&gt; 不用Number、parseInt和parseFloat和方法把”1″字符串转换成数字12var a = \"1\";console.log(+a); 随机颜色12\"#\"+Math.floor(Math.random() * (2 &lt;&lt; 23)).toString(16);\"#\"+(~~(Math.random()*(1&lt;&lt;24))).toString(16) ({a ,b}) =&gt;（{a,b}）123a =1;b=3;(&#123;a ,b&#125;)// &#123;a: 1, b: 3&#125; 金钱格式化1234var test1 = '1234567890';var format = test1.replace(/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g, ',')//'123456789.00'.replace(/\\d(?=(?:\\d&#123;3&#125;)+\\b)/g,',')console.log(format) // 1,234,567,890 123456var test1 = '1234567890';function formatCash(str) &#123; return str.split('').reverse().reduce((prev, next, index) =&gt; &#123; return ((index % 3) ? next : (next + ',')) + prev &#125;);&#125;console.log(formatCash('1234567890')) // 1,234,567,890 将n维数组破开成一维123var arr = [1, [2, 3], [4, 5, [6,7,[8]]], [9], 10];var arr1 = arr.join(',').split(',');console.log(arr1); //[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"] 1([1, [2, 3], [4, 5, [6,7,[8]]], [9], 10]+'').split(',') 123var arr = [1, [2, 3], [4, 5, [6,7,[8]]], [9], 10];var arr1 = arr.toString().split(',');console.log(arr1); //[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"] 1[1,...[2,3],...[4,5,...[6, 7,...[8]]],...[9],...[10]] 1eval('['+arr+']') 1[].concat(...arr) 数组去重的几种方法12345678var arr = [1, 4, 7, 4, 3, 2, 1, 4, 7];var newArr =[];for(i in arr)&#123;if(!newArr.includes(arr[i]))&#123;truenewArr.push(arr[i]); &#125;&#125;console.log(newArr); 12345678var arr = [1, 4, 7, 4, 3, 2, 1, 4, 7];var newArr =[];for (e in arr) &#123; if (arr.indexOf(arr[e]) == e) &#123; newArr.push(arr[e]) &#125;&#125;console.log(newArr); 123var arr = [1, 4, 7, 4, 3, 2, 1, 4, 7];var newArr = arr.reduce((newArr, current) =&gt; &#123;if(newArr.indexOf(current) === -1) &#123;newArr.push(current);&#125;return newArr;&#125;, []);console.log(newArr); 123var arr = [1, 4, 7, 4, 3, 2, 1, 4, 7];var newArr = Array.from(new Set(arr));console.log(newArr); 1[...new Set([1, 4, 7, 4, 3, 2, 1, 4, 7])] 123[1, 4, 7, 4, 3, 2, 1, 4, 7].filter(function(ele,index,array)&#123; return index===array.indexOf(ele)&#125;) 在数组中找出最小值、最大值123456var arr = [23, 45, 40, 30, 12];var temp = arr[0];arr.forEach(function(value)&#123; temp = value &gt; temp ? value : temp;&#125;)console.log(temp); 123456var arr = [23, 45, 40, 30, 12];var temp = arr.shift();arr.forEach((value) =&gt; &#123; temp = value &gt; temp ? value : temp;&#125;);console.log(temp); 123var arr = [23, 45, 40, 30, 12];Math.max(...arr);Math.min(...arr); 扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法 12345678// ES5 的写法Math.max.apply(null, [23, 45, 40, 30, 12]) // ES6 的写法Math.max(...[23, 45, 40, 30, 12]) // 等同于Math.max(23, 45, 40, 30, 12); 交换两个变量的值12345var a = 4, b = 6;var temp = a;a = b;b = temp;console.log(a , b); 123var a = 4, b = 6;[a, b] = [b, a];console.log(a, b); 一行代码实现星级评分123\"★★★★★☆☆☆☆☆\".slice(5 - rate, 10 - rate); //rate是0～5的整数//或者：\"★\".repeat(rate) + \"☆\".repeat(5-rate); 向下取整的几种方式12345~~2.332.33 | 02.33 &gt;&gt; 02.33 ^ 0Math.floor(2.33); 统计字符串中相同字符出现的次数123var arr = 'abcdaabc';var info = arr.split('').reduce((p, k) =&gt; (p[k]++ || (p[k] = 1), p), &#123;&#125;);console.log(info); //&#123; a: 3, b: 2, c: 2, d: 1 &#125; =&gt; 箭头函数=&gt;是es6语法中的arrow function 🔎详情 12345(x) =&gt; x + 6//等价于：function(x)&#123; return x + 6;&#125; reduce()方法🔎详情1 🔎详情2 1234//等价于：var arr = [0,1,2,3,4]; arr.reduce(function (preValue,curValue,index,array) &#123; return preValue + curValue; &#125;); // 10 slice、repeat12345\"★★★★★☆☆☆☆☆\".slice(5 - rate, 10 - rate);\"★\".repeat(rate) + \"☆\".repeat(5-rate);//以上两种方法都可以实现简易的评分//arrayObject.slice(start,end) 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。//string.repeat(n) 将一个字符串重复自身n次 Object.keys()123var obj = &#123;'ssss':'w','dddd':'wd','fff':'f'&#125;; console.log(Object.keys(obj));//[\"ssss\", \"dddd\", \"fff\"] Array.prototype.filter()🔎详情 1234567891011var arr = [23,73,2,215,6]arr.filter(function(i)&#123;return i&gt;50&#125;)// [73, 215]var arr = [23,73,2,215,6]function compares(i)&#123;return i&gt;50&#125;arr.filter(compares)// [73, 215]var arr = [23,73,2,215,6]arr.filter((i) =&gt; i&gt;50) 根据text绑定select123456$(\"#xxx\").find(\"option\").each(function (data) &#123; var $this = $(this); if ($this.text() == \"xxxx\") &#123; $this.attr(\"selected\", true); &#125;&#125;); 毛玻璃效果12345678.blur &#123; filter: url(blur.svg#blur); /* FireFox, Chrome, Opera */ -webkit-filter: blur(10px); /* Chrome, Opera */ -moz-filter: blur(10px); -ms-filter: blur(10px); filter: blur(10px); filter: progid:DXImageTransform.Microsoft.Blur(PixelRadius=10, MakeShadow=false); /* IE6~IE9 */&#125; 移动端监听键盘弹出123456789var clientHeight = document.documentElement.clientHeight; $(window).on('resize', function () &#123; var nowClientHeight = document.documentElement.clientHeight; if (clientHeight &gt; nowClientHeight) &#123; //键盘弹出的事件处理 &#125; else &#123; //键盘收起的事件处理 &#125; &#125;); 修改jquery的关键字,当和别的框架有冲突时1&lt;script&gt;var jq = jQuery.noConflict();&lt;/script&gt; textarea换行的保存和赋值12str.replace(/\\n/g, \"&lt;br/&gt;\");str.replace(/&lt;br\\s*\\/?&gt;/gi, \"\\n\")); 连接起来的字符串变成一个变量123var index = 1;eval(\"xx\"+index)//这样取到的的就不是\"xx1\"这样的字符串，而是变量xx1的值 从数组里随机取一项1arr[Math.floor(Math.random()*arr.length)] 阻止浏览器默认的右键点击事件123window.document.oncontextmenu = function () &#123;return false;&#125; 左击右击事件123456789function clickMe() &#123;var event = event ? event : window.event;if (1 == event.which) &#123;//左击&#125;if (3 == event.which) &#123;//右击&#125;&#125; 循环时候去掉最后一个逗号12345var json = eval(msg), arr = [];for (var k in json[0]) &#123;arr.push(k + \"：\" + json[0][k] + \"条\");&#125;$('#dataNum').html(arr.join('，')); 判断是否存在id为item元素12345if($('#item').length!=0)&#123;//因为jquery获取的元素是一个集合，看长度是否为0就可以知道是不是存在//有元素&#125;else&#123;//没有元素&#125; 生成区间随机数123function getRandom(m,n)&#123;return Math.floor(Math.random()*(n-m+1)+m)&#125; 小数转为百分数1Number(point*100).toFixed(2)+\"%\"; trim() 去掉前后空白123456789101112//去左空格;function ltrim(s)&#123;return s.replace(/(^\\s*)/g, \"\");&#125;//去右空格;function rtrim(s)&#123;return s.replace(/(\\s*$)/g, \"\");&#125;//去左右空格;function trim(s)&#123;return s.replace(/(^\\s*)|(\\s*$)/g, \"\");&#125; 数组去重123456789function QuChong(arr)&#123;var newArr =[];for(i in arr)&#123;if(!newArr.includes(arr[i]))&#123;newArr.push(arr[i]);&#125;&#125;return newArr;&#125; reverse()1reverse();用于翻转数组，该方法会改变原来的数组，而不会创建新的数组。 sort()123456function sortNumber(a,b)&#123;return a - b;//升序//return b - a;//倒序 或者升序之后用 reverse() 翻转数组&#125;arr.sort(sortNumber); 找出元素 item 在给定数组 arr 中的位置123function indexOf(arr, item) &#123;return arr.indexOf(item)&#125; 计算给定数组 arr 中所有元素的总和1234567891011计算给定数组 arr 中所有元素的总和function sum(arr) &#123;var hehe=0;for(e in arr)&#123;hehe += arr[e];&#125;return hehe;&#125;function sum(arr) &#123;return eval(arr.join('+'));&#125; 移除数组 arr 中的所有值与 item 相等的元素1234567891011121314151617移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组function remove(arr, item) &#123;var arr2 =[];for(e in arr)&#123;if(arr[e] != item)&#123;arr2.push(arr[e]);&#125;&#125;return arr2;&#125;function remove(arr, item) &#123;var newArr = arr.slice(0);while(newArr.indexOf(item)!=-1)&#123;newArr.splice(newArr.indexOf(item),1);&#125;return newArr;&#125; 在数组 arr 末尾添加元素 item12345678在数组 arr 末尾添加元素 item。不要直接修改数组 arr，结果返回新的数组function append(arr, item) &#123;return arr.concat([item]);&#125;function append(arr, item) &#123;var newArr = arr.slice(0);return newArr.push(item);&#125; 删除数组 arr 最后一个元素12345678删除数组 arr 最后一个元素。不要直接修改数组 arr，结果返回新的数组function truncate(arr) &#123;var newArr = arr.slice(0);newArr.pop();//newArr.splice(newArr.length-1,1);//newArr.splice(newArr.length-1);return newArr;&#125; 在数组 arr 开头添加元素 item123456789在数组 arr 开头添加元素 item。不要直接修改数组 arr，结果返回新的数组function prepend(arr, item) &#123;return [item].concat(arr);&#125;function prepend(arr, item) &#123;var newArr = arr.slice(0);newArr.unshift(item);return newArr;&#125; 删除数组 arr 第一个元素1234删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组function curtail(arr) &#123;return arr.slice(1);&#125; 合并数组 arr1 和数组 arr21234合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组function concat(arr1, arr2) &#123;return arr1.concat(arr2);&#125; 在数组 arr 的 index 处添加元素 item123456在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组function insert(arr, item, index) &#123;var newArr = arr.slice(0);newArr.splice(index,0,item);return newArr;&#125; 统计数组 arr 中值等于 item 的元素出现的次数12345678910统计数组 arr 中值等于 item 的元素出现的次数function count(arr, item) &#123;var c=0;for(e in arr)&#123;if(arr[e]==item)&#123;c++;&#125;&#125;return c;&#125; 生成m到n的区间随机数12345生成m到n的区间随机数function getRand(m, n) &#123;var random = Math.floor(Math.random() * (n - m + 1) + m);return random;&#125; 检查数组里是否包含了某值12检查数组里是否包含了某值arr.includes(item);//结果返回true和false 编写一个javscript函数 fn123456789101112131415161718192021222324252627编写一个javscript函数 fn，该函数有一个参数 n(数字类型)，其返回值是一个数组，该数组内是 n 个随机且不重复的整数，且整数取值范围是 [2, 32]。//fn函数function fn(n) &#123;var arr = [];for (var i = 0; i &lt; n; i++) &#123;var rnd = getRand(2, 32);if (arr.includes(rnd)) &#123;i--;//减一是因为如果第i次循环的时候如果数组有了改值，就重新走一遍&#125; else &#123;arr.push(rnd);&#125;&#125;return arr;&#125;//生成区间随机数function getRand(m, n) &#123;var random = Math.floor(Math.random() * (n - m + 1) + m);return random;&#125;//检查是否重复,这里直接用了 arr.includes(e)function checkInArr(e,arr)&#123;if(arr.indexOf(e)==-1)&#123;return false;&#125;return true;&#125;//console.log(fn(5)); 打乱一个数组12345678910111213141516171819randomArr.sort(function () &#123; return Math.random() &gt; 0.5 ? -1 : 1; &#125;);## 计算给定数组 arr 中所有元素的总和```javascript//一般的方法function sum(arr) &#123;var sum = 0;for(var i =0;i&lt;arr.length;i++)&#123;sum = sum +arr[i];&#125;return sum;&#125;//或者可以这样function sum(arr) &#123;return eval(arr.join(\"+\"))&#125; checkbox的一些用法1234$(\"input[name='WeiZhi']\"); //选取name为xx的元素$(\"input[type='checkbox']\").prop('checked',true); //设置checkbox选中$(\"input[type='checkbox']\").attr('checked'); //两种结果 \"checked\"和undefined，注意引号！$(\"input[name='WeiZhi']:checked\").length; // 选中的个数 小数转百分数123function toPercent(point) &#123;return Number(point * 100).toFixed(2) + \"%\";//保留2位小数&#125; 获取事件源12345function test()&#123;var event = event? event: window.event;var srcObj = ((event.srcElement)?event.srcElement:event.target);alert($(srcObj));&#125; 查看的绑定123456var json = eval(msg);if (json.length &gt; 0) &#123;for (var key in json[0]) &#123;$(\"#\" + key).text(json[0][key]);&#125;&#125; 获取选中的下拉列表的value和text123var index = $('#HuoJia')[0].selectedIndex; // 选中索引var HuoJia = $('#HuoJia')[0].options[index].text; // 选中文本$(\"#HuoJia\").find(\"option:selected\").text() //简洁 join, split, splice, substring的区别1234join(',')是将数组用逗号隔开，转化为字符串split('-')是以字符串中的-符号转化为数组splice(3,1)是返回 从下标索引为3的位置切割出长度为1的字符str.substring(3,5)是截取两个指定下标位置的字符串，这个是下标为3和5的位置 回到顶部123456789101112$(window).scroll(function () &#123;var scrollt = document.documentElement.scrollTop + document.body.scrollTop;if ( scrollt &gt; 700 )&#123;$(\".to-top\").fadeIn(500);&#125; else &#123;$(\".to-top\").fadeOut(500);&#125;&#125;);$(\".to-top\").click(function()&#123;$(\"html,body\").animate(&#123;scrollTop: 0&#125;, 1000);&#125;); enter键代替按钮点击123456document.onkeydown = function (event) &#123;var e = event || window.event || arguments.callee.caller.arguments[0];if (e &amp;&amp; e.keyCode == 13) &#123; // enter 键Login();&#125;&#125;","categories":[{"name":"汇总篇","slug":"汇总篇","permalink":"http://zc95.github.io/categories/汇总篇/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://zc95.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://zc95.github.io/tags/jquery/"}]},{"title":"在Mac下通过Hexo在Github上搭建博客（入门篇）","slug":"hexoBlog","date":"2017-10-20T13:48:28.000Z","updated":"2017-12-21T12:17:50.595Z","comments":true,"path":"2017/10/20/hexoBlog/","link":"","permalink":"http://zc95.github.io/2017/10/20/hexoBlog/","excerpt":"Hexo 快速，简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。Hexo支持Github Flavored Markdown的所有功能，甚至可以整合Octopress的大多数插件，并自己也拥有强大的插件系统。 Hexo github Node.js Git markdown themes bash命令 npm SSH 什么是Hexo？ Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 Markdown（或其他渲染引擎，之后会解释什么是Markdown）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 前期准备安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js （安装Recommended For Most Users那个版本） Git","text":"Hexo 快速，简洁且高效的博客框架，让上百个页面在几秒内瞬间完成渲染。Hexo支持Github Flavored Markdown的所有功能，甚至可以整合Octopress的大多数插件，并自己也拥有强大的插件系统。 Hexo github Node.js Git markdown themes bash命令 npm SSH 什么是Hexo？ Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 Markdown（或其他渲染引擎，之后会解释什么是Markdown）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 前期准备安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js （安装Recommended For Most Users那个版本） Git 安装Hexo 当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：命令就是你的Launchpad里叫 终端 的app，相当于win的cmd以下出现的$都不是命令的一部分 $ npm install -g hexo-cli全局安装 hexo 模块， 如果下面的操作报错则需要卸载 hexo：$ npm uninstall hexo 再重新安装 hexo：$ sudo npm install -g hexo输入管理员密码（Mac登录密码）即开始安装 创建博客目录初始化, 在指定目录中创建文件目录，以 blog 为例： $ hexo init blog blog是你建立的文件夹名称，cd到blog文件夹下，安装npm： $ cd blog $ npm install 创建一篇新文章以创建博客 firstBlog为例，标题中包含空格需要用引号将标题引起来 $ hexo new firstBlog执行该命令后在source/_posts目录下生成文件 生成博客页面 $ hexo generate执行该命令后会生成public目录 $ hexo sever执行命令后启动服务，访问http://localhost:4000/可查看博客 注意： 之后每次修改完你的博客或者配置内容，都需要用$ hexo sever来开启hexo服务器预览 按 Ctrl+C 停止服务器，以便于进行其他操作 关联Github在进行这一步时你需要一个github账号，到 github官网 用邮箱注册就行，名字尽量简短有意义，我的github地址：https://github.com/zc95 创建仓库登录你的Github帐号，新建仓库，一定要是名为 用户名.github.io 的固定写法（如 zc95.github.io ），我的仓库地址：https://github.com/zc95/zc95.github.io 上传到 github首次使用配置： $ npm install hexo-deplorer-git –save安装 hexo-deplorer-git 打开新建的blog文件夹，找到 _config.yml 配置文件，用记事本打开，Ctrl+F来搜索deploy，type改为git，repository改为你自己的仓库地址，在配置博客站点的_config.yml文件时（包括theme主题站点中的_config.yml），在所有的冒号: 后边都要加一个空格，否则执行hexo命令会报错，切记 切记 deploy:type: gitrepository: 你的仓库地址branch: master ok，可以尽情装逼了。。。 hexo g == hexo generate #生成页面文件 hexo s == hexo server #启动服务预览 hexo d == hexo deploy # 部署到GitHub 常用命令 git clone #克隆主题时用到 cd blog #进入blog文件夹 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g == hexo generate #生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy # 部署 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d #你应该看得懂… 关于作者1234var author = &#123; Name : \"张成\", Blog : \"http://zc95.github.io\"&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://zc95.github.io/categories/技术篇/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://zc95.github.io/tags/Hexo/"},{"name":"github","slug":"github","permalink":"http://zc95.github.io/tags/github/"},{"name":"Node.js","slug":"Node-js","permalink":"http://zc95.github.io/tags/Node-js/"},{"name":"markdown","slug":"markdown","permalink":"http://zc95.github.io/tags/markdown/"},{"name":"npm","slug":"npm","permalink":"http://zc95.github.io/tags/npm/"},{"name":"博客","slug":"博客","permalink":"http://zc95.github.io/tags/博客/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-18T16:10:04.000Z","updated":"2017-12-21T12:18:09.638Z","comments":true,"path":"2017/10/19/hello-world/","link":"","permalink":"http://zc95.github.io/2017/10/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}