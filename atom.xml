<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张成的学习笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zc95.github.io/"/>
  <updated>2018-05-15T16:09:39.947Z</updated>
  <id>http://zc95.github.io/</id>
  
  <author>
    <name>张成</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 中的 call、apply、bind 深入理解</title>
    <link href="http://zc95.github.io/2018/05/16/thisapplycallbind/"/>
    <id>http://zc95.github.io/2018/05/16/thisapplycallbind/</id>
    <published>2018-05-15T16:08:25.000Z</published>
    <updated>2018-05-15T16:09:39.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this、apply、call、bind"><a href="#this、apply、call、bind" class="headerlink" title="this、apply、call、bind"></a>this、apply、call、bind</h1><p>之前在公司也做过关于this、apply、call、bind的PPT分享，在这里整理一下这几个知识点。</p><h1 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h1><p>首先必须要说的是，<strong>this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁</strong>，<strong>实际上this的最终指向的是那个调用它的对象（</strong>这句话有些问题，后面会解释为什么会有问题，虽然网上大部分的文章都是这样说的，虽然在很多情况下那样去理解不会出什么问题，但是实际上那样理解是不准确的，所以在你理解this的时候会有种琢磨不透的感觉<strong>）</strong>，那么接下来我会深入的探讨这个问题。</p><p>为什么要学习this？如果你学过函数式编程，面向对象编程，那你肯定知道干什么用的，如果你没有学过，那么暂时可以不用看这篇文章，当然如果你有兴趣也可以看看，毕竟这是js中必须要掌握的东西。    </p><p>下面我们来看一个最简单的例子：<br>例 1：</p><pre><code class="javascript">    var name = &quot;windowsName&quot;;    function a() {        var name = &quot;Cherry&quot;;        console.log(this.name);          // windowsName        console.log(&quot;inner:&quot; + this);    // inner: Window    }    a();    console.log(&quot;outer:&quot; + this)         // outer: Window</code></pre><p>这个相信大家都知道为什么 log 的是 windowsName，因为根据刚刚的那句话“<strong>this 永远指向最后调用它的那个对象</strong>”，我们看最后调用 <code>a</code> 的地方 <code>a();</code>，前面没有调用的对象那么就是全局对象 window，这就相当于是 <code>window.a()</code>；注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 <code>undefined</code>，那么就会报错 <code>Uncaught TypeError: Cannot read property &#39;name&#39; of undefined</code>。</p><p>再看下这个例子：<br>例 2：</p><pre><code class="javascript">    var name = &quot;windowsName&quot;;    var a = {        name: &quot;Cherry&quot;,        fn : function () {            console.log(this.name);      // Cherry        }    }    a.fn();</code></pre><p>在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。是不是有一点清晰了呢~</p><p>我们做一个小小的改动：<br>例 3：</p><pre><code class="javascript">var name = &quot;windowsName&quot;;    var a = {        name: &quot;Cherry&quot;,        fn : function () {            console.log(this.name);      // Cherry        }    }    window.a.fn();</code></pre><p>这里打印 Cherry 的原因也是因为刚刚那句话“<strong>this 永远指向最后调用它的那个对象</strong>”，最后调用它的对象仍然是对象 a。</p><p>我们再来看一下这个例子：<br>例 4：</p><pre><code class="javascript">    var name = &quot;windowsName&quot;;    var a = {        // name: &quot;Cherry&quot;,        fn : function () {            console.log(this.name);      // undefined        }    }    window.a.fn();</code></pre><p>这里为什么会打印 <code>undefined</code> 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 <code>this.name</code>的值是 <code>undefined</code>。</p><p>这个例子还是说明了：<strong>this 永远指向最后调用它的那个对象</strong>，因为最后调用 fn 的对象是 a，所以就算 a 中没有 name 这个属性，也不会继续向上一个对象寻找 <code>this.name</code>，而是直接输出 <code>undefined</code>。</p><p>再来看一个比较坑的例子：<br>例 5：</p><pre><code class="javascript">    var name = &quot;windowsName&quot;;    var a = {        name : null,        // name: &quot;Cherry&quot;,        fn : function () {            console.log(this.name);      // windowsName        }    }    var f = a.fn;    f();</code></pre><p>这里你可能会有疑问，为什么不是 <code>Cherry</code>，这是因为虽然将 a 对象的 fn 方法赋值给变量 f 了，但是没有调用，再接着跟我念这一句话：“<strong>this 永远指向最后调用它的那个对象</strong>”，由于刚刚的 f 并没有调用，所以 <code>fn()</code> 最后仍然是被 window 调用的。所以 this 指向的也就是 window。</p><p>由以上五个例子我们可以看出，this 的指向并不是在创建的时候就可以确定的，在 es5 中，永远是<strong>this 永远指向最后调用它的那个对象</strong>。</p><p>再来看一个例子：<br>例 6：</p><pre><code class="javascript">    var name = &quot;windowsName&quot;;    function fn() {        var name = &#39;Cherry&#39;;        innerFunction();        function innerFunction() {            console.log(this.name);      // windowsName        }    }    fn()</code></pre><p>读到现在了应该能够理解这是为什么了吧(oﾟ▽ﾟ)o。</p><h1 id="怎么改变-this-的指向"><a href="#怎么改变-this-的指向" class="headerlink" title="怎么改变 this 的指向"></a>怎么改变 this 的指向</h1><p>改变 this 的指向我总结有以下几种方法：</p><ul><li>使用 ES6 的箭头函数</li><li>在函数内部使用 <code>_this = this</code></li><li>使用 <code>apply</code>、<code>call</code>、<code>bind</code></li><li>new 实例化一个对象</li></ul><p>例 7：</p><pre><code class="javascript">    var name = &quot;windowsName&quot;;    var a = {        name : &quot;Cherry&quot;,        func1: function () {            console.log(this.name)             },        func2: function () {            setTimeout(  function () {                this.func1()            },100);        }    };    a.func2()     // this.func1 is not a function</code></pre><p>在不使用箭头函数的情况下，是会报错的，因为最后调用 <code>setTimeout</code> 的对象是 window，但是在 window 中并没有 func1 函数。</p><p>我们在改变 this 指向这一节将把这个例子作为 demo 进行改造。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>众所周知，ES6 的箭头函数是可以避免 ES5 中使用 this 的坑的。<strong>箭头函数的 this 始终指向函数定义时的 this，而非执行时。</strong>，箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。</p><p>例 8 ：</p><pre><code class="javascript">    var name = &quot;windowsName&quot;;    var a = {        name : &quot;Cherry&quot;,        func1: function () {            console.log(this.name)             },        func2: function () {            setTimeout( () =&gt; {                this.func1()            },100);        }    };    a.func2()     // Cherry</code></pre><h2 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 <code>_this = this</code></h2><p>如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 <code>_this</code> 中，然后在函数中都使用这个 <code>_this</code>，这样 <code>_this</code> 就不会改变了。<br>例 9：</p><pre><code class="javascript">    var name = &quot;windowsName&quot;;    var a = {        name : &quot;Cherry&quot;,        func1: function () {            console.log(this.name)             },        func2: function () {            var _this = this;            setTimeout( function() {                _this.func1()            },100);        }    };    a.func2()       // Cherry</code></pre><p>这个例子中，在 func2 中，首先设置 <code>var _this = this;</code>，这里的 <code>this</code> 是调用 <code>func2</code> 的对象 a，为了防止在 <code>func2</code> 中的 setTimeout 被 window 调用而导致的在 setTimeout 中的 this 为 window。我们将 <code>this(指向变量 a)</code> 赋值给一个变量 <code>_this</code>，这样，在 <code>func2</code> 中我们使用 <code>_this</code> 就是指向对象 a 了。</p><h2 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h2><p>使用 apply、call、bind 函数也是可以改变 this 的指向的，原理稍后再讲，我们先来看一下是怎么实现的：</p><h3 id="使用-apply"><a href="#使用-apply" class="headerlink" title="使用 apply"></a>使用 apply</h3><p>例 10：</p><pre><code class="javascript">    var a = {        name : &quot;Cherry&quot;,        func1: function () {            console.log(this.name)        },        func2: function () {            setTimeout(  function () {                this.func1()            }.apply(a),100);        }    };    a.func2()            // Cherry</code></pre><h3 id="使用-call"><a href="#使用-call" class="headerlink" title="使用 call"></a>使用 call</h3><p>例 11：</p><pre><code class="javascript">    var a = {        name : &quot;Cherry&quot;,        func1: function () {            console.log(this.name)        },        func2: function () {            setTimeout(  function () {                this.func1()            }.call(a),100);        }    };    a.func2()            // Cherry</code></pre><h3 id="使用-bind"><a href="#使用-bind" class="headerlink" title="使用 bind"></a>使用 bind</h3><p>例 12：</p><pre><code class="javascript">    var a = {        name : &quot;Cherry&quot;,        func1: function () {            console.log(this.name)        },        func2: function () {            setTimeout(  function () {                this.func1()            }.bind(a)(),100);        }    };    a.func2()            // Cherry</code></pre><h1 id="apply、call、bind-区别"><a href="#apply、call、bind-区别" class="headerlink" title="apply、call、bind 区别"></a>apply、call、bind 区别</h1><p>刚刚我们已经介绍了 apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。</p><p>在 <a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fapply" target="_blank" rel="external">MDN</a> 中定义 apply 如下；</p><blockquote><p>apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数</p></blockquote><p>语法：</p><blockquote><p>fun.apply(thisArg, [argsArray])</p></blockquote><ul><li>thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</li><li>argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。</li></ul><h2 id="apply-和-call-的区别"><a href="#apply-和-call-的区别" class="headerlink" title="apply 和 call 的区别"></a>apply 和 call 的区别</h2><p>其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。</p><p>call 的语法为：</p><pre><code class="javascript">fun.call(thisArg[, arg1[, arg2[, ...]]])</code></pre><p>所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。</p><p>例 13：</p><pre><code class="javascript">    var a ={        name : &quot;Cherry&quot;,        fn : function (a,b) {            console.log( a + b)        }    }    var b = a.fn;    b.apply(a,[1,2])     // 3</code></pre><p>例 14：</p><pre><code class="javascript">    var a ={        name : &quot;Cherry&quot;,        fn : function (a,b) {            console.log( a + b)        }    }    var b = a.fn;    b.call(a,1,2)       // 3</code></pre><h2 id="bind-和-apply、call-区别"><a href="#bind-和-apply、call-区别" class="headerlink" title="bind 和 apply、call 区别"></a>bind 和 apply、call 区别</h2><p>我们先来将刚刚的例子使用 bind 试一下</p><pre><code class="javascript">    var a ={        name : &quot;Cherry&quot;,        fn : function (a,b) {            console.log( a + b)        }    }    var b = a.fn;    b.bind(a,1,2)</code></pre><p>我们会发现并没有输出，这是为什么呢，我们来看一下 <a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fbind" target="_blank" rel="external">MDN</a> 上的文档说明：</p><blockquote><p>bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p></blockquote><p>所以我们可以看出，bind 是创建一个新的函数，我们必须要手动去调用：</p><pre><code class="javascript">    var a ={        name : &quot;Cherry&quot;,        fn : function (a,b) {            console.log( a + b)        }    }    var b = a.fn;    b.bind(a,1,2)()           // 3</code></pre><p>==================================== 更新==============================</p><h1 id="JS-中的函数调用"><a href="#JS-中的函数调用" class="headerlink" title="JS 中的函数调用"></a>JS 中的函数调用</h1><p>看到留言说，很多童靴不理解为什么 例 6 的 innerFunction 和 例 7 的 this 是指向 window 的，所以我就来补充一下 JS 中的函数调用。<br>例 6：</p><pre><code class="javascript">    var name = &quot;windowsName&quot;;    function fn() {        var name = &#39;Cherry&#39;;        innerFunction();        function innerFunction() {            console.log(this.name);      // windowsName        }    }    fn()</code></pre><p>例 7：</p><pre><code class="javascript">    var name = &quot;windowsName&quot;;    var a = {        name : &quot;Cherry&quot;,        func1: function () {            console.log(this.name)             },        func2: function () {            setTimeout(  function () {                this.func1()            },100);        }    };    a.func2()     // this.func1 is not a function</code></pre><p>函数调用的方法一共有 4 种</p><ol><li>作为一个函数调用</li><li>函数作为方法调用</li><li>使用构造函数调用函数</li><li>作为函数方法调用函数（call、apply）</li></ol><h2 id="作为一个函数调用"><a href="#作为一个函数调用" class="headerlink" title="作为一个函数调用"></a>作为一个函数调用</h2><p>比如上面的 例 1：<br>例 1：</p><pre><code class="javascript">    var name = &quot;windowsName&quot;;    function a() {        var name = &quot;Cherry&quot;;        console.log(this.name);          // windowsName        console.log(&quot;inner:&quot; + this);    // inner: Window    }    a();    console.log(&quot;outer:&quot; + this)         // outer: Window</code></pre><p>这样一个最简单的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 window 的，在严格模式，就是 undefined。</p><p>但这是一个全局的函数，很容易产生命名冲突，所以不建议这样使用。</p><h2 id="函数作为方法调用"><a href="#函数作为方法调用" class="headerlink" title="函数作为方法调用"></a>函数作为方法调用</h2><p>所以说更多的情况是将函数作为对象的方法使用。比如例 2：<br>例 2：</p><pre><code class="javascript">    var name = &quot;windowsName&quot;;    var a = {        name: &quot;Cherry&quot;,        fn : function () {            console.log(this.name);      // Cherry        }    }    a.fn();</code></pre><p>这里定义一个对象 <code>a</code>，对象 <code>a</code> 有一个属性（<code>name</code>）和一个方法（<code>fn</code>）。</p><p>然后对象 <code>a</code> 通过 <code>.</code> 方法调用了其中的 fn 方法。</p><p>然后我们一直记住的那句话“<strong>this 永远指向最后调用它的那个对象</strong>”，所以在 fn 中的 this 就是指向 a 的。</p><h2 id="使用构造函数调用函数"><a href="#使用构造函数调用函数" class="headerlink" title="使用构造函数调用函数"></a>使用构造函数调用函数</h2><blockquote><p>如果函数调用前使用了 new 关键字, 则是调用了构造函数。<br>这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：</p></blockquote><pre><code class="javascript">// 构造函数:function myFunction(arg1, arg2) {    this.firstName = arg1;    this.lastName  = arg2;}// This    creates a new objectvar a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);a.lastName;                             // 返回 &quot;Cherry&quot;</code></pre><p>这就有要说另一个面试经典问题：new 的过程了，(ಥ_ಥ)<br>这里就简单的来看一下 new 的过程吧：<br>伪代码表示：</p><pre><code class="javascript">var a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);new myFunction{    var obj = {};    obj.__proto__ = myFunction.prototype;    var result = myFunction.call(obj,&quot;Li&quot;,&quot;Cherry&quot;);    return typeof result === &#39;obj&#39;? result : obj;}</code></pre><ol><li>创建一个空对象 obj;</li><li>将新创建的空对象的隐式原型指向其构造函数的显示原型。</li><li>使用 call 改变 this 的指向</li><li>如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。</li></ol><p>所以我们可以看到，在 new 的过程中，我们是使用 call 改变了 this 的指向。</p><h2 id="作为函数方法调用函数"><a href="#作为函数方法调用函数" class="headerlink" title="作为函数方法调用函数"></a>作为函数方法调用函数</h2><blockquote><p>在 JavaScript 中, 函数是对象。</p><p>JavaScript 函数有它的属性和方法。<br>call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身</p><p>在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。<br>在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。</p></blockquote><p>这个时候我们再来看例 6：<br>例 6：</p><pre><code class="javascript">    var name = &quot;windowsName&quot;;    function fn() {        var name = &#39;Cherry&#39;;        innerFunction();        function innerFunction() {            console.log(this.name);      // windowsName        }    }    fn()</code></pre><p>这里的 innerFunction() 的调用是不是属于第一种调用方式：作为一个函数调用（它就是作为一个函数调用的，没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下 this 就是指向 window 的）</p><p>然后再看一下 例 7：<br>例 7：</p><pre><code class="javascript">    var name = &quot;windowsName&quot;;    var a = {        name : &quot;Cherry&quot;,        func1: function () {            console.log(this.name)             },        func2: function () {            setTimeout(  function () {                this.func1()            },100 );        }    };    a.func2()     // this.func1 is not a function</code></pre><p>这个简单一点的理解可以理解为“<strong>匿名函数的 this 永远指向 window</strong>”，你可以这样想，还是那句话<strong>this 永远指向最后调用它的那个对象</strong>，那么我们就来找最后调用匿名函数的对象，这就很尴尬了，因为匿名函数名字啊，笑哭，所以我们是没有办法被其他对象调用匿名函数的。所以说 匿名函数的 this 永远指向 window。</p><p>如果这个时候你要问，那匿名函数都是怎么定义的，首先，我们通常写的匿名函数都是自执行的，就是在匿名函数后面加 <code>()</code> 让其自执行。其次就是虽然匿名函数不能被其他对象调用，但是可以被其他函数调用啊，比如例 7 中的 setTimeout。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;this、apply、call、bind&quot;&gt;&lt;a href=&quot;#this、apply、call、bind&quot; class=&quot;headerlink&quot; title=&quot;this、apply、call、bind&quot;&gt;&lt;/a&gt;this、apply、call、bind&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="html" scheme="http://zc95.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>vue-todo</title>
    <link href="http://zc95.github.io/2018/04/27/vue-todo/"/>
    <id>http://zc95.github.io/2018/04/27/vue-todo/</id>
    <published>2018-04-26T16:12:01.000Z</published>
    <updated>2018-04-26T16:24:53.413Z</updated>
    
    <content type="html"><![CDATA[<p>这几天看了点vue，感觉很棒，把之前的todo翻出来用vue写了一下，瞬间少了三分之二的代码😂</p><h2 id="demo-amp-源码"><a href="#demo-amp-源码" class="headerlink" title="demo &amp; 源码"></a>demo &amp; 源码</h2><p>demo：<a href="https://zc95.github.io/demo/vue-todo">https://zc95.github.io/demo/vue-todo</a></p><p>github：<a href="https://github.com/zc95/ToDo/blob/master/vue-todo.html" target="_blank" rel="external">https://github.com/zc95/ToDo/blob/master/vue-todo.html</a></p><p>扫描二维码，在移动设备上查看：<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqqisjlidij307s07sq2p.jpg" alt=""></p><h2 id="demo对比（前面是vue写的）："><a href="#demo对比（前面是vue写的）：" class="headerlink" title="demo对比（前面是vue写的）："></a>demo对比（前面是vue写的）：</h2><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqqicqtlihj31bw18ugr0.jpg" alt=""></p><h2 id="代码量对比"><a href="#代码量对比" class="headerlink" title="代码量对比"></a>代码量对比</h2><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqqifc1djgj31kw0xg4k3.jpg" alt=""></p><h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><pre><code class="css">let todoStorage = {      save: function (todos) {        localStorage.setItem(&#39;vueTodoStorage&#39;, JSON.stringify(todos))      }    }    let app = new Vue({      el: &#39;#app&#39;,      data: {        todos: localStorage.vueTodoStorage ? JSON.parse(localStorage.vueTodoStorage) : [],        inputValue: &quot;&quot;      },      watch: {        todos: {          handler: function (items) {            todoStorage.save(items);          },          deep: true        }      },      methods: {        add() {          mdui.prompt(&#39;add a todo&#39;,            function (value) {              if(value.trim()==&quot;&quot;){                mdui.snackbar({ message: &quot;Can&#39;t be empty!&quot; });                return false;              }              app.todos.push({ text: value, completed: false });              mdui.snackbar({ message: &#39;A todo has been added.&#39; });            }          );        },        removeTodo(index) {          this.todos.splice(index, 1);          mdui.snackbar({ message: &#39;A todo has been removed.&#39; });        },        deleteAll() {          mdui.confirm(&#39;Are you sure you remove all todo?&#39;, function () {            app.todos = [];            mdui.snackbar({ message: &#39;All todo have been removed.&#39; });          });        },        resetAll() {          mdui.confirm(&#39;Are you sure you reset all todo?&#39;, function () {            app.todos.forEach(element =&gt; {              element.completed = false;            });            mdui.snackbar({ message: &#39;All todo have been reset.&#39; });          });        }      }    })</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天看了点vue，感觉很棒，把之前的todo翻出来用vue写了一下，瞬间少了三分之二的代码😂&lt;/p&gt;
&lt;h2 id=&quot;demo-amp-源码&quot;&gt;&lt;a href=&quot;#demo-amp-源码&quot; class=&quot;headerlink&quot; title=&quot;demo &amp;amp; 源码&quot;
      
    
    </summary>
    
      <category term="demo" scheme="http://zc95.github.io/categories/demo/"/>
    
    
      <category term="material design" scheme="http://zc95.github.io/tags/material-design/"/>
    
      <category term="vue" scheme="http://zc95.github.io/tags/vue/"/>
    
      <category term="todo" scheme="http://zc95.github.io/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>vue-devtools的安装</title>
    <link href="http://zc95.github.io/2018/04/22/vue-devtools/"/>
    <id>http://zc95.github.io/2018/04/22/vue-devtools/</id>
    <published>2018-04-21T17:22:45.000Z</published>
    <updated>2018-04-21T17:25:53.079Z</updated>
    
    <content type="html"><![CDATA[<p>vue-devtools 是一款基于chrome游览器的插件，用于调试vue应用，由于国内不能访问谷歌商店（要科学上网），所以安装比较麻烦，写个博客记录一下。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>将vue-devtools clone到本地</p><pre><code class="bash">git clone https://github.com/vuejs/vue-devtools.git</code></pre><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>在vue-devtools目录下安装依赖包</p><pre><code class="shell">cd vue-devtoolsnpm install</code></pre><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>编译代码</p><pre><code class="bash">npm run build</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqksckz0bfj30vo0kcjvu.jpg" alt=""></p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>修改 <code>vue-devtools/shells/chrome/manifest.json</code> 文件，将 persistent改成 <code>true</code></p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqkqczgwjdj30zi0g4di1.jpg" alt=""></p><h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><h3 id="打开chrome，输入-chrome-extensions-进入到chrome扩展程序设置页面"><a href="#打开chrome，输入-chrome-extensions-进入到chrome扩展程序设置页面" class="headerlink" title="打开chrome，输入 chrome://extensions/ 进入到chrome扩展程序设置页面"></a>打开chrome，输入 <code>chrome://extensions/</code> 进入到chrome扩展程序设置页面</h3><p>打开右上角的 <code>开发者模式</code> </p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqkqim3oz3j30b2058aa4.jpg" alt=""></p><h3 id="点击-加载已解压的扩展程序-选择-vue-devtools-shells-chrome"><a href="#点击-加载已解压的扩展程序-选择-vue-devtools-shells-chrome" class="headerlink" title="点击 加载已解压的扩展程序 选择 vue-devtools/shells/chrome"></a>点击 <code>加载已解压的扩展程序</code> 选择 <code>vue-devtools/shells/chrome</code></h3><p>   <img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqkqmn6rp0j31480owdlm.jpg" alt=""></p><h3 id="注意：勾选-允许访问文件网址"><a href="#注意：勾选-允许访问文件网址" class="headerlink" title="注意：勾选 允许访问文件网址"></a>注意：勾选 <code>允许访问文件网址</code></h3><p>   <img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqks8mz3qxj318u05i0t0.jpg" alt=""></p><p>至此，vue-devtools已经安装完毕。enjoy it!</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqksb2n8lkj31kw115n6r.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vue-devtools 是一款基于chrome游览器的插件，用于调试vue应用，由于国内不能访问谷歌商店（要科学上网），所以安装比较麻烦，写个博客记录一下。&lt;/p&gt;
&lt;h2 id=&quot;第一步&quot;&gt;&lt;a href=&quot;#第一步&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="Vue" scheme="http://zc95.github.io/tags/Vue/"/>
    
      <category term="vue-devtools" scheme="http://zc95.github.io/tags/vue-devtools/"/>
    
  </entry>
  
  <entry>
    <title>vue-learning</title>
    <link href="http://zc95.github.io/2018/04/17/vue-learning/"/>
    <id>http://zc95.github.io/2018/04/17/vue-learning/</id>
    <published>2018-04-17T15:02:21.000Z</published>
    <updated>2018-04-17T15:06:34.274Z</updated>
    
    <content type="html"><![CDATA[<p>emm…开始学习Vue啦 <a href="https://github.com/zc95/vue-learning" target="_blank" rel="external">https://github.com/zc95/vue-learning</a></p><p><img src="https://cn.vuejs.org/images/logo.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;emm…开始学习Vue啦 &lt;a href=&quot;https://github.com/zc95/vue-learning&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/zc95/vue-learning&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="html" scheme="http://zc95.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>js的函数重载</title>
    <link href="http://zc95.github.io/2018/04/15/overloading/"/>
    <id>http://zc95.github.io/2018/04/15/overloading/</id>
    <published>2018-04-15T15:17:48.000Z</published>
    <updated>2018-04-16T12:52:48.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h2><p>函数重载，简单说，就是函数有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。</p><p>所以说，重载函数需要两点：同样的函数名，不同的函数参数。</p><h2 id="js到底有没有函数重载"><a href="#js到底有没有函数重载" class="headerlink" title="js到底有没有函数重载"></a>js到底有没有函数重载</h2><p>如果在我们在一个页面中定义了两个名字相同的函数，则该名字只属于后定义的函数，如下：</p><pre><code class="javascript">function add(num){    return num+1;}function add(num){    return num+2;}add(4);  //结果为6</code></pre><p>在上面的例子中，add()函数被定义了两次，然而，当我们调用他的时候，却直接调用了第二个函数，这说明在JavaScript中，后定义的函数会覆盖先定义的函数。</p><p>其实，在java或者.net中都是是存在重载的，那么js中呢？可以肯定的说，js中是不存在重载的，但是我们可以通过其他的方式来模拟重载。</p><h2 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h2><p>当我们在js中在调用一个函数的时候，我们经常会给这个函数传递一些参数，js把传入到这个函数的全部参数存储在一个叫做arguments的东西里面，<code>arguments</code>对象不是一个<code>Array</code> 。它类似于<code>Array</code>，可以使用[i]或者.length，为了代码的严谨度，我们可以用arguments的length属性来判断当前传入参数的个数是否与我们需要的数量一致。</p><pre><code class="javascript">function add(num1, num2){    // 根据arguments.length，对不同的值进行不同的操作　　switch(arguments.length) {　　　　case 0:　　　　　　/*没有传入任何参数时*/　　　　　　break;　　　　case 1:　　　　　　/*传入一个参数时*/　　　　　　break;　　　　case 2:　　　　　　/*传入两个参数时*/             break;      /*case N.....*/}}</code></pre><p>通过这个例子，我们可以看出，通过检查传入函数中参数的数量，JavaScript函数可以做出不同的反应，这可以间接达到重载的目的。</p><p>所以，JavaScript是可以模仿函数的重载的。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="arguments-类数组对象转为真正的数组"><a href="#arguments-类数组对象转为真正的数组" class="headerlink" title="arguments 类数组对象转为真正的数组"></a>arguments 类数组对象转为真正的数组</h3><pre><code>Array.prototype.slice.apply(arguments);Array.from(arguments);[...arguments];</code></pre><h3 id="callee"><a href="#callee" class="headerlink" title="callee"></a>callee</h3><p><code>arguments.callee</code> 属性包含当前正在执行的函数。<strong>callee</strong> 是 <code>arguments</code> 对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。这在函数的名称是未知时很有用，例如在没有名称的函数表达式（也称为匿名函数）内。</p><p>以一个求阶乘的方法为例：</p><pre><code class="javascript">function fact(n) { if (n &lt; 2) {  return n; } else {  return n * fact(n - 1); }}console.log(fact(5)); //5*4*3*2=120</code></pre><p>匿名函数中：</p><pre><code class="javascript">(function (n) { if (n &lt; 2) {  return n; } else {  return n * arguments.callee(n - 1); }})(5);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数的重载&quot;&gt;&lt;a href=&quot;#函数的重载&quot; class=&quot;headerlink&quot; title=&quot;函数的重载&quot;&gt;&lt;/a&gt;函数的重载&lt;/h2&gt;&lt;p&gt;函数重载，简单说，就是函数有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="javascript" scheme="http://zc95.github.io/tags/javascript/"/>
    
      <category term="函数重载" scheme="http://zc95.github.io/tags/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    
      <category term="arguments对象" scheme="http://zc95.github.io/tags/arguments%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Node.js构建TCP服务器和TCP客户端</title>
    <link href="http://zc95.github.io/2018/03/20/nodejs-TCP/"/>
    <id>http://zc95.github.io/2018/03/20/nodejs-TCP/</id>
    <published>2018-03-20T13:56:12.000Z</published>
    <updated>2018-04-15T15:19:58.967Z</updated>
    
    <content type="html"><![CDATA[<p>网络是通信互联网的基础，Node.js提供了net、http、dgram模块、分别用来实现TCP、HTTP、UDP的通信。上次的文章<a href="https://zc95.github.io/2018/03/19/nodejs-HTTP/">《Node.js构建HTTP服务器》</a>实现了HTTP的通信，这篇文章说一说TCP服务器和TCP客户端的构建。</p><h2 id="用Node-js创建TCP服务器"><a href="#用Node-js创建TCP服务器" class="headerlink" title="用Node.js创建TCP服务器"></a>用Node.js创建TCP服务器</h2><h3 id="构建TCP服务器"><a href="#构建TCP服务器" class="headerlink" title="构建TCP服务器"></a>构建TCP服务器</h3><p>为了使用Node.js创建TCP服务器，首先要使用require(“net”)来加载net模块，然后使用net模块的createServer方法就可以轻松地创建一个TCP服务器。</p><pre><code class="javascript">/** * 构建TCP客户端 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP服务器 */var server = net.createServer(function(socket){    console.log(&#39;someone connects&#39;);})/* 设置连接的服务器 */server.listen(8000, function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>运行这段代码并访问了<a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a>的话会看到控制台打印了”someone connects”，表明已经成功连接到这个创建的TCP服务器。</p><hr><blockquote><p>/<em> 设置连接的服务器 </em>/<br>server.listen(8000, function(){<br>​    console.log(“Creat server on <a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a>“);<br>})</p></blockquote><p>上面这段代码实际上触发的是server下的listening事件，等同于：</p><blockquote><p>/<em> 设置监听端口 </em>/</p><p>server.listen(8000);</p><p>/<em> 设置监听时的回调函数 </em>/</p><p>server.on(“listening”, function () {</p><p>​    console.log(“Creat server on <a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a>“);</p><p>})</p></blockquote><p>事实上，除了listening事件外，TCP服务器还支持以下事件：</p><ol><li>connection：当有新的连接创建时触发，回调函数的参数为socket连接对象。</li><li>close：TCP服务器关闭的时候触发，回调函数没有参数</li><li>error：TCP服务器发生错误的时候触发，回调函数的参数为error对象</li></ol><p>下列代码通过net.Server类来创建一个TCP服务器，并添加以上事件。</p><pre><code class="javascript"> /** * 通过net.Server类来创建一个TCP服务器 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 实例化一个服务器对象 */var server = new net.Server();/* 监听 connection 事件 */server.on(&quot;connection&quot;, function (socket) {    console.log(&quot;someone connects&quot;);});/* 设置监听端口 */server.listen(8000);/* 设置监听时的回调函数 */server.on(&quot;listening&quot;, function () {    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})/* 设置关闭时的回调函数 */server.on(&quot;close&quot;, function () {    console.log(&quot;server closed!&quot;);})/* 设置错误时的回调函数 */server.on(&quot;error&quot;, function (err) {    console.log(&quot;error!&quot;);})</code></pre><h3 id="查看服务器监听的地址"><a href="#查看服务器监听的地址" class="headerlink" title="查看服务器监听的地址"></a>查看服务器监听的地址</h3><p>当创建了一个TCP服务器后，可以通过server.address()方法来查看这个TCP服务器监听的地址，并返回一个JSON对象。这个对象的属性有：</p><ol><li>port：TCP服务器监听的端口号</li><li>family：说明TCP服务器监听的地址是 IPv6 还是 IPv4</li><li>address：TCP服务器监听的地址</li></ol><pre><code class="javascript">/** * 查看服务器监听的地址 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP服务器 */var server = net.createServer(function(socket){    console.log(&#39;someone connects&#39;);})/* 获取地址信息 */server.listen(8000,function(){    /* 获取地址信息，得到的是一个json { address: &#39;::&#39;, family: &#39;IPv6&#39;, port: 8000 } */    var address = server.address();    /* TCP服务器监听的端口号 */    console.log(&quot;the port of server is&quot;+ address.port);    /* TCP服务器监听的地址 */    console.log(&quot;the address of server is&quot;+ address.address);    /* 说明TCP服务器监听的地址是 IPv6 还是 IPv4 */    console.log(&quot;the family of server is&quot;+ address.family);})</code></pre><h3 id="连接服务器的客户端数量"><a href="#连接服务器的客户端数量" class="headerlink" title="连接服务器的客户端数量"></a>连接服务器的客户端数量</h3><p>创建一个TCP服务器后，可以通过server.getConnections()方法获取连接这个TCP服务器的客户端数量。除此之外，也可以通过maxConnections属性来设置这个服务器的最大连接数量，当连接数量超过最大值时，服务器将拒绝新的连接。</p><pre><code class="javascript">/** * 连接服务器的客户端数量 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP服务器 */var server = net.createServer(function(socket){    console.log(&#39;someone connects&#39;);    /* 设置最大连接数量 */    server.maxConnections=3;    server.getConnections(function(err,count){        console.log(&quot;the count of client is &quot;+count);    })})/* 获取监听端口 */server.listen(8000,function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>你可以打开多个网页输入localhost:8000来测试这段代码，也可以用Telnet命令 <code>telnet localhost 8000</code> 来连接这个TCP服务器（上一篇文章有提到如何用Homebrew安装Telnet：<a href="https://zc95.github.io/2018/03/20/Homebrew/">《Homebrew》</a>）。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fpkqytum6zj31kw0s7toa.jpg" alt=""></p><h3 id="服务器和客户端之间的通信"><a href="#服务器和客户端之间的通信" class="headerlink" title="服务器和客户端之间的通信"></a>服务器和客户端之间的通信</h3><p>利用socket.write()可以使TCP服务器发送数据给客户端；</p><p>socket对象可以用来获取客户端发出的流数据，每次接收到数据的时候触发data事件，通过监听这个事件就可以在回调函数中获取客户端发送的数据了。</p><pre><code class="javascript">/** * 发送和获取 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP服务器 */var server = net.createServer(function(socket){    /* 获取地址信息 */    var address = server.address();    var message = &quot;the server address is&quot;+JSON.stringify(address);    /* 发送数据 */    socket.write(message,function(){        var writeSize = socket.bytesWritten;        console.log(message + &quot;has send&quot;);        console.log(&quot;the size of message is&quot;+writeSize);    })    /* 监听data事件 */    socket.on(&#39;data&#39;,function(data){        console.log(data.toString());        var readSize = socket.bytesRead;        console.log(&quot;the size of data is&quot;+readSize);    })})/* 获取地址信息 */server.listen(8000,function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>下图中TCP服务器给客户端发送了字符串：</p><blockquote><p>the server address is{“address”:”::”,”family”:”IPv6”,”port”:8000}has send</p></blockquote><p>客户端给TCP服务器发送了字符串 <code>hello TCP!</code> 和字节数。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fpkr5446asj31kw0p5gvz.jpg" alt=""></p><h2 id="用Node-js创建TCP客户端"><a href="#用Node-js创建TCP客户端" class="headerlink" title="用Node.js创建TCP客户端"></a>用Node.js创建TCP客户端</h2><h3 id="构建TCP客户端"><a href="#构建TCP客户端" class="headerlink" title="构建TCP客户端"></a>构建TCP客户端</h3><p>上面说到用打开网页或者Telnet来访问TCP服务器，其实我们也可以用Node.js来构建一个TCP客户端，实现TCP客户端和TCP服务器的通信。</p><p>为了使用Node.js创建TCP客户端，首先要使用require(“net”)来加载net模块，然后创建一个连接TCP客户端的socket对象即可：</p><blockquote><p>/<em> 引入net模块 </em>/</p><p>var net = require(“net”);</p><p>/<em> 创建TCP客户端 </em>/</p><p>var client = net.Socket();</p></blockquote><p>创建完socket对象后，使用socket对象的connect方法就可以连接一个TCP服务器。</p><pre><code class="javascript">/** * 构建TCP客户端 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP客户端 */var client = net.Socket();/* 设置连接的服务器 */client.connect(8000, &#39;127.0.0.1&#39;, function () {    console.log(&quot;connect the server&quot;);    /* 向服务器发送数据 */    client.write(&quot;message from client&quot;);})/* 监听服务器传来的data数据 */client.on(&quot;data&quot;, function (data) {    console.log(&quot;the data of server is &quot; + data.toString());})/* 监听end事件 */client.on(&quot;end&quot;, function () {    console.log(&quot;data end&quot;);})</code></pre><h3 id="TCP客户端和TCP服务器的通信"><a href="#TCP客户端和TCP服务器的通信" class="headerlink" title="TCP客户端和TCP服务器的通信"></a>TCP客户端和TCP服务器的通信</h3><p>运行 <a href="#服务器和客户端之间的通信">这段代码</a> 之后再运行 <a href="#构建TCP客户端">这段代码</a> ，可以发现服务器已经接收到客户端的数据，客户端也已经接收到服务端的数据。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fpkso73cqdj31kw0o27bv.jpg" alt=""></p><h2 id="LINK"><a href="#LINK" class="headerlink" title="LINK"></a>LINK</h2><ol><li>本章github源码：<a href="https://github.com/zc95/nodeTest/tree/master/TCP" target="_blank" rel="external">https://github.com/zc95/nodeTest/tree/master/TCP</a></li><li>《Node.js构建HTTP服务器》：<a href="https://zc95.github.io/2018/03/19/nodejs-HTTP/">https://zc95.github.io/2018/03/19/nodejs-HTTP/</a></li><li>用Homebrew安装Telnet：<a href="https://zc95.github.io/2018/03/20/Homebrew/">https://zc95.github.io/2018/03/20/Homebrew/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络是通信互联网的基础，Node.js提供了net、http、dgram模块、分别用来实现TCP、HTTP、UDP的通信。上次的文章&lt;a href=&quot;https://zc95.github.io/2018/03/19/nodejs-HTTP/&quot;&gt;《Node.js构建HTTP
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="Node.js" scheme="http://zc95.github.io/tags/Node-js/"/>
    
      <category term="TCP" scheme="http://zc95.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Homebrew</title>
    <link href="http://zc95.github.io/2018/03/20/Homebrew/"/>
    <id>http://zc95.github.io/2018/03/20/Homebrew/</id>
    <published>2018-03-20T13:31:52.000Z</published>
    <updated>2018-03-21T14:58:14.483Z</updated>
    
    <content type="html"><![CDATA[<p>Homebrew简称brew，OSX上的软件包管理工具，在Mac终端可以通过brew安装、更新、卸载软件。</p><h2 id="Homebrew-能干什么"><a href="#Homebrew-能干什么" class="headerlink" title="Homebrew 能干什么?"></a>Homebrew 能干什么?</h2><p><a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew官网</a> 的title是这么说的：macOS 缺失的软件包管理器，意思就是使用 Homebrew 安装 Apple 没有预装但你需要的东西，比如high sierra 10.13中移除了telnet，只需要 <code>brew install telnet</code> 一个命令就行。</p><a id="more"></a><h2 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h2><p>一、进入<a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew官网</a>，按照官网提示在命令行执行ruby脚本（mac自带ruby），在终端运行以下命令：</p><pre><code class="bash">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p>二、按提示输入电脑密码，一路enter到底，直到出现下面的信息就说明安装成功。</p><pre><code class="bash">==&gt; Next steps:- Run `brew help` to get started- Further documentation:     https://docs.brew.sh</code></pre><p>三、运行命令 <code>brew help</code> 就可以了解一些brew常用的命令：</p><pre><code class="bash">Example usage:  brew search [TEXT|/REGEX/]  brew (info|home|options) [FORMULA...]  brew install FORMULA...  brew update  brew upgrade [FORMULA...]  brew uninstall FORMULA...  brew list [FORMULA...]Troubleshooting:  brew config  brew doctor  brew install -vd FORMULADevelopers:  brew create [URL [--no-fetch]]  brew edit [FORMULA...]  https://docs.brew.sh/Formula-CookbookFurther help:  man brew  brew help [COMMAND]  brew home</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Homebrew简称brew，OSX上的软件包管理工具，在Mac终端可以通过brew安装、更新、卸载软件。&lt;/p&gt;
&lt;h2 id=&quot;Homebrew-能干什么&quot;&gt;&lt;a href=&quot;#Homebrew-能干什么&quot; class=&quot;headerlink&quot; title=&quot;Homebrew 能干什么?&quot;&gt;&lt;/a&gt;Homebrew 能干什么?&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://brew.sh/index_zh-cn.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Homebrew官网&lt;/a&gt; 的title是这么说的：macOS 缺失的软件包管理器，意思就是使用 Homebrew 安装 Apple 没有预装但你需要的东西，比如high sierra 10.13中移除了telnet，只需要 &lt;code&gt;brew install telnet&lt;/code&gt; 一个命令就行。&lt;/p&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="Homebrew" scheme="http://zc95.github.io/tags/Homebrew/"/>
    
      <category term="brew" scheme="http://zc95.github.io/tags/brew/"/>
    
      <category term="telnet" scheme="http://zc95.github.io/tags/telnet/"/>
    
  </entry>
  
  <entry>
    <title>Node.js构建HTTP服务器</title>
    <link href="http://zc95.github.io/2018/03/19/nodejs-HTTP/"/>
    <id>http://zc95.github.io/2018/03/19/nodejs-HTTP/</id>
    <published>2018-03-19T12:29:42.000Z</published>
    <updated>2018-04-09T14:29:15.156Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js® is a JavaScript runtime built on <a href="https://developers.google.com/v8/" target="_blank" rel="external">Chrome’s V8 JavaScript engine</a>. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, <a href="https://www.npmjs.com/" target="_blank" rel="external">npm</a>, is the largest ecosystem of open source libraries in the world.</p><h2 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a>Node.js简介</h2><p><code>Node.js</code> 是一个基于 Google Chrome V8 引擎 的 JavaScript 运行环境。Node.js使用后多种先进的技术，其中包括 事件驱动、非阻塞 I/O 模型，使其轻量又高效，受到众多开发者的追捧。</p><p>简单的说，Node.js 就是运行在服务端的 JavaScript ，可以稳定地在各种平台下运行，包括Linux、Windows、Mac OS X、Sun Os 和FreeBSD等众多平台。</p><a id="more"></a><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><ol><li>点击 <a href="https://nodejs.org" target="_blank" rel="external">https://nodejs.org</a> 进入nodejs官网</li><li>有两个版本：LTS和Current，LTS是长期支持版本，成熟可靠</li><li>next到底</li><li>打开终端，输入 <code>node -v</code> ，回车，如果出现类似 <code>v6.11.4</code> 的版本号就说明安装成功</li></ol><h2 id="构建一个HTTP服务器"><a href="#构建一个HTTP服务器" class="headerlink" title="构建一个HTTP服务器"></a>构建一个HTTP服务器</h2><p>在如今web大行其道的时代，支撑无数网页运行的正是HTTP服务器。Node.js之所以受到大量web开发者的青睐，与Node.js有能力自己构建服务器是分不开的。</p><ol><li><p>在根目录下新建 <code>nodetest</code> 文件夹</p></li><li><p>在 <code>nodetest</code> 下新建 <code>HTTP</code> 文件夹</p></li><li><p>在 <code>HTTP</code> 文件夹下新建一个 <code>server.js</code> 的文件</p></li><li><p>拷贝粘贴这段代码，保存：</p><pre><code class="javascript">/** * 创建http服务器 *//* 引入http模块 */var http = require(&quot;http&quot;);/* 创建HTTP服务器 */var server = http.createServer(function(request, response) {    /* 设置相应的头部 */    response.writeHead(200, {        &quot;content-Type&quot; : &quot;text/plain&quot;    });    /* 设置相应的数据 */    response.write(&quot;Welcome to Nodejs&quot;);    response.end();});/* 设置服务器端口 */server.listen(8000, function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre></li><li><p>打开终端 输入 <code>cd nodetest/HTTP</code> </p></li><li><p>输入 <code>node server.js</code> ，返回 <code>Creat server on http://127.0.0.1:8000/</code></p></li><li><p>打开浏览器输入 <code>http://127.0.0.1:8000/</code> 或者 <code>http://localhost:8000</code> </p></li><li><p>Welcome to Nodejs</p></li></ol><h2 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块"></a>文件模块</h2><p>上面说到的HTTP服务器知识实现了将一串字符串发送给服务器。很明显，如果服务器只能发送一些字符串，那几乎是远远不够的，因此我们要做一些扩展，通过文件模块将文件读取并发送给服务器是一个不错的选择，在nodetest文件夹下新建 <code>fsModule.js</code> :</p><pre><code class="javascript">/** * fs模块 *//* 引入http模块 */var http = require(&quot;http&quot;);/* 引入fs模块 */var fs = require(&quot;fs&quot;);/* 创建HTTP服务器 */var server = http.createServer(function(request, response) {    /* 设置响应的头部 */    response.writeHead(200, {        &quot;content-Type&quot; : &quot;text/html&quot;    });    /* 读取文件数据 */    var data = fs.readFileSync(&quot;./index.html&quot;);    /* 设置响应的数据 */    response.write(data);    response.end();});/* 设置服务器端口 */server.listen(8000, function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>同时在同级目录中创建一个名为 <code>index.html</code> 的文件，写入以下代码：</p><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot; /&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;title&gt;fs module&lt;/title&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;fs文件模块&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>node fsModule.js 运行，在浏览器中打开 <code>http://localhost:8000</code> ，Node.js已经把index这个文件发送到客户端了；</p><p>需要提及的是，这里HTTP服务器在发送给浏览器的头部信息中将 content-type修改为了 <code>text/html</code> 。 content-type的人作用就是用来表示客户端或者服务器传输数据的类型，服务器或者客客户端通过这个值来做相应的解析。如果这个值改为原来的 <code>text/plain</code> ，浏览器将显示index.html的所有源代码，这显然不是我们想要的。</p><h2 id="HTTP服务器的路由控制"><a href="#HTTP服务器的路由控制" class="headerlink" title="HTTP服务器的路由控制"></a>HTTP服务器的路由控制</h2><p>上一节中的服务器虽然已经可以通过读取文件数据来发送给客户端了，但你并没有做任何的路由控制，在浏览器中输入任何URL都将返回同样的内容，简单来说，路由就是URL到函数的映射。</p><p>要做到路由控制，通过上面的学习可以预想到修改content-type就可以了，这里假定只需要处理html、js、css和图片文件，创建一个名为 <code>mime.js</code> 的文件：</p><pre><code class="javascript">module.exports = {    &quot;.html&quot; : &quot;text/html&quot;,    &quot;.css&quot; : &quot;text/css&quot;,    &quot;.js&quot; : &quot;text/javascript&quot;,    &quot;.gif&quot; : &quot;image/gif&quot;,    &quot;.ico&quot; : &quot;image/x-icon&quot;,    &quot;.jpeg&quot; : &quot;image/jpeg&quot;,    &quot;.jpg&quot; : &quot;image/jpeg&quot;,    &quot;.png&quot; : &quot;image/png&quot;,}</code></pre><p>创建一个名为 <code>fsModule2.js</code> 的文件：</p><pre><code class="javascript">/** * 这里通过路径处理判断来返回不同的资源，从而做到简单的路由控制 *//* 引入http模块 */var http = require(&quot;http&quot;);/* 引入fs模块 */var fs = require(&quot;fs&quot;);/* 引入url模块 */var url = require(&quot;url&quot;);/* 引入mime文件 */var mime = require(&quot;./mime.js&quot;);/* 引入path模块 */var path = require(&quot;path&quot;);/* 创建HTTP服务器 */var server = http.createServer(function(request, response) {    var filePath = &quot;.&quot;+url.parse(request.url).pathname;    if(filePath === &quot;./&quot;){        filePath = &#39;./index.html&#39;    }    /* 判断相应的文件是否存在 */    fs.exists(filePath,function(exists){        /* 存在则返回相应文件数据 */        if(exists){            var data = fs.readFileSync(filePath);            var contentType = mime[path.extname(filePath)];            response.writeHead(200,{                &quot;content-type&quot;: contentType            });            response.write(data);            response.end();        }else{            response.end(&quot;404&quot;);        }    })});/* 设置服务器端口 */server.listen(8000, function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>这里通过对路径处理判断来返回不同的资源，从而做到简单的路由控制。</p><h2 id="LINK"><a href="#LINK" class="headerlink" title="LINK"></a>LINK</h2><ol><li>本章github源码：<a href="https://github.com/zc95/nodeTest/tree/master/HTTP" target="_blank" rel="external">https://github.com/zc95/nodeTest/tree/master/HTTP</a></li><li>《Node.js构建TCP服务器和TCP客户端》：<a href="https://zc95.github.io/2018/03/20/nodejs-TCP/">https://zc95.github.io/2018/03/20/nodejs-TCP/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js® is a JavaScript runtime built on &lt;a href=&quot;https://developers.google.com/v8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Chrome’s V8 JavaScript engine&lt;/a&gt;. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, &lt;a href=&quot;https://www.npmjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;npm&lt;/a&gt;, is the largest ecosystem of open source libraries in the world.&lt;/p&gt;
&lt;h2 id=&quot;Node-js简介&quot;&gt;&lt;a href=&quot;#Node-js简介&quot; class=&quot;headerlink&quot; title=&quot;Node.js简介&quot;&gt;&lt;/a&gt;Node.js简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Node.js&lt;/code&gt; 是一个基于 Google Chrome V8 引擎 的 JavaScript 运行环境。Node.js使用后多种先进的技术，其中包括 事件驱动、非阻塞 I/O 模型，使其轻量又高效，受到众多开发者的追捧。&lt;/p&gt;
&lt;p&gt;简单的说，Node.js 就是运行在服务端的 JavaScript ，可以稳定地在各种平台下运行，包括Linux、Windows、Mac OS X、Sun Os 和FreeBSD等众多平台。&lt;/p&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="Node.js" scheme="http://zc95.github.io/tags/Node-js/"/>
    
      <category term="本地服务器" scheme="http://zc95.github.io/tags/%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门</title>
    <link href="http://zc95.github.io/2018/03/13/es6-webpack/"/>
    <id>http://zc95.github.io/2018/03/13/es6-webpack/</id>
    <published>2018-03-13T13:42:52.000Z</published>
    <updated>2018-03-20T13:32:31.633Z</updated>
    
    <content type="html"><![CDATA[<p>github：<a href="https://github.com/zc95/es6-webpack" target="_blank" rel="external">https://github.com/zc95/es6-webpack</a></p><h2 id="webpack搭建ES6环境"><a href="#webpack搭建ES6环境" class="headerlink" title="webpack搭建ES6环境"></a>webpack搭建ES6环境</h2><p>首先下载源码</p><pre><code class="shell">git clone https://github.com/zc95/es6-webpack.git</code></pre><p>然后安装</p><pre><code class="shell">cd es6-webpacknpm installnpm install webpack -gnpm install webpack-dev-server -g</code></pre><p>最后运行</p><pre><code class="shell">cd es6-webpacknpm start</code></pre><a id="more"></a><h2 id="es6基础"><a href="#es6基础" class="headerlink" title="es6基础"></a>es6基础</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><pre><code class="javascript">// ES5 中常量的写法Object.defineProperty(window, &quot;PI2&quot;, {    value: 3.1415926,    writable: false,})</code></pre><pre><code class="javascript">// ES6 的常量写法const PI = 3.1415926</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><pre><code class="javascript">// ES3,ES5var evens = [1, 2, 3, 4, 5];var odds = evens.map(function(v) {  return v + 1});  console.log(evens, odds);};</code></pre><pre><code class="javascript">// ES6let evens = [1, 2, 3, 4, 5];let odds = evens.map(v =&gt; v + 1);console.log(evens, odds);</code></pre><p><strong>this的指向</strong></p><pre><code class="javascript">// ES3,ES5中 this 的指向是 该函数被调用的对象  var factory = function() {    this.a = &#39;a&#39;;    this.b = &#39;b&#39;;    this.c = {      a: &#39;a+&#39;,      b: function() {        return this.a      }    }  }  console.log(new factory().c.b());};</code></pre><pre><code class="javascript">// ES6箭头函数中 this 的指向是 定义时this的指向var factory = function() {    this.a = &#39;a&#39;;    this.b = &#39;b&#39;;    this.c = {      a: &#39;a+&#39;,      b: () =&gt; {        return this.a      }    }  }  console.log(new factory().c.b());</code></pre><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p><strong>默认参数</strong></p><pre><code class="javascript">// ES5\ES3 默认参数的写法  function f(x, y, z) {    if (y === undefined) {      y = 7;    }    if (z === undefined) {      z = 42    }    return x + y + z  }  console.log(f(1, 3));</code></pre><pre><code class="javascript">// ES6 默认参数  function f(x, y = 7, z = 42) {    return x + y + z  }  console.log(f(1, 3));</code></pre><p><strong>可变参数</strong></p><pre><code class="javascript">// ES3,ES5 可变参数  function f() {    var a = Array.prototype.slice.call(arguments);    var sum = 0;    a.forEach(function(item) {      sum += item * 1;    })    return sum  }  console.log(f(1, 2, 3, 6));</code></pre><pre><code class="javascript">// ES6 可变参数function f(...a) {    var sum = 0;    a.forEach(item =&gt; {      sum += item * 1    });    return sum  }  console.log(f(1, 2, 3, 6));</code></pre><p><strong>合并数组</strong></p><pre><code class="javascript">// ES5 合并数组  var params = [&#39;hello&#39;, true, 7];  var other = [1, 2].concat(params);  console.log(other);</code></pre><pre><code class="javascript">// ES6 利用扩展运算符合并数组  var params = [&#39;hello&#39;, true, 7];  var other = [    1, 2, ...params  ];  console.log(other);</code></pre><h3 id="对象代理"><a href="#对象代理" class="headerlink" title="对象代理"></a>对象代理</h3><pre><code class="javascript">// ES3,ES5 数据保护  var Person = function() {    var data = {      name: &#39;es3&#39;,      sex: &#39;male&#39;,      age: 15    }    this.get = function(key) {      return data[key]    }    this.set = function(key, value) {      if (key !== &#39;sex&#39;) {        data[key] = value      }    }  }  // 声明一个实例  var person = new Person();  // 读取  console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)});  // 修改  person.set(&#39;name&#39;, &#39;es3-cname&#39;);  console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)});  person.set(&#39;sex&#39;, &#39;female&#39;);  console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)});</code></pre><pre><code class="javascript">// ES5  var Person = {    name: &#39;es5&#39;,    age: 15  };  Object.defineProperty(Person, &#39;sex&#39;, {    writable: false,    value: &#39;male&#39;  });  console.table({name: Person.name, age: Person.age, sex: Person.sex});  Person.name = &#39;es5-cname&#39;;  console.table({name: Person.name, age: Person.age, sex: Person.sex});  try {    Person.sex = &#39;female&#39;;    console.table({name: Person.name, age: Person.age, sex: Person.sex});  } catch (e) {    console.log(e);  }</code></pre><pre><code class="javascript">// ES6  let Person = {    name: &#39;es6&#39;,    sex: &#39;male&#39;,    age: 15  };  let person = new Proxy(Person, {    get(target, key) {      return target[key]    },    set(target,key,value){      if(key!==&#39;sex&#39;){        target[key]=value;      }    }  });  console.table({    name:person.name,    sex:person.sex,    age:person.age  });  try {    person.sex=&#39;female&#39;;  } catch (e) {    console.log(e);  } finally {  }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;github：&lt;a href=&quot;https://github.com/zc95/es6-webpack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/zc95/es6-webpack&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;webpack搭建ES6环境&quot;&gt;&lt;a href=&quot;#webpack搭建ES6环境&quot; class=&quot;headerlink&quot; title=&quot;webpack搭建ES6环境&quot;&gt;&lt;/a&gt;webpack搭建ES6环境&lt;/h2&gt;&lt;p&gt;首先下载源码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git clone https://github.com/zc95/es6-webpack.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;cd es6-webpack
npm install
npm install webpack -g
npm install webpack-dev-server -g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后运行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;cd es6-webpack
npm start
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="ES6" scheme="http://zc95.github.io/tags/ES6/"/>
    
      <category term="webpack" scheme="http://zc95.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>撸了一个canvas手写板</title>
    <link href="http://zc95.github.io/2018/03/08/canvasPalette/"/>
    <id>http://zc95.github.io/2018/03/08/canvasPalette/</id>
    <published>2018-03-08T15:15:11.000Z</published>
    <updated>2018-03-31T04:47:20.741Z</updated>
    
    <content type="html"><![CDATA[<p>用 canvas 写了一个手写板，功能：画笔粗细、橡皮擦大小、画笔颜色、清空画布、历史操作等</p><h2 id="canvas手写板"><a href="#canvas手写板" class="headerlink" title="canvas手写板"></a>canvas手写板</h2><ul><li><a href="https://zc95.github.io/demo/canvas.html">demo</a></li><li><a href="https://github.com/zc95/canvas" target="_blank" rel="external">github</a><a id="more"></a><h2 id="扫一扫"><a href="#扫一扫" class="headerlink" title="扫一扫"></a>扫一扫</h2></li></ul><p><img width="150" src="https://ws4.sinaimg.cn/large/006tNc79gy1fp5r4kgijtj307s07st9m.jpg"></p><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp5tb8a00yj31401z40vt.jpg" height="600"></p><hr><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp5tb8s4tgj31401z4wjo.jpg" height="600"></p><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp5tbmm3ytj31401z4wj1.jpg" height="600"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 canvas 写了一个手写板，功能：画笔粗细、橡皮擦大小、画笔颜色、清空画布、历史操作等&lt;/p&gt;
&lt;h2 id=&quot;canvas手写板&quot;&gt;&lt;a href=&quot;#canvas手写板&quot; class=&quot;headerlink&quot; title=&quot;canvas手写板&quot;&gt;&lt;/a&gt;canvas手写板&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zc95.github.io/demo/canvas.html&quot;&gt;demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zc95/canvas&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;
    
    </summary>
    
      <category term="demo" scheme="http://zc95.github.io/categories/demo/"/>
    
    
      <category term="canvas" scheme="http://zc95.github.io/tags/canvas/"/>
    
      <category term="material design" scheme="http://zc95.github.io/tags/material-design/"/>
    
  </entry>
  
  <entry>
    <title>自己写了个音乐播放器</title>
    <link href="http://zc95.github.io/2018/02/21/musicPlayer/"/>
    <id>http://zc95.github.io/2018/02/21/musicPlayer/</id>
    <published>2018-02-21T04:45:29.000Z</published>
    <updated>2018-03-31T04:48:24.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="material-design风格的音乐播放器"><a href="#material-design风格的音乐播放器" class="headerlink" title="material design风格的音乐播放器"></a>material design风格的音乐播放器</h2><ul><li><a href="https://zc95.github.io/demo/music.html">demo</a></li><li><a href="https://github.com/zc95/music" target="_blank" rel="external">github</a><a id="more"></a><h2 id="扫一扫"><a href="#扫一扫" class="headerlink" title="扫一扫"></a>扫一扫</h2></li></ul><p><img width="150" src="https://ws3.sinaimg.cn/large/006tNc79gy1fonxkcugj3j307s07sq2p.jpg"></p><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fony99p9rfj30u01hcmzd.jpg" height="600"></p><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fony8j721lj30u01hcwhv.jpg" height="600"></p><h2 id="HTML-5-audio标签"><a href="#HTML-5-audio标签" class="headerlink" title="HTML 5 audio标签"></a>HTML 5 audio标签</h2><h3 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h3><p> 标签定义声音，比如音乐或其他音频流，是 HTML 5 的新标签。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre><code class="html">&lt;audio src=&quot;https://music.163.com/song/media/outer/url?id=451703096.mp3&quot;&gt;您的浏览器不支持 audio 标签。&lt;/audio&gt;</code></pre><h3 id="提示和注释"><a href="#提示和注释" class="headerlink" title="提示和注释"></a>提示和注释</h3><p>可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_autoplay.asp" target="_blank" rel="external">autoplay</a></td><td>autoplay</td><td>如果出现该属性，则音频在就绪后马上播放。</td></tr><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_controls.asp" target="_blank" rel="external">controls</a></td><td>controls</td><td>如果出现该属性，则向用户显示控件，比如播放按钮。</td></tr><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_loop.asp" target="_blank" rel="external">loop</a></td><td>loop</td><td>如果出现该属性，则每当音频结束时重新开始播放。</td></tr><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_preload.asp" target="_blank" rel="external">preload</a></td><td>preload</td><td>如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td></tr><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_src.asp" target="_blank" rel="external">src</a></td><td><em>url</em></td><td>要播放的音频的 URL。</td></tr></tbody></table><h2 id="Javascript控制html5-Audio标签"><a href="#Javascript控制html5-Audio标签" class="headerlink" title="Javascript控制html5 Audio标签"></a>Javascript控制html5 Audio标签</h2><h3 id="javascript动态创建audio标签"><a href="#javascript动态创建audio标签" class="headerlink" title="javascript动态创建audio标签"></a>javascript动态创建audio标签</h3><pre><code class="javascript">var audio=document.creatElement(&quot;audio&quot;);audio.src=&quot;audio/source.ogg&quot;;//路径audio.play();</code></pre><p>or</p><pre><code class="javascript">audio=new Audio(&quot;audio/source.ogg&quot;);//路径audio.play();</code></pre><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>我们可以通过preload=”auto”来实现音频的自动加载，但是我们无法知道音频加载的进度</p><p>这时候可以用canplaythrough来完成</p><pre><code class="javascript">var audio = document.createElement(&quot;audio&quot;);audio.src = &quot;https://music.163.com/song/media/outer/url?id=451703096.mp3&quot;;audio.addEventListener(&quot;canplaythrough&quot;, function () {    alert(&#39;音频文件已经准备好，随时待命&#39;);}, false);</code></pre><p>第一次运行时间会长一些，第二次运行由于文件已经缓存到本地，所以会直接弹出提示框。</p><h3 id="javascript控制audio的播放，暂停，停止"><a href="#javascript控制audio的播放，暂停，停止" class="headerlink" title="javascript控制audio的播放，暂停，停止"></a>javascript控制audio的播放，暂停，停止</h3><pre><code class="javascript">function aPlay() {    audio.play();}function aPause() {    audio.pause();}function aStop() {    audio.currentTime = 0;    audio.pause();}function aSkip() {    audio.currentTime = 50;    audio.play(); }</code></pre><pre><code class="javascript">&lt;input type=&quot;button&quot; onclick=&quot;aPlay();&quot; value=&quot;播放音频&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;aPause();&quot; value=&quot;暂停音频&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;aStop();&quot; value=&quot;停止音频&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;aSkip();&quot; value=&quot;跳到第50秒&quot;&gt;</code></pre><h3 id="javascript控制audio的声音大小"><a href="#javascript控制audio的声音大小" class="headerlink" title="javascript控制audio的声音大小"></a>javascript控制audio的声音大小</h3><blockquote><p>audio.volume = 0;//表示静音  </p><p>audio.volume = 1; //表示声音最大</p><p>audio.volume //返回当前音量，声音值在0-1之间</p></blockquote><h3 id="javascript控制audio的快进，快退，以及显示进度与时长"><a href="#javascript控制audio的快进，快退，以及显示进度与时长" class="headerlink" title="javascript控制audio的快进，快退，以及显示进度与时长"></a>javascript控制audio的快进，快退，以及显示进度与时长</h3><blockquote><p>audio.currentTime //控制audio的进度</p><p>audio.duration //返回当前音量的总时长</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;material-design风格的音乐播放器&quot;&gt;&lt;a href=&quot;#material-design风格的音乐播放器&quot; class=&quot;headerlink&quot; title=&quot;material design风格的音乐播放器&quot;&gt;&lt;/a&gt;material design风格的音乐播放器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zc95.github.io/demo/music.html&quot;&gt;demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zc95/music&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;
    
    </summary>
    
      <category term="demo" scheme="http://zc95.github.io/categories/demo/"/>
    
    
      <category term="material design" scheme="http://zc95.github.io/tags/material-design/"/>
    
  </entry>
  
  <entry>
    <title>教你下载会员歌曲</title>
    <link href="http://zc95.github.io/2018/02/19/musicLink/"/>
    <id>http://zc95.github.io/2018/02/19/musicLink/</id>
    <published>2018-02-19T15:19:04.000Z</published>
    <updated>2018-03-31T04:48:47.851Z</updated>
    
    <content type="html"><![CDATA[<p>教你找歌曲的外链（要会员的歌曲都能下载🤪）</p><h2 id="什么是歌曲的外链？"><a href="#什么是歌曲的外链？" class="headerlink" title="什么是歌曲的外链？"></a>什么是歌曲的外链？</h2><p>我们手机里的歌曲都是下载好的mp3文件，比如说散就散.mp3，</p><p>而外链就比如 <a href="https://music.163.com/song/media/outer/url?id=523251118.mp3" target="_blank" rel="external">https://music.163.com/song/media/outer/url?id=523251118.mp3</a> 这样链接的形式。</p><a id="more"></a><h2 id="怎么免费下载会员歌曲？"><a href="#怎么免费下载会员歌曲？" class="headerlink" title="怎么免费下载会员歌曲？"></a>怎么免费下载会员歌曲？</h2><p>你应该注意到了《说散就散》在qq音乐和网易云都是要vip才能下载</p><p><img style="height:400px; display:inline-block;" src="https://ws4.sinaimg.cn/large/006tNc79gy1fom4irp01wj30nq1600x0.jpg"></p><p><img style="height:400px; display:inline-block;" src="https://ws1.sinaimg.cn/large/006tNc79gy1fom4m03u1bj30no15y77v.jpg"></p><p>这里以网易云音乐的网页版为例说一下”破解“的方法</p><p>这个外链下载会员歌曲的方法也是最近撸一个播放器的时候发现的 <a href="https://zc95.github.io/demo/music">https://zc95.github.io/demo/music</a> （还在改进，下次再说吧 ，逃。。。）</p><h2 id="废话少说，开始了"><a href="#废话少说，开始了" class="headerlink" title="废话少说，开始了"></a>废话少说，开始了</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>打开你电脑上的浏览器，输入 <a href="http://music.163.com" target="_blank" rel="external">http://music.163.com</a> ，网易云音乐官网，输入 “说散就散” 搜索，点第一个要钱的原唱！</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>到了 <a href="http://music.163.com/#/song?id=523251118" target="_blank" rel="external">http://music.163.com/#/song?id=523251118</a> 这个页面</p><ol><li>这个什么 <code>生成外链播放器</code> 不用管，就是个iframe（一般用来博客里），点了提示没版权，放弃。。。</li><li>还有下载按钮，点了提示下载PC端和app，肯定还是要会员。。。放弃</li><li><strong>重点是url，有个?id = xxxxx ，原来百度云网页版的每首歌都有自己的id标识</strong></li></ol><p><img style="height:400px;" src="https://ws2.sinaimg.cn/large/006tNc79gy1fom543cxz3j317i0tgq8q.jpg"></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>从url得到这首歌的id是 <code>523251118</code></p><p>所以这首歌的外链就是 <a href="https://music.163.com/song/media/outer/url?id=523251118.mp3" target="_blank" rel="external">https://music.163.com/song/media/outer/url?id=523251118.mp3</a> ，之后找到别的歌，把这个链接的id替换了就行，除了那种网易云没播放版权的，所有的都可以。</p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>打开电脑里的浏览器，输入 <a href="https://music.163.com/song/media/outer/url?id=523251118.mp3" target="_blank" rel="external">https://music.163.com/song/media/outer/url?id=523251118.mp3</a> 回车，这时候url被解析成好长的一段，不用管它，有上面的链接就足够了，点html5 video标签上的下载按钮就行啦（如下），移动端和Safari的video应该是没有下载按钮的。。。</p><video controls name="media"><source src="https://music.163.com/song/media/outer/url?id=523251118.mp3" type="audio/mpeg"></video><h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>如果是安卓机的就直接把这首歌导入到手机里去，qq音乐、网易云都会自动加到列表里去。</p><p>如果是iphone，，，那就没啥吊用了。。。。</p><hr><p>最后说一下，有很多方法下载这种会员歌曲，，发现这种方法是因为最近在手撸一个音乐播放器，需要用到这样的链接<a href="https://zc95.github.io/demo/music">https://zc95.github.io/demo/music</a> </p><p>不然才不费这么大劲。。毕竟我有破解版😂😂😂</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fom5ymxc3aj31ik11egs4.jpg" alt="https://ws1.sinaimg.cn/large/006tNc79gy1fom5ymxc3aj31ik11egs4.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;教你找歌曲的外链（要会员的歌曲都能下载🤪）&lt;/p&gt;
&lt;h2 id=&quot;什么是歌曲的外链？&quot;&gt;&lt;a href=&quot;#什么是歌曲的外链？&quot; class=&quot;headerlink&quot; title=&quot;什么是歌曲的外链？&quot;&gt;&lt;/a&gt;什么是歌曲的外链？&lt;/h2&gt;&lt;p&gt;我们手机里的歌曲都是下载好的mp3文件，比如说散就散.mp3，&lt;/p&gt;
&lt;p&gt;而外链就比如 &lt;a href=&quot;https://music.163.com/song/media/outer/url?id=523251118.mp3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://music.163.com/song/media/outer/url?id=523251118.mp3&lt;/a&gt; 这样链接的形式。&lt;/p&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="歌曲" scheme="http://zc95.github.io/tags/%E6%AD%8C%E6%9B%B2/"/>
    
  </entry>
  
  <entry>
    <title>Rich Text Format</title>
    <link href="http://zc95.github.io/2018/02/06/RTF/"/>
    <id>http://zc95.github.io/2018/02/06/RTF/</id>
    <published>2018-02-06T15:20:53.000Z</published>
    <updated>2018-03-31T04:49:02.246Z</updated>
    
    <content type="html"><![CDATA[<p>自己写的一个移动端的富文本编辑器</p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><ul><li><a href="https://htmlpreview.github.io/?https://github.com/zc95/RTF/blob/master/index.html" target="_blank" rel="external">demo</a></li><li><a href="https://github.com/zc95/RTF" target="_blank" rel="external">github</a><a id="more"></a></li></ul><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fo74tsp0mij31401z4aeo.jpg" style="height:500px;"></p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fo74ugdi9qj31401z4q72.jpg" style="height:500px;"><br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo74v4k9udj31401z40wu.jpg" style="height:500px;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己写的一个移动端的富文本编辑器&lt;/p&gt;
&lt;h2 id=&quot;Link&quot;&gt;&lt;a href=&quot;#Link&quot; class=&quot;headerlink&quot; title=&quot;Link&quot;&gt;&lt;/a&gt;Link&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://htmlpreview.github.io/?https://github.com/zc95/RTF/blob/master/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zc95/RTF&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="html" scheme="http://zc95.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>一行代码实现星级评分</title>
    <link href="http://zc95.github.io/2018/01/23/star-rating/"/>
    <id>http://zc95.github.io/2018/01/23/star-rating/</id>
    <published>2018-01-23T13:03:13.000Z</published>
    <updated>2018-01-30T15:23:57.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fnqvphubb8j30lu0dodhh.jpg" alt=""></p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><ul><li><a href="https://htmlpreview.github.io/?https://github.com/zc95/star-rating/blob/master/index.html" target="_blank" rel="external">demo</a></li><li><a href="https://github.com/zc95/star-rating" target="_blank" rel="external">github</a></li></ul><a id="more"></a><h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><pre><code class="css">.score_wrapper {      display:inline-block;      font-size: 45px;      cursor: pointer;      color: #dc2020;      -webkit-user-select:none;      -moz-user-select:none;      -ms-user-select:none;      user-select:none;    }</code></pre><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><pre><code class="html">&lt;div class=&quot;score_wrapper&quot;&gt;&lt;/div&gt;</code></pre><h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><pre><code class="javascript">    $(function () {      ScoreInit(3); //初始化，参数是0～5的数字，代表星数，传空默认0颗星    })    //点击    function ScoreInit(e) {      Score((e == null) ? 0 : e); //传空默认0颗星      $(&quot;.score_wrapper&quot;).bind(&#39;click&#39;, function (e) {        var eachWidth = $(&quot;.score_wrapper&quot;).width() / 5; //计算出每个星星的长度        var X = e.pageX - $(this).offset().left; //距离父容器的偏移距离        var score = Math.floor(X / eachWidth) + 1; //分数        Score((getScore() == score) ? 0 : score); //取消评分      })    }    //评分    function Score(rate) {      $(&quot;.score_wrapper&quot;).html(&quot;★★★★★☆☆☆☆☆&quot;.slice(5 - rate, 10 - rate));    }    //获取评分    function getScore() {      var str = $(&quot;.score_wrapper&quot;).html(), num = 0;      for (var i = 0; i &lt; str.length; i++) {        if (str[i] == &quot;★&quot;) {          num++        }      }      return num;    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1fnqvphubb8j30lu0dodhh.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Link&quot;&gt;&lt;a href=&quot;#Link&quot; class=&quot;headerlink&quot; title=&quot;Link&quot;&gt;&lt;/a&gt;Link&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://htmlpreview.github.io/?https://github.com/zc95/star-rating/blob/master/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zc95/star-rating&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="html" scheme="http://zc95.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>水平垂直居中</title>
    <link href="http://zc95.github.io/2018/01/10/centerAndmiddle/"/>
    <id>http://zc95.github.io/2018/01/10/centerAndmiddle/</id>
    <published>2018-01-10T13:17:24.000Z</published>
    <updated>2018-01-10T14:26:16.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="水平垂直居中（已知宽高）"><a href="#水平垂直居中（已知宽高）" class="headerlink" title="水平垂直居中（已知宽高）"></a>水平垂直居中（已知宽高）</h2><p>方法很多，这里就说一个不常见的</p><pre><code class="Html">&lt;div class=&quot;father&quot;&gt;  &lt;div class=&quot;son&quot;&gt;    &lt;p&gt;zc95.github.io&lt;/p&gt;    &lt;p&gt;zc95.github.io&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.father {  position: relative;  width: 300px;  height: 300px;  border: 1px solid black;}.son {  position: absolute;  width: 60px;  height: 60px;  top: 0;  left: 0;  bottom: 0;  right: 0;  margin: auto;  border: 1px solid gray;}</code></pre><a id="more"></a><hr><h2 id="水平垂直居中（宽高不确定-伪元素）"><a href="#水平垂直居中（宽高不确定-伪元素）" class="headerlink" title="水平垂直居中（宽高不确定/伪元素）"></a>水平垂直居中（宽高不确定/伪元素）</h2><p>用伪元素和 inline-block / vertical-align 可以实现水平垂直居中</p><pre><code class="html">&lt;div class=&quot;father&quot;&gt;  &lt;div class=&quot;son&quot;&gt;    &lt;p&gt;zc95.github.io&lt;/p&gt;    &lt;p&gt;zc95.github.io&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.father {  position:fixed;  top:0;  right:0;  left:0;  bottom:0;  text-align: center;  border: 1px solid black;}.father:before {  content: &#39;&#39;;  display: inline-block;  height: 100%;  vertical-align: middle;  margin-right: -0.25em; /*去空隙*/}.son {  display: inline-block;  vertical-align: middle;  border: 1px solid gray;}</code></pre><hr><h2 id="水平垂直居中（宽高不确定-flex）"><a href="#水平垂直居中（宽高不确定-flex）" class="headerlink" title="水平垂直居中（宽高不确定/flex）"></a>水平垂直居中（宽高不确定/flex）</h2><p>css弹性布局（flex）</p><pre><code class="html">&lt;div class=&quot;father&quot;&gt;  &lt;div class=&quot;son&quot; style=&quot;display:inline-block;&quot;&gt;    &lt;p&gt;zc95.github.io&lt;/p&gt;    &lt;p&gt;zc95.github.io&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.father {  height: 300px;  width: 100%;  display: flex;  align-items: center; /*定义body的元素垂直居中*/  justify-content: center; /*定义body的里的元素水平居中*/}.son{  border:1px solid gray;}</code></pre><hr><h2 id="水平垂直居中（宽高不确定-transform）"><a href="#水平垂直居中（宽高不确定-transform）" class="headerlink" title="水平垂直居中（宽高不确定/transform）"></a>水平垂直居中（宽高不确定/transform）</h2><p>CSS3的transform，通过设置div的transform: translate(-50%,-50%)，使得div向上平移（translate）自身高度的一半(50%)、自身宽度的一半(50%)</p><pre><code class="html">&lt;div class=&quot;son&quot;&gt;  &lt;p&gt;zc95.github.io&lt;/p&gt;  &lt;p&gt;zc95.github.io&lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="css">.son {  position: absolute;  top: 50%;  left: 50%;  -webkit-transform: translate(-50%,-50%);  -moz-transform: translate(-50%,-50%);  -ms-transform: translate(-50%,-50%);  transform: translate(-50%,-50%);  border: 1px solid gray;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;水平垂直居中（已知宽高）&quot;&gt;&lt;a href=&quot;#水平垂直居中（已知宽高）&quot; class=&quot;headerlink&quot; title=&quot;水平垂直居中（已知宽高）&quot;&gt;&lt;/a&gt;水平垂直居中（已知宽高）&lt;/h2&gt;&lt;p&gt;方法很多，这里就说一个不常见的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Html&quot;&gt;&amp;lt;div class=&amp;quot;father&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;son&amp;quot;&amp;gt;
    &amp;lt;p&amp;gt;zc95.github.io&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;zc95.github.io&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.father {
  position: relative;
  width: 300px;
  height: 300px;
  border: 1px solid black;
}

.son {
  position: absolute;
  width: 60px;
  height: 60px;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  margin: auto;
  border: 1px solid gray;
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="css" scheme="http://zc95.github.io/tags/css/"/>
    
      <category term="水平垂直居中" scheme="http://zc95.github.io/tags/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>ToDo 待办事宜app</title>
    <link href="http://zc95.github.io/2018/01/07/ToDo/"/>
    <id>http://zc95.github.io/2018/01/07/ToDo/</id>
    <published>2018-01-07T10:29:58.000Z</published>
    <updated>2018-01-07T12:54:37.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo"></a>ToDo</h2><p>最近做事情总是丢三落四，老忘记一些重要的事情，就突发奇想写了这个 <code>ToDo</code> 待办事宜的app。</p><ol><li><a href="https://htmlpreview.github.io/?https://github.com/zc95/ToDo/blob/master/index.html#" target="_blank" rel="external">项目地址</a></li><li><a href="https://github.com/zc95/ToDo" target="_blank" rel="external">github地址</a></li></ol><p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;display:inline-block;" src="https://ws2.sinaimg.cn/large/006tNc79gy1fn8bgdbyhbj30xr1o04b6.jpg" height="500px;"><br><img style="box-shadow:1px 1px 10px #888888;display:inline-block;" src="https://ws4.sinaimg.cn/large/006tNc79gy1fn8bo7m0uqj30xr1o0tgz.jpg" height="500px;"><br></p><a id="more"></a><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ol><li>可以添加待办事项到首页中，数据都是保存在本地localStorage的，只要不是手动删除或者换了设备，数据是永久保存的</li><li>点击事项可以将待办事项的状态改为 <code>选中</code> 和 <code>未选中</code> ，每次改变状态都会保存到localStorage，每天的开始都可以点 <code>重置所有状态</code> 的按钮来设置所有的待办事项为未选中</li><li>可以删除已添加的待办事项或者彻底删除所有本地localStorage数据</li></ol><p>可以复制项目链接在自己的浏览器中打开，然后添加到桌面，方便使用；<br><a href="https://htmlpreview.github.io/?https://github.com/zc95/ToDo/blob/master/index.html" target="_blank" rel="external">https://htmlpreview.github.io/?https://github.com/zc95/ToDo/blob/master/index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ToDo&quot;&gt;&lt;a href=&quot;#ToDo&quot; class=&quot;headerlink&quot; title=&quot;ToDo&quot;&gt;&lt;/a&gt;ToDo&lt;/h2&gt;&lt;p&gt;最近做事情总是丢三落四，老忘记一些重要的事情，就突发奇想写了这个 &lt;code&gt;ToDo&lt;/code&gt; 待办事宜的app。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://htmlpreview.github.io/?https://github.com/zc95/ToDo/blob/master/index.html#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;项目地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zc95/ToDo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github地址&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;text-align:center;&quot;&gt;&lt;br&gt;&lt;img style=&quot;box-shadow:1px 1px 10px #888888;display:inline-block;&quot; src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fn8bgdbyhbj30xr1o04b6.jpg&quot; height=&quot;500px;&quot;&gt;&lt;br&gt;&lt;img style=&quot;box-shadow:1px 1px 10px #888888;display:inline-block;&quot; src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fn8bo7m0uqj30xr1o0tgz.jpg&quot; height=&quot;500px;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="demo" scheme="http://zc95.github.io/categories/demo/"/>
    
    
      <category term="localStorage" scheme="http://zc95.github.io/tags/localStorage/"/>
    
  </entry>
  
  <entry>
    <title>VMware服务器虚拟化</title>
    <link href="http://zc95.github.io/2017/12/26/VMware/"/>
    <id>http://zc95.github.io/2017/12/26/VMware/</id>
    <published>2017-12-26T12:49:24.000Z</published>
    <updated>2017-12-26T13:10:59.660Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="https://ws2.sinaimg.cn/large/006tNc79gy1fmucwl7r2aj31hc0u0dng.jpg" width="90%;"><br></p><p>今天去机房打了一天酱油，听到了看到了一些没接触过的东西，做个简单的整理。</p><h2 id="VMware服务器虚拟化"><a href="#VMware服务器虚拟化" class="headerlink" title="VMware服务器虚拟化"></a>VMware服务器虚拟化</h2><p><a href="https://www.vmware.com/cn/solutions/virtualization.html" target="_blank" rel="external">VMware官网</a></p><p>大多数服务器的容量利用率不足 15%，这不仅导致了服务器数量剧增，还增加了复杂性。实现服务器虚拟化后，多个操作系统可以作为虚拟机在单台物理服务器上运行，并且每个操作系统都可以访问底层服务器的计算资源，从而解决效率低下问题。接下来将服务器集群聚合为一项整合资源，这可以提高整体效率并降低成本。服务器虚拟化还可以加快工作负载部署速度、提高应用性能以及改善可用性。</p><a id="more"></a><h3 id="虚拟化的优势"><a href="#虚拟化的优势" class="headerlink" title="虚拟化的优势"></a>虚拟化的优势</h3><p>虚拟化可以提高 IT 部门的敏捷性、灵活性和可扩展性，同时大幅节约成本。工作负载的部署速度更快、性能和可用性得到提升、运维实现自动化，所有这一切不仅简化了 IT 管理，还降低了拥有成本和运维成本。其他优势包括：</p><ol><li>降低资金成本和运维成本。</li><li>最大限度地减少或消除停机。</li><li>提高 IT 部门的工作效率、效益、敏捷性和响应能力。</li><li>更快地调配应用和资源。</li><li>支持业务连续性与灾难恢复。</li><li>简化数据中心管理。</li><li>构建真正的软件定义的数据中心</li></ol><h3 id="VMware-vSphere-client"><a href="#VMware-vSphere-client" class="headerlink" title="VMware vSphere client"></a>VMware vSphere client</h3><p>用来连接<a href="https://www.baidu.com/s?wd=VMware&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3rARvrjnvm19bPHfsnA790ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHT4P16dPHm3rjcdnW0drHnsPs" target="_blank" rel="external">VMware</a> ESXi主机和vCenter server，业内最完整、 最强健的虚拟化平台。创建资源池来管理计算、 网络和存储容量与易用性，并提供最高水平的服务，每个应用程序工作负载以最低的总成本。VSphere — — 取决于世界上要求最苛刻的数据中心虚拟化您业务关键型应用程序为空前的灵活性和可靠性。</p><h2 id="UPS电源"><a href="#UPS电源" class="headerlink" title="UPS电源"></a>UPS电源</h2><p><a href="https://baike.baidu.com/item/不间断电源" target="_blank" rel="external">百度百科</a></p><p>UPS电源一般指不间断电源。</p><p><a href="https://baike.baidu.com/item/UPS" target="_blank" rel="external">UPS</a>（Uninterruptible Power System/Uninterruptible Power Supply），即不间断<a href="https://baike.baidu.com/item/%E7%94%B5%E6%BA%90" target="_blank" rel="external">电源</a>，是将<a href="https://baike.baidu.com/item/%E8%93%84%E7%94%B5%E6%B1%A0" target="_blank" rel="external">蓄电池</a>（多为铅酸免维护蓄电池）与主机相连接，通过主机逆变器等模块电路将直流电转换成市电的系统设备。主要用于给单台<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="external">计算机</a>、计算机网络系统或其它<a href="https://baike.baidu.com/item/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E8%AE%BE%E5%A4%87" target="_blank" rel="external">电力电子设备</a>如电磁阀、压力变送器等提供稳定、不间断的电力供应。当市电输入正常时，UPS 将市电稳压后供应给<a href="https://baike.baidu.com/item/%E8%B4%9F%E8%BD%BD" target="_blank" rel="external">负载</a>使用，此时的UPS就是一台交流式电<a href="https://baike.baidu.com/item/%E7%A8%B3%E5%8E%8B%E5%99%A8" target="_blank" rel="external">稳压器</a>，同时它还向机内电池充电；当市电中断（事故停电）时， UPS 立即将电池的直流电能，通过逆变器切换转换的<a href="https://baike.baidu.com/item/%E6%96%B9%E6%B3%95" target="_blank" rel="external">方法</a>向负载继续供应220V<a href="https://baike.baidu.com/item/%E4%BA%A4%E6%B5%81%E7%94%B5" target="_blank" rel="external">交流电</a>，使负载维持正常工作并保护负载软、<a href="https://baike.baidu.com/item/%E7%A1%AC%E4%BB%B6" target="_blank" rel="external">硬件</a>不受损坏。UPS 设备通常对电压过高或电压过低都能提供保护。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><strong>UPS</strong>是针对中国电网环境和<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7" target="_blank" rel="external">网络监控</a>及<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="external">网络系统</a>、<a href="https://baike.baidu.com/item/%E5%8C%BB%E7%96%97" target="_blank" rel="external">医疗</a>系统等对<a href="https://baike.baidu.com/item/%E7%94%B5%E6%BA%90" target="_blank" rel="external">电源</a>的可靠性要求，克服中、大型<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="external">计算机</a>网络系统集中供电所造成的供电电网环境日益恶劣的问题，以全新的数字技术研制出的第三代工频纯在线式智能型UPS。直流电源，是维持电路中形成稳恒电流的装置。如干电池、蓄电池、<a href="https://baike.baidu.com/item/%E7%9B%B4%E6%B5%81%E5%8F%91%E7%94%B5%E6%9C%BA" target="_blank" rel="external">直流发电机</a>等。</li><li><strong>UPS</strong>和<a href="https://baike.baidu.com/item/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%BA%90" target="_blank" rel="external">直流电源</a>是企业重要的供电保障设备，传统的维护管理包括：①日常巡检外观，定期更换电池、<a href="https://baike.baidu.com/item/%E6%BB%A4%E6%B3%A2%E7%94%B5%E5%AE%B9" target="_blank" rel="external">滤波电容</a>、<a href="https://baike.baidu.com/item/%E9%A3%8E%E6%9C%BA" target="_blank" rel="external">风机</a>等易损件，大修时做电池活化等；②改造或采用换代设备，使用高级工具测试电池性能。这种管理方式企业投入成本高，维护人员工作量大，不易实时掌握设备运行状态和关键数据，设备事故预防能力低。实施在线维护管理可避免传统方式的不足之处，获得良好效益。</li><li><strong>UPS</strong>的中文意思为“不间断电源”，是英语“Uninterruptible Power System/Uninterruptible Power Supply”的缩写，它可以保障计算机系统在停电之后继续工作一段时间以使用户能够紧急<a href="https://baike.baidu.com/item/%E5%AD%98%E7%9B%98" target="_blank" rel="external">存盘</a>，使用户不致因停电而影响工作或丢失<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE" target="_blank" rel="external">数据</a>。</li></ol><hr><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p><a href="https://baike.baidu.com/item/cisco交换机" target="_blank" rel="external">百度百科</a></p><p>交换机（Switch）意为“<a href="https://baike.baidu.com/item/%E5%BC%80%E5%85%B3/2275072" target="_blank" rel="external">开关</a>”是一种用于电（光）信号转发的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87" target="_blank" rel="external">网络设备</a>。它可以为接入交换机的任意两个<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E8%8A%82%E7%82%B9" target="_blank" rel="external">网络节点</a>提供独享的电信号通路。最常见的交换机是<a href="https://baike.baidu.com/item/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA" target="_blank" rel="external">以太网交换机</a>。其他常见的还有电话语音交换机、<a href="https://baike.baidu.com/item/%E5%85%89%E7%BA%A4%E4%BA%A4%E6%8D%A2%E6%9C%BA" target="_blank" rel="external">光纤交换机</a>等。</p><p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="https://ws1.sinaimg.cn/large/006tNc79gy1fmudmq5dhvj31hc1han99.jpg" width="90%;"><br></p><p>图片上是 <code>Cisco Catalyst 4500-E Series</code> ，<a href="https://www.cisco.com/c/zh_cn/products/switches/catalyst-4500-x-series-switches/index.html?POSITION=SEM&amp;COUNTRY_SITE=cn&amp;CAMPAIGN=EN-04+Switches&amp;CREATIVE=APJC_GMP_EN-04_CN-Switches%2bSwitches%7cModel-45E&amp;REFERRING_SITE=Baidu&amp;KEYWORD=catalyst+4500E&amp;CCID=cc000010&amp;DTID=psebdu000360&amp;gclid=CMD8q-zEp9gCFVLZvAodLsEBXg&amp;gclsrc=ds" target="_blank" rel="external">Cisco Catalyst 4500-X 系列交换机</a></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>交换（switching）</strong>是按照通信两端传输信息的需要，用人工或设备自动完成的方法，把要传输的信息送到符合要求的相应路由上的技术的统称。根据工作位置的不同，可以分为<a href="https://baike.baidu.com/item/%E5%B9%BF%E5%9F%9F%E7%BD%91" target="_blank" rel="external">广域网</a>交换机和<a href="https://baike.baidu.com/item/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA" target="_blank" rel="external">局域网交换机</a>。广义的<strong>交换机（switch）</strong>就是一种在通信系统中完成信息交换功能的设备。</p><p>在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="external">计算机网络系统</a>中，交换概念的提出改进了共享工作模式。我们以前介绍过的HUB集线器就是一种共享设备，HUB本身不能识别目的地址，当同一局域网内的A主机给B主机传输数据时，<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85" target="_blank" rel="external">数据包</a>在以HUB为架构的网络上是以广播方式传输的，由每一台终端通过验证数据包头的地址信息来确定是否接收。也就是说，在这种工作方式下，同一时刻网络上只能传输一组<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%B8%A7" target="_blank" rel="external">数据帧</a>的通讯，如果发生碰撞还得重试。这种方式就是共享<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%B8%A6%E5%AE%BD" target="_blank" rel="external">网络带宽</a>。</p><hr><h2 id="hub"><a href="#hub" class="headerlink" title="hub"></a>hub</h2><p><a href="https://baike.baidu.com/item/HUB" target="_blank" rel="external">百度百科</a></p><p>HUB是一个多端口的<a href="https://baike.baidu.com/item/%E8%BD%AC%E5%8F%91%E5%99%A8" target="_blank" rel="external">转发器</a>，在以HUB为中心设备时，即使网络中某条线路产生了故障，并不影响其它线路的工作。所以HUB在<a href="https://baike.baidu.com/item/%E5%B1%80%E5%9F%9F%E7%BD%91" target="_blank" rel="external">局域网</a>中得到了广泛的应用。大多数的时候它用在星型与<a href="https://baike.baidu.com/item/%E6%A0%91%E5%9E%8B%E7%BD%91%E7%BB%9C" target="_blank" rel="external">树型网络</a>拓扑结构中，以RJ45接口与各主机相连（也有<a href="https://baike.baidu.com/item/BNC%E6%8E%A5%E5%8F%A3" target="_blank" rel="external">BNC接口</a>），HUB按照不同的说法有很多种类。 HUB按照对输入信号的处理方式上，可以分为无源HUB、有源HUB、智能HUB。</p><hr><h2 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h2><p><a href="https://baike.baidu.com/item/磁盘阵列" target="_blank" rel="external">百度百科</a></p><p>磁盘阵列（Redundant Arrays of Independent Disks，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。</p><p>磁盘阵列是由很多价格较便宜的<a href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98" target="_blank" rel="external">磁盘</a>，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。利用这项技术，将数据切割成许多区段，分别存放在各个硬盘上。</p><p>磁盘阵列还能利用同位检查（Parity Check）的观念，在<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84" target="_blank" rel="external">数组</a>中任意一个<a href="https://baike.baidu.com/item/%E7%A1%AC%E7%9B%98%E6%95%85%E9%9A%9C" target="_blank" rel="external">硬盘故障</a>时，仍可读出数据，在数据重构时，将数据经计算后重新置入新硬盘中。</p><hr><h2 id="堡垒机"><a href="#堡垒机" class="headerlink" title="堡垒机"></a>堡垒机</h2><p><a href="https://baike.baidu.com/item/堡垒机" target="_blank" rel="external">百度百科</a></p><p>堡垒机，即在一个特定的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83" target="_blank" rel="external">网络环境</a>下，为了保障网络和数据不受来自外部和内部用户的入侵和破坏，而运用各种技术手段实时收集和监控网络环境中每一个组成部分的系统状态、安全事件、网络活动，以便集中<a href="https://baike.baidu.com/item/%E6%8A%A5%E8%AD%A6" target="_blank" rel="external">报警</a>、及时处理及<a href="https://baike.baidu.com/item/%E5%AE%A1%E8%AE%A1/2140835" target="_blank" rel="external">审计</a>定责。</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>随着企事业单位IT系统的不断发展，网络规模和设备数量迅速扩大，日趋复杂的IT系统与不同背景的运维人员的行为给信息系统安全带来较大风险，主要表现在：</p><ol><li>多个用户使用同一个账号。这种情况主要出现在同一工作组中，由于工作需要，同时系统管理账号唯一，因此只能多用户共享同一账号。如果发生安全事故，不仅难以定位账号的实际使用者和责任人，而且无法对账号的使用范围进行有效控制，存在较大安全风险和隐患。</li></ol><ol><li><p>一个用户使用多个账号。目前，一个维护人员使用多个账号是较为普遍的情况，用户需要记忆多套口令同时在多套主机系统、网络设备之间切换，降低工作效率，增加工作复杂度。如下图所示：</p><p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="https://ws2.sinaimg.cn/large/006tNc79gy1fmuei2zoarj306405faa3.jpg" width="50%;"><br></p></li><li><p>缺少统一的权限管理平台，权限管理日趋繁重和无序；而且维护人员的权限大多是粗放管理，无法基于最小权限分配原则的用户权限管理，难以实现更细粒度的命令级权限控制，系统安全性无法充分保证。</p></li><li>无法制定统一的访问审计策略，审计粒度粗。各网络设备、主机系统、数据库是分别单独审计记录访问行为，由于没有统一审计策略，并且各系统自身审计日志内容深浅不一，难以及时通过系统自身审计发现违规操作行为和追查取证。</li><li>传统的网络安全审计系统无法对维护人员经常使用的SSH、RDP等加密、图形操作协议进行内容审计。</li></ol><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><h4 id="单点登录功能"><a href="#单点登录功能" class="headerlink" title="单点登录功能"></a>单点登录功能</h4><p>支持对X11、linux、unix、数据库、网络设备、安全设备等一系列授权账号进行密码的自动化周期更改，简化密码管理，让使用者无需记忆众多系统密码，即可实现自动登录目标设备，便捷安全。[1]<a href=""> </a></p><h4 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h4><p>设备支持统一账户管理策略，能够实现对所有服务器、网络设备、安全设备等账号进行集中管理，完成对账号整个生命周期的监控，并且可以对设备进行特殊角色设置如：<a href="https://baike.baidu.com/item/%E5%AE%A1%E8%AE%A1/2140835" target="_blank" rel="external">审计</a>巡检员、<a href="https://baike.baidu.com/item/%E8%BF%90%E7%BB%B4" target="_blank" rel="external">运维</a>操作员、<a href="https://baike.baidu.com/item/%E8%AE%BE%E5%A4%87" target="_blank" rel="external">设备</a>管理员等自定义设置，以满足审计需求</p><h4 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h4><p>设备提供统一的认证接口，对用户进行认证，支持身份认证模式包括 动态口令、静态密码、硬件key 、生物特征等多种认证方式，设备具有灵活的定制接口，可以与其他第三方认证服务器之间结合；安全的认证模式，有效提高了认证的安全性和可靠性。</p><h4 id="资源授权"><a href="#资源授权" class="headerlink" title="资源授权"></a>资源授权</h4><p>设备提供基于用户、目标设备、时间、协议类型<a href="https://baike.baidu.com/item/IP/224599" target="_blank" rel="external">IP</a>、行为等要素实现细粒度的操作授权，最大限度保护用户资源的安全</p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>设备支持对不同用户进行不同策略的制定，细粒度的访问控制能够最大限度的保护用户资源的安全，严防非法、越权访问事件的发生。</p><h4 id="操作审计"><a href="#操作审计" class="headerlink" title="操作审计"></a>操作审计</h4><p>设备能够对<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="external">字符串</a>、<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2/773307" target="_blank" rel="external">图形</a>、<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93" target="_blank" rel="external">文件传输</a>、<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="external">数据库</a>等全程操作行为审计；通过设备录像方式实时监控运维人员对操作系统、安全设备、网络设备、数据库等进行的各种操作，对违规行为进行事中控制。对终端指令信息能够进行精确搜索，进行录像精确定位。[2]<a href=""> </a></p>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;text-align:center;&quot;&gt;&lt;br&gt;&lt;img style=&quot;box-shadow:1px 1px 10px #888888;&quot; src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fmucwl7r2aj31hc0u0dng.jpg&quot; width=&quot;90%;&quot;&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;今天去机房打了一天酱油，听到了看到了一些没接触过的东西，做个简单的整理。&lt;/p&gt;
&lt;h2 id=&quot;VMware服务器虚拟化&quot;&gt;&lt;a href=&quot;#VMware服务器虚拟化&quot; class=&quot;headerlink&quot; title=&quot;VMware服务器虚拟化&quot;&gt;&lt;/a&gt;VMware服务器虚拟化&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.vmware.com/cn/solutions/virtualization.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VMware官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大多数服务器的容量利用率不足 15%，这不仅导致了服务器数量剧增，还增加了复杂性。实现服务器虚拟化后，多个操作系统可以作为虚拟机在单台物理服务器上运行，并且每个操作系统都可以访问底层服务器的计算资源，从而解决效率低下问题。接下来将服务器集群聚合为一项整合资源，这可以提高整体效率并降低成本。服务器虚拟化还可以加快工作负载部署速度、提高应用性能以及改善可用性。&lt;/p&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="VMware" scheme="http://zc95.github.io/tags/VMware/"/>
    
      <category term="服务器虚拟化" scheme="http://zc95.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="堡垒机" scheme="http://zc95.github.io/tags/%E5%A0%A1%E5%9E%92%E6%9C%BA/"/>
    
      <category term="磁盘阵列" scheme="http://zc95.github.io/tags/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/"/>
    
      <category term="交换机" scheme="http://zc95.github.io/tags/%E4%BA%A4%E6%8D%A2%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript闭包</title>
    <link href="http://zc95.github.io/2017/12/21/javascriptClosure/"/>
    <id>http://zc95.github.io/2017/12/21/javascriptClosure/</id>
    <published>2017-12-21T12:48:17.000Z</published>
    <updated>2017-12-26T13:11:21.185Z</updated>
    
    <content type="html"><![CDATA[<p>对于JavaScript的程序员来说，闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="external">MDN Closures</a></p><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>变量的作用域无非就是两种：全局变量和局部变量。当在函数中声明一个变量的时候，如果用关键字<code>var</code>来声明此变量，那么它就是局部变量，如果没有<code>var</code>那么就会成为全局变量。一般不建议用这种方式定义全局变量。而是用<code>var</code>将变量声明在函数的外面。</p><pre><code class="javascript">var name = &#39;小张&#39;;  // 全局变量function func() {    var name = &#39;小明&#39;;  // 局部变量    age = 12;  // 全局变量，建议少用这种全局变量的定义方式}</code></pre><a id="more"></a><p>在JavaScript中，函数可以用来创造函数作用域。函数内部可以看到外面的变量，而外面看不到函数里的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，直到搜索到全局变量为止。</p><pre><code class="javascript">var a = 1;var func1 = function(){    var b = 2;    var func2 = function(){        var c = 3;        console.log( b );  // 2        console.log( a );  // 1    }     func2();    console.log( c );  // 报错：c is not defined};func1();</code></pre><p>那么能不能从函数外部来访问局部变量呢？答案是可以。</p><pre><code class="javascript">var func = function() {    var number = 6;    return function() {        return number;    } };console.log( func()() );  // 6</code></pre><h2 id="变量的生存周期"><a href="#变量的生存周期" class="headerlink" title="变量的生存周期"></a>变量的生存周期</h2><p>全局变量的生存周期是永久的，除非我们主动的销毁这个全局变量。而对于局部变量来说，当退出函数时，这些局部变量就失去了生存的环境，所以会随着函数调用的结束而被销毁。<br>那么是否可以让局部变量在函数调用结束的时候不被销毁呢？来看下面这个例子：</p><pre><code class="javascript">var func = function() {    var a = 1;    return function() {        a++;        console.log( a );    }  };var f = func();f();  // 2f();  // 3f();  // 4</code></pre><p>从上面这个输出结果，我们可以看到局部变量a并没有随着f()的调用而被销毁。这是因为全局变量f保存着对func里面匿名函数的引用。而这个匿名函数是可以访问到局部变量a的，所以自然a也被保存下来了。所以这种情况下局部变量的生存周期就得以延续。上面这个匿名函数其实就是一个闭包。再来看一个闭包的经典应用。</p><pre><code class="javascript">// 假设有5个divvar nodes = document.getElementsByTagName( &#39;div&#39; );for ( var i = 0, l = nodes.length; i &lt; l; i++ ) {    nodes[i].onclick = function() {        console.log( i );    }}</code></pre><p>当真正执行这段代码的时候，发现无论点击那个div，最后打印的结果都是4。这是因为onclick事件是异步触发的，当事件触发的时候，for循环早已经结束，此时变量i的值已经是4。解决方案可以是用闭包把每次的i都保存起来：</p><pre><code class="javascript">for ( var i = 0, l = nodes.length; i &lt; l; i++ ) {    (function( i ) {        nodes[i].onclick = function() {            console.log( i );        }    })( i );}</code></pre><p>同理，我们编写一段代码用来判断对象类型：</p><pre><code class="javascript">var Type = {};for ( var i = 0, type; type = [ &#39;String&#39;, &#39;Array&#39;, &#39;Number&#39; ][ i++ ]; ) {    (function( type ) {        Type[ &#39;is&#39; + type ] = function( obj ) {            return Object.prototype.toString.call( obj ) === &#39;[object &#39; + type + &#39;]&#39;;        }    })( type );}Type.isArray( [] );  // trueType.isString( &#39;str&#39; );  // true</code></pre><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>官方的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因为这些变量也是该表达式的一部分。这个概念不好理解，我们可以简单得理解成闭包就是能够访问函数内部变量的函数。</p><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ul><li><p>可以在函数外部访问在函数内部定义的局部变量</p></li><li><p>延续局部变量的生存周期</p></li><li><p>封装变量<br>闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。假设有一个计算乘积的函数：</p><pre><code class="javascript">var mult = function() {    var  a = 1;    for ( var i = 0, l = arguments.length; i &lt; l; i++ ) {        a = a * arguments[i];    }    return a;};mult(2, 3, 4);  // 24</code></pre><p>mult函数接受一些<code>Number</code>类型的参数，并且返回他们的乘积。现再我们觉得对于那些相同参数来说，每次再进行计算是一种浪费，所以我们决定加入缓存机制来提高函数性能：</p><pre><code class="javascript">var cache = {};var mult = function() {    var args = Array.prototype.join.call( arguments, &#39;&#39; );    if ( cache[ args ] ) {        return cache[ args ];    }    var  a = 1;    for ( var i = 0, l = arguments.length; i &lt; l; i++ ) {        a = a * arguments[i];    }    return cache[ args ] = a;};</code></pre><p>我们看到cache这个变量仅仅在mult函数中被使用，所以为了避免cache污染全局变量，我们将它放到mult函数里面</p><pre><code class="javascript">var mult = (function() {    var cache = {};    return function() {        var args = Array.prototype.join.call( arguments, &#39;&#39; );        if ( cache[ args ] ) {            return cache[ args ];        }        var  a = 1;        for ( var i = 0, l = arguments.length; i &lt; l; i++ ) {           a = a * arguments[i];        }        return cache[ args ] = a;    }})();</code></pre><p>提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有利于代码的复用，如果这些小函数有一个良好的命名，那么它们本身就起到了一个很好的注释作用。</p><pre><code class="javascript">var mult = (function() {    var cache = {};    var calculate = function() {        var  a = 1;        for ( var i = 0, l = arguments.length; i &lt; l; i++ ) {           a = a * arguments[i];        }        return a;    };    return function() {        var args = Array.prototype.join.call( arguments, &#39;&#39; );        if ( cache[ args ] ) {            return cache[ args ];        }        return cache[ args ] = calculate.apply( null, arguments );    }})();</code></pre></li></ul><h2 id="闭包与内存管理"><a href="#闭包与内存管理" class="headerlink" title="闭包与内存管理"></a>闭包与内存管理</h2><p>局部变量本来应该在函数退出的时候就被结束引用，但如果局部变量被封装在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上来看，闭包确实会使一些数据无法被及时销毁。如果将来需要回收这些变量，我们可以手动把这些变量设为<code>null</code>。<br>跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域中保存着一些DOM节点，这个时候就有可能造成内存泄露。在IE9之前的浏览器中，由于BOM和DOM中的对象是使用C++对象以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是引用计数策略。在基于引用计数的垃圾收集机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。但我们只要把循环引用中的对象设为<code>null</code>即可解决这个问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于JavaScript的程序员来说，闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MDN Closures&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;变量的作用域&quot;&gt;&lt;a href=&quot;#变量的作用域&quot; class=&quot;headerlink&quot; title=&quot;变量的作用域&quot;&gt;&lt;/a&gt;变量的作用域&lt;/h2&gt;&lt;p&gt;变量的作用域无非就是两种：全局变量和局部变量。当在函数中声明一个变量的时候，如果用关键字&lt;code&gt;var&lt;/code&gt;来声明此变量，那么它就是局部变量，如果没有&lt;code&gt;var&lt;/code&gt;那么就会成为全局变量。一般不建议用这种方式定义全局变量。而是用&lt;code&gt;var&lt;/code&gt;将变量声明在函数的外面。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var name = &amp;#39;小张&amp;#39;;  // 全局变量
function func() {
    var name = &amp;#39;小明&amp;#39;;  // 局部变量
    age = 12;  // 全局变量，建议少用这种全局变量的定义方式
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="javascript" scheme="http://zc95.github.io/tags/javascript/"/>
    
      <category term="正则表达式" scheme="http://zc95.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://zc95.github.io/2017/12/20/RegularExpression/"/>
    <id>http://zc95.github.io/2017/12/20/RegularExpression/</id>
    <published>2017-12-20T10:48:26.000Z</published>
    <updated>2017-12-21T12:41:12.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PART-1-为什么使用正则表达式？"><a href="#PART-1-为什么使用正则表达式？" class="headerlink" title="PART 1-为什么使用正则表达式？"></a>PART 1-为什么使用正则表达式？</h2><ul><li><p>测试字符串内的模式</p><p>例如，可以测试输入字符串，以查看字符串内是否出现电话号码或信用卡号码模式。这称为数据验证</p></li><li><p>替换文本</p><p>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它</p></li><li><p>基于模式匹配从字符串中提取子字符串</p><p>可以查找文档内或输入域内特定的文本</p><a id="more"></a></li></ul><h2 id="PART-2-练习正则表达式"><a href="#PART-2-练习正则表达式" class="headerlink" title="PART 2-练习正则表达式"></a>PART 2-练习正则表达式</h2><p>我们可以在console控制台，regexper 或者 <code>IDE</code> 去练习正则表达式</p><ul><li><p>推荐一个JS正则可视化的在线工具，简单易懂：<a href="https://regexper.com" target="_blank" rel="external">regexper.com</a></p><p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="/img/regexper.png" width="90%;"><br></p></li><li><p>现在大部分IDE都会支持正则表达式匹配，如sublime：</p><p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="/img/sublimeRegexper.png" width="90%;"><br></p></li></ul><hr><h2 id="PART-3-举个🌰"><a href="#PART-3-举个🌰" class="headerlink" title="PART 3-举个🌰"></a>PART 3-举个🌰</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><blockquote><p>^[0-9]+abc$</p></blockquote><ul><li><code>^</code> 为匹配输入字符串的开始位置</li><li><code>[0-9]+</code> 匹配单个数字，<code>+</code> 匹配一个或者多个</li><li><code>abc$</code> 匹配字母 <code>abc</code> 结尾</li><li><code>$</code> 为匹配输入字符串的结束位置</li></ul><p>匹配以数字开头，并以abc结尾的字符串：</p><pre><code class="javascript">var str = &quot;123abc&quot;;var patt1 = /^[0-9]+abc$/;document.write(str.match(patt1));==&gt; 123ABC</code></pre><hr><h2 id="PART-4-基本正则字符"><a href="#PART-4-基本正则字符" class="headerlink" title="PART 4-基本正则字符"></a>PART 4-基本正则字符</h2><h3 id="基础字符含义"><a href="#基础字符含义" class="headerlink" title="基础字符含义"></a>基础字符含义</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="external">MDN Regular Expressions</a></p><table><thead><tr><th style="text-align:center">字符</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">\</td><td>转意，即通常在”\”后面的字符不按原来意义解释，如/b/匹配字符”b”，当b前面加了反斜杠后/\b/，转意为匹配一个单词的边界。</td></tr><tr><td style="text-align:center">^</td><td>匹配输入的开始<br><br> 例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。 当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#note" target="_blank" rel="external">补充字符集合</a>一节有详细介绍和示例。</td></tr><tr><td style="text-align:center">$</td><td>匹配输入的结束。 例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。</td></tr><tr><td style="text-align:center">*</td><td>匹配前面元字符0次或多次，<strong>/ba*/</strong> 将匹配b,ba,baa,baaa ，相当于{0, } <br><br> 例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西。</td></tr><tr><td style="text-align:center">+</td><td>匹配前面元字符1次或多次，/ba+/将匹配ba,baa,baaa，相当于{1, } <br><br>例如，/a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。</td></tr><tr><td style="text-align:center">?</td><td>匹配前面元字符0次或1次，相当于 {0,1}<br><br> 例如，/e?le?/ 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’<br><br> 如果<strong>紧跟在任何量词 *、 +、? 或 {} 的后面</strong>，将会使量词变为<strong>非贪婪</strong>的（匹配尽量少的字符），和缺省使用的<strong>贪婪模式</strong>（匹配尽可能多的字符）正好相反。<br><br> 例如，对 “123abc” 应用 /\d+/ 将会返回 “123”，如果使用 /\d+?/,那么就只会匹配到 “1”。<br> 还可以运用于先行断言，如本表的 <code>x(?=y)</code> 和 <code>x(?!y)</code> 条目中所述。</td></tr><tr><td style="text-align:center">.</td><td>匹配除换行符之外的任何单个字符<br><br> 例如，/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。</td></tr><tr><td style="text-align:center">x&#124;y</td><td>匹配x或y</td></tr><tr><td style="text-align:center">{n}</td><td>精确匹配n次</td></tr><tr><td style="text-align:center">{n,}</td><td>匹配n次以上</td></tr><tr><td style="text-align:center">{n,m}</td><td>匹配n-m次</td></tr><tr><td style="text-align:center"><strong>[^xyz ]</strong></td><td>字符集(character set)，匹配这个集合中的任一一个字符(或元字符)</td></tr><tr><td style="text-align:center">[\b]</td><td>匹配一个退格符</td></tr><tr><td style="text-align:center">\b</td><td>匹配一个单词的边界</td></tr><tr><td style="text-align:center">\B</td><td>匹配一个非单词边界</td></tr><tr><td style="text-align:center">\cX</td><td>这儿，X是一个控制符，/\cM/匹配Ctrl-M</td></tr><tr><td style="text-align:center">\d</td><td>匹配一个数字，/\d/ = /[0-9]/</td></tr><tr><td style="text-align:center">\D</td><td>匹配一个非字数字符，/\D/ = /[ ^0-9]/</td></tr><tr><td style="text-align:center">\f</td><td>匹配一个换页符</td></tr><tr><td style="text-align:center">\n</td><td>匹配一个换行符</td></tr><tr><td style="text-align:center">\r</td><td>匹配一个回车符</td></tr><tr><td style="text-align:center">\s</td><td>匹配一个空白字符，包括\n,\r,\f,\t,\v等</td></tr><tr><td style="text-align:center">\S</td><td>匹配一个非空白字符，等于 /[ ^\n\f\r\t\v]/</td></tr><tr><td style="text-align:center">\t</td><td>匹配一个制表符</td></tr><tr><td style="text-align:center">\v</td><td>匹配一个重直制表符</td></tr><tr><td style="text-align:center">\w</td><td>匹配字母或数字或下划线，等于[a-zA-Z_0-9] ( 能不能匹配汉字要视你的操作系统和你的应用环境而定</td></tr><tr><td style="text-align:center">\W</td><td>匹配一个不可以组成单词的字符，如[\W]匹配”5.98”中的，等于 [ ^a-zA-Z0-9]</td></tr></tbody></table><hr><h2 id="PART-5-使用正则表达式"><a href="#PART-5-使用正则表达式" class="headerlink" title="PART 5-使用正则表达式"></a>PART 5-使用正则表达式</h2><p>正则表达式可以被用于<code>RegExp</code>的<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/RegExp/exec" target="_blank" rel="external"><code>exec</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/RegExp/test" target="_blank" rel="external"><code>test</code></a>方法以及 <a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String" target="_blank" rel="external"><code>String</code></a>的<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/match" target="_blank" rel="external"><code>match</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="external"><code>replace</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/search" target="_blank" rel="external"><code>search</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="external"><code>split</code></a>方法。这些方法在<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference" target="_blank" rel="external">JavaScript 手册</a>中有详细的解释。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>exec</code></td><td>一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。</td></tr><tr><td><code>test</code></td><td>一个在字符串中测试是否匹配的RegExp方法，它返回true或false。</td></tr><tr><td><code>match</code></td><td>一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。</td></tr><tr><td><code>search</code></td><td>一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。</td></tr><tr><td><code>replace</code></td><td>一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。</td></tr><tr><td><code>split</code></td><td>一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PART-1-为什么使用正则表达式？&quot;&gt;&lt;a href=&quot;#PART-1-为什么使用正则表达式？&quot; class=&quot;headerlink&quot; title=&quot;PART 1-为什么使用正则表达式？&quot;&gt;&lt;/a&gt;PART 1-为什么使用正则表达式？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;测试字符串内的模式&lt;/p&gt;
&lt;p&gt;例如，可以测试输入字符串，以查看字符串内是否出现电话号码或信用卡号码模式。这称为数据验证&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;替换文本&lt;/p&gt;
&lt;p&gt;可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于模式匹配从字符串中提取子字符串&lt;/p&gt;
&lt;p&gt;可以查找文档内或输入域内特定的文本&lt;/p&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="正则表达式" scheme="http://zc95.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>用最简单的代码实现点击查看大图</title>
    <link href="http://zc95.github.io/2017/11/29/enlargeImg/"/>
    <id>http://zc95.github.io/2017/11/29/enlargeImg/</id>
    <published>2017-11-29T13:03:34.000Z</published>
    <updated>2017-12-21T12:42:50.170Z</updated>
    
    <content type="html"><![CDATA[<p>今天做了个点击查看大图的功能，只需要给img加一个class，不用写额外的html代码</p><p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="/img/enlargeImg.png" width="90%;"><br></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li><a href="https://htmlpreview.github.io/?https://github.com/zc95/enlargeImg/blob/master/index.html" target="_blank" rel="external">demo地址</a></li><li><a href="https://github.com/zc95/enlargeImg" target="_blank" rel="external">github地址</a><a id="more"></a><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2></li></ul><h3 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h3><pre><code class="html">&lt;img class=&quot;enlargeImg&quot; width=&quot;80&quot; src=&quot;https://zc95.github.io/img/avatar.png&quot;title=&quot;点击查看大图&quot; /&gt;</code></pre><p>重点：</p><ul><li>img标签</li><li>class=”enlargeImg”</li><li>限制图片宽度或高度为”小图片”，width=”80”</li><li>src有值</li><li>title=”点击查看大图”</li></ul><h3 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h3><pre><code class="css">.enlargeImg_wrapper {  display: none;  position: fixed;  z-index: 999;  top: 0;  right: 0;  bottom: 0;  left: 0;  background-repeat: no-repeat;  background-attachment: fixed;  background-position: center;  background-color: rgba(52, 52, 52, 0.8);  background-size: 50%;}img:hover,.enlargeImg_wrapper:hover {  cursor: pointer;}</code></pre><p>重点：</p><ul><li>半透明遮罩层 background-color: rgba(52, 52, 52, 0.8);</li><li>水平垂直居中 background-position: center;</li><li>放大后的图片大小 background-size: 50%;</li><li>如果受页面中别的定位元素的z-index影响，改z-index的值就行</li></ul><h3 id="js部分"><a href="#js部分" class="headerlink" title="js部分"></a>js部分</h3><pre><code class="javascript">$(function() {  enlargeImg();})//查看大图function enlargeImg() {  $(&quot;.enlargeImg&quot;).click(function() {    $(this).after(&quot;&lt;div onclick=&#39;closeImg()&#39; class=&#39;enlargeImg_wrapper&#39;&gt;&lt;/div&gt;&quot;);    var imgSrc = $(this).attr(&#39;src&#39;);    $(&quot;.enlargeImg_wrapper&quot;).css(&quot;background-image&quot;, &quot;url(&quot; + imgSrc + &quot;)&quot;);    $(&#39;.enlargeImg_wrapper&#39;).fadeIn(200);  })}//关闭并移除图层function closeImg() {  $(&#39;.enlargeImg_wrapper&#39;).fadeOut(200).remove();}</code></pre><p>重点：</p><ul><li>点击class为 <code>enlargeImg</code> 的图片时获取它的路径，var imgSrc = $(this).attr(‘src’);</li><li>创建遮罩层，$(this).after(“<div onclick="closeImg()" class="enlargeImg_wrapper"></div>“);</li><li>赋值给 <code>enlargeImg_wrapper</code> ，$(“.enlargeImg_wrapper”).css(“background-image”, “url(“ + imgSrc + “)”);</li><li>关闭遮罩层时移除遮罩层，$(‘.enlargeImg_wrapper’).fadeOut(200).remove();</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天做了个点击查看大图的功能，只需要给img加一个class，不用写额外的html代码&lt;/p&gt;
&lt;p style=&quot;text-align:center;&quot;&gt;&lt;br&gt;&lt;img style=&quot;box-shadow:1px 1px 10px #888888;&quot; src=&quot;/img/enlargeImg.png&quot; width=&quot;90%;&quot;&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://htmlpreview.github.io/?https://github.com/zc95/enlargeImg/blob/master/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zc95/enlargeImg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github地址&lt;/a&gt;
    
    </summary>
    
      <category term="demo" scheme="http://zc95.github.io/categories/demo/"/>
    
    
      <category term="css" scheme="http://zc95.github.io/tags/css/"/>
    
  </entry>
  
</feed>
