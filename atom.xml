<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张成的学习笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zc95.github.io/"/>
  <updated>2018-05-26T03:40:37.366Z</updated>
  <id>http://zc95.github.io/</id>
  
  <author>
    <name>张成</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>本地开启的localhost服务器如何在移动设备访问</title>
    <link href="http://zc95.github.io/2018/05/26/mobilewatchlocalhost/"/>
    <id>http://zc95.github.io/2018/05/26/mobilewatchlocalhost/</id>
    <published>2018-05-26T03:36:42.000Z</published>
    <updated>2018-05-26T03:40:37.366Z</updated>
    
    <content type="html"><![CDATA[<p>当vue-cli为我们开启了一个本地服务器如：<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a>，我们该怎么在手机或平板上查看呢。</p><p>1.找到 <code>build/index.js</code> ，将红色方框内原来的localhost改成0.0.0.0，表示底层的TCP bind IP结构体被置为全0，就允许监听本机全部网卡。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1frokw2zi7aj30oi08mmyq.jpg" alt=""></p><p>2.新建命令 ifconfig（Windows用户是ipconfig），找到本机ip地址</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1frol1xh200j30iy0dawgk.jpg" alt=""></p><p>3.打开浏览器把localhost换成刚刚的ip <a href="http://192.168.2.238:8080" target="_blank" rel="external">http://192.168.2.238:8080</a>，发现仍然可以访问</p><p>4.打开草料二维码粘贴生成二维码，手机微信扫一扫就好啦</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1frol5bjp2zj31kw0t8tdi.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当vue-cli为我们开启了一个本地服务器如：&lt;a href=&quot;http://localhost:8080&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:8080&lt;/a&gt;，我们该怎么在手机或平板上查看呢。&lt;/p&gt;
&lt;p&gt;1
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="localhost" scheme="http://zc95.github.io/tags/localhost/"/>
    
      <category term="ifconfig" scheme="http://zc95.github.io/tags/ifconfig/"/>
    
  </entry>
  
  <entry>
    <title>我的第一个vue项目[饿了么app]</title>
    <link href="http://zc95.github.io/2018/05/25/vue-sell/"/>
    <id>http://zc95.github.io/2018/05/25/vue-sell/</id>
    <published>2018-05-25T14:00:24.000Z</published>
    <updated>2018-05-25T16:09:50.199Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个饿了么外卖app开发笔记，记录我的第一个vue项目的开发过程。慕课的老项目了，没有打广告哈哈。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1frnx4o6etrj314f0rhwjl.jpg" alt=""></p><h2 id="vue-cli脚手架-搭建基本代码框架"><a href="#vue-cli脚手架-搭建基本代码框架" class="headerlink" title="vue-cli脚手架 搭建基本代码框架"></a>vue-cli脚手架 搭建基本代码框架</h2><blockquote><p>全局安装vue-cli</p><p>$ npm install hexo-cli -g</p><p>创建一个基于webpack模版的新项目，基本配置看下图</p><p>$ vue init webpack vue-sell</p><p>安装依赖，开启localhost本地服务器</p><p>$ cd vue-sell</p><p>$ npm run dev</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1frnx9rccizj30iy0doq4i.jpg" alt=""></p><h2 id="引入准备好的字体图标"><a href="#引入准备好的字体图标" class="headerlink" title="引入准备好的字体图标"></a>引入准备好的字体图标</h2><p>慕课准备好了图标，这一步就省略了，可以去 <a href="https://icomoon.io/app/#/select" target="_blank" rel="external">icomoon.io</a> 自己打包图标</p><h2 id="mock数据（模拟后台数据）"><a href="#mock数据（模拟后台数据）" class="headerlink" title="mock数据（模拟后台数据）"></a>mock数据（模拟后台数据）</h2><p>1.将准备好的 <code>data.json</code> 模拟数据文件放到根目录下</p><p>2.打开<code>build/webpack.dev.conf.js</code> 文件编写数据接口</p><pre><code class="javascript">const appData = require(&#39;../data.json&#39;)const seller = appData.sellerconst goods = appData.goodsconst ratings = appData.ratingsbefore(app) {      app.get(&#39;/api/seller&#39;, function (req, res) {        res.json({          errno: 0,          data: seller        })      });      app.get(&#39;/api/goods&#39;, function (req, res) {        res.json({          errno: 0,          data: goods        })      });      app.get(&#39;/api/ratings&#39;, function (req, res) {        res.json({          errno: 0,          data: ratings        })      });    }</code></pre><p>3.浏览器中打开 <a href="http://localhost:8080/api/seller" target="_blank" rel="external">http://localhost:8080/api/seller</a> 查看数据是否能正常访问，我们可以安装谷歌插件 <code>JSONView</code> 让数据格式化，然后依次查看goods ratings数据是否正常。</p><h2 id="重置css样式"><a href="#重置css样式" class="headerlink" title="重置css样式"></a>重置css样式</h2><p>引入reset.css即可</p><h2 id="CSS预处理器-stylus-的安装"><a href="#CSS预处理器-stylus-的安装" class="headerlink" title="CSS预处理器 stylus 的安装"></a>CSS预处理器 stylus 的安装</h2><p>1.在 <code>package.json</code> 文件中写入依赖</p><blockquote><p>“stylus”: “^0.54.5”,</p><p>“stylus-loader”: “^3.0.1”,</p></blockquote><p>然后安装依赖，mac用户需要加sudo，win不需要</p><blockquote><p>sudo npm install</p><p>npm run dev</p></blockquote><h2 id="头部组件的命名问题"><a href="#头部组件的命名问题" class="headerlink" title="头部组件的命名问题"></a>头部组件的命名问题</h2><p>因为 header 是html5的一个原生的标签，组件名字和它有冲突。</p><pre><code class="javascript">[Vue warn]: Do not use built-in or reserved HTML elements as component id: header</code></pre><p>修改后：</p><pre><code class="html">&lt;v-header&gt;&lt;/v-header&gt;&lt;script&gt;import header from &#39;./components/header/header.vue&#39;export default {  components:{    &#39;v-header&#39;:header  }}&lt;/script&gt;</code></pre><h1 id="ESLint规范"><a href="#ESLint规范" class="headerlink" title="ESLint规范"></a>ESLint规范</h1><p>ESLint是一种代码检测工具，空格、分号各种报错。。。当然我们可以在配置里面注释它，但是有良好的代码习惯还是很重要的，一个个解决吧～</p><blockquote><p>Missing space before value for key ‘v-header’ </p><p>‘v-header’:header</p><p>缺少空格，改：</p><p>‘v-header’: header</p><p>Extra semicolon</p><p>有无用的分号，删掉</p></blockquote><p>好麻烦，还是直接在 <code>build/webpack.base.conf.js</code> 禁止检测吧</p><blockquote><p>//…(config.dev.useEslint ? [createLintingRule()] : []),</p></blockquote><p>重启服务器，世界都清净了。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个饿了么外卖app开发笔记，记录我的第一个vue项目的开发过程。慕课的老项目了，没有打广告哈哈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1frnx4o6etrj314f0rhwjl.jpg&quot; a
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="webpack" scheme="http://zc95.github.io/tags/webpack/"/>
    
      <category term="Vue" scheme="http://zc95.github.io/tags/Vue/"/>
    
      <category term="mock模拟数据" scheme="http://zc95.github.io/tags/mock%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE/"/>
    
      <category term="vue-cli" scheme="http://zc95.github.io/tags/vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>上传项目至github</title>
    <link href="http://zc95.github.io/2018/05/22/git-remote-add/"/>
    <id>http://zc95.github.io/2018/05/22/git-remote-add/</id>
    <published>2018-05-21T17:01:13.000Z</published>
    <updated>2018-05-25T17:10:13.570Z</updated>
    
    <content type="html"><![CDATA[<p>之前因为没有用github上传过整个项目，都是一些小呆萌，现在要上传整个项目再去在网页上一个个新建文件夹上传很麻烦，现在记录一下如何在上传项目至github。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h4 id="假设你已经在github上新建了一个空项目，你的电脑里的项目也都准备好了，同时你也已经安装了-git，然后-let’s-start"><a href="#假设你已经在github上新建了一个空项目，你的电脑里的项目也都准备好了，同时你也已经安装了-git，然后-let’s-start" class="headerlink" title="假设你已经在github上新建了一个空项目，你的电脑里的项目也都准备好了，同时你也已经安装了 git，然后 let’s start."></a>假设你已经在github上新建了一个空项目，你的电脑里的项目也都准备好了，同时你也已经安装了 git，然后 let’s start.</h4><blockquote><p>cd my-project</p><p>git init</p></blockquote><hr><h4 id="然后配置-ssh-输入：sh-keygen-t-rsa-C-“571346800-qq-com”-邮箱替换成你登录github的邮箱"><a href="#然后配置-ssh-输入：sh-keygen-t-rsa-C-“571346800-qq-com”-邮箱替换成你登录github的邮箱" class="headerlink" title="然后配置 ssh , 输入：sh-keygen -t rsa -C “571346800@qq.com” (邮箱替换成你登录github的邮箱)"></a>然后配置 ssh , 输入：sh-keygen -t rsa -C “571346800@qq.com” (邮箱替换成你登录github的邮箱)</h4><blockquote><p>ssh-keygen -t rsa -C “571346800@qq.com”</p></blockquote><hr><h4 id="这个地方请注意，它会在你选择的路径下上生成-ssh-key，如果你直接点击回车，会在默认路径下创建-ssh-。如果你有多个项目，有工作的，有自己玩的，那么请配置不同的路径，或者一个路径换个文件名，我就用：-Users-zhangcheng-ssh-id-vue-rsa-作为演示。输入路径之后点击回车。"><a href="#这个地方请注意，它会在你选择的路径下上生成-ssh-key，如果你直接点击回车，会在默认路径下创建-ssh-。如果你有多个项目，有工作的，有自己玩的，那么请配置不同的路径，或者一个路径换个文件名，我就用：-Users-zhangcheng-ssh-id-vue-rsa-作为演示。输入路径之后点击回车。" class="headerlink" title="这个地方请注意，它会在你选择的路径下上生成 ssh key，如果你直接点击回车，会在默认路径下创建 ssh 。如果你有多个项目，有工作的，有自己玩的，那么请配置不同的路径，或者一个路径换个文件名，我就用：/Users/zhangcheng/.ssh/id_vue_rsa 作为演示。输入路径之后点击回车。"></a>这个地方请注意，它会在你选择的路径下上生成 ssh key，如果你直接点击回车，会在默认路径下创建 ssh 。如果你有多个项目，有工作的，有自己玩的，那么请配置不同的路径，或者一个路径换个文件名，我就用：/Users/zhangcheng/.ssh/id_vue_rsa 作为演示。输入路径之后点击回车。</h4><blockquote><p>/Users/zhangcheng/.ssh/id_test_rsa</p></blockquote><hr><p>下面要你输入密码，直接回车则是不设置密码。直接回车就可以。然后会让你重复密码，也是直接回车。</p><p>当你出现如图所示，就代表 ssh 已经生成了。</p><p>这个执行命令：<code>pbcopy &lt; ~/.ssh/id_test_rsa.pub</code>   这个的作用是将你的 ssh 代码复制到剪贴板。</p><blockquote><p>pbcopy &lt; ~/.ssh/id_test_rsa.pub</p></blockquote><p>点击新建 New SSH key ,直接 Crl＋v 将刚才你已经复制在剪贴板里的 ssh 复制到 key input 里面，title 你随意起喽。然后点击 Add SSH key.</p><hr><p>现在，咱们再打开终端，验证一下是否添加ssh成功了，输入命令： ssh -T git@github.com</p><blockquote><p>ssh -T git@github.com</p></blockquote><hr><p>当你successfully之后，咱们就在 git config 里设置一下你的 github 登录名以及登陆邮箱，执行以下两个命令：</p><blockquote><p>git config –global user.name “zc95”</p><p>git config –global user.email “571346800@qq.com”</p><p>git status</p></blockquote><hr><p>这个时候你就会看到所有的改动，然后执行 git add .    (有个点哦，这个点表示更改所有的改动)</p><p>then 执行命令 git commit -m “第一次更新”</p><blockquote><p>git add . </p><p>git commit -m “第一次更新”</p></blockquote><hr><p>然后执行命令：git remote add origin git@github.com:用户名/项目名.git （后面的地址从下面标注的地方可以找到）</p><blockquote><p>git remote add origin git@github.com:zc95/vue-cli-test.git</p><p>git push -f origin master</p></blockquote><hr><p>最后执行命令：git push -f origin master</p><p>现在 回到你的 github 页面，然后刷新该项目页，enjoy it！</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1frjgy38y6ij30tk0inacz.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前因为没有用github上传过整个项目，都是一些小呆萌，现在要上传整个项目再去在网页上一个个新建文件夹上传很麻烦，现在记录一下如何在上传项目至github。&lt;/p&gt;
&lt;h2 id=&quot;基本命令&quot;&gt;&lt;a href=&quot;#基本命令&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="git" scheme="http://zc95.github.io/tags/git/"/>
    
      <category term="github" scheme="http://zc95.github.io/tags/github/"/>
    
      <category term="ssh" scheme="http://zc95.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>我又回来了</title>
    <link href="http://zc95.github.io/2018/05/21/vue-comeback/"/>
    <id>http://zc95.github.io/2018/05/21/vue-comeback/</id>
    <published>2018-05-21T15:12:01.000Z</published>
    <updated>2018-05-23T11:01:58.378Z</updated>
    
    <content type="html"><![CDATA[<p>最近一个月发生了好多事。比如谈了三年多的女朋友要分手😂，房子的事各种烦，加上公司的事情超多天天加班，已经一个月没能安安静静学习了。</p><p>看了看之前的学习进度，很忧伤～基础部分可说是断断续续的学完的。现在房子忙完了，女朋友没了，公司的事也稍微少了些，应该可以定下心好好学vue啦，下面的目标就是Vue-cli和webpack。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1frjds1uqlpj30rd0imgo4.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一个月发生了好多事。比如谈了三年多的女朋友要分手😂，房子的事各种烦，加上公司的事情超多天天加班，已经一个月没能安安静静学习了。&lt;/p&gt;
&lt;p&gt;看了看之前的学习进度，很忧伤～基础部分可说是断断续续的学完的。现在房子忙完了，女朋友没了，公司的事也稍微少了些，应该可以定下心
      
    
    </summary>
    
      <category term="杂谈篇" scheme="http://zc95.github.io/categories/%E6%9D%82%E8%B0%88%E7%AF%87/"/>
    
    
      <category term="Vue" scheme="http://zc95.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-todo</title>
    <link href="http://zc95.github.io/2018/04/27/vue-todo/"/>
    <id>http://zc95.github.io/2018/04/27/vue-todo/</id>
    <published>2018-04-26T16:12:01.000Z</published>
    <updated>2018-05-21T15:38:25.650Z</updated>
    
    <content type="html"><![CDATA[<p>这几天看了点vue，感觉很棒，把之前的todo翻出来用vue写了一下，瞬间少了三分之二的代码😂</p><h2 id="demo-amp-源码"><a href="#demo-amp-源码" class="headerlink" title="demo &amp; 源码"></a>demo &amp; 源码</h2><p>demo：<a href="https://zc95.github.io/demo/vue-todo">https://zc95.github.io/demo/vue-todo</a></p><p>github：<a href="https://github.com/zc95/ToDo/blob/master/vue-todo.html" target="_blank" rel="external">https://github.com/zc95/ToDo/blob/master/vue-todo.html</a></p><p>扫描二维码，在移动设备上查看：<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqqisjlidij307s07sq2p.jpg" alt=""></p><h2 id="demo对比（前面是vue写的）："><a href="#demo对比（前面是vue写的）：" class="headerlink" title="demo对比（前面是vue写的）："></a>demo对比（前面是vue写的）：</h2><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqqicqtlihj31bw18ugr0.jpg" alt=""></p><h2 id="代码量对比"><a href="#代码量对比" class="headerlink" title="代码量对比"></a>代码量对比</h2><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqqifc1djgj31kw0xg4k3.jpg" alt=""></p><h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><pre><code class="css">let todoStorage = {      save: function (todos) {        localStorage.setItem(&#39;vueTodoStorage&#39;, JSON.stringify(todos))      }    }    let app = new Vue({      el: &#39;#app&#39;,      data: {        todos: localStorage.vueTodoStorage ? JSON.parse(localStorage.vueTodoStorage) : [],        inputValue: &quot;&quot;      },      watch: {        todos: {          handler: function (items) {            todoStorage.save(items);          },          deep: true        }      },      methods: {        add() {          mdui.prompt(&#39;add a todo&#39;,            function (value) {              if(value.trim()==&quot;&quot;){                mdui.snackbar({ message: &quot;Can&#39;t be empty!&quot; });                return false;              }              app.todos.push({ text: value, completed: false });              mdui.snackbar({ message: &#39;A todo has been added.&#39; });            }          );        },        removeTodo(index) {          this.todos.splice(index, 1);          mdui.snackbar({ message: &#39;A todo has been removed.&#39; });        },        deleteAll() {          mdui.confirm(&#39;Are you sure you remove all todo?&#39;, function () {            app.todos = [];            mdui.snackbar({ message: &#39;All todo have been removed.&#39; });          });        },        resetAll() {          mdui.confirm(&#39;Are you sure you reset all todo?&#39;, function () {            app.todos.forEach(element =&gt; {              element.completed = false;            });            mdui.snackbar({ message: &#39;All todo have been reset.&#39; });          });        }      }    })</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天看了点vue，感觉很棒，把之前的todo翻出来用vue写了一下，瞬间少了三分之二的代码😂&lt;/p&gt;
&lt;h2 id=&quot;demo-amp-源码&quot;&gt;&lt;a href=&quot;#demo-amp-源码&quot; class=&quot;headerlink&quot; title=&quot;demo &amp;amp; 源码&quot;
      
    
    </summary>
    
      <category term="demo" scheme="http://zc95.github.io/categories/demo/"/>
    
    
      <category term="material design" scheme="http://zc95.github.io/tags/material-design/"/>
    
      <category term="Vue" scheme="http://zc95.github.io/tags/Vue/"/>
    
      <category term="todo" scheme="http://zc95.github.io/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>vue-devtools的安装</title>
    <link href="http://zc95.github.io/2018/04/22/vue-devtools/"/>
    <id>http://zc95.github.io/2018/04/22/vue-devtools/</id>
    <published>2018-04-21T17:22:45.000Z</published>
    <updated>2018-04-21T17:25:53.079Z</updated>
    
    <content type="html"><![CDATA[<p>vue-devtools 是一款基于chrome游览器的插件，用于调试vue应用，由于国内不能访问谷歌商店（要科学上网），所以安装比较麻烦，写个博客记录一下。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>将vue-devtools clone到本地</p><pre><code class="bash">git clone https://github.com/vuejs/vue-devtools.git</code></pre><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>在vue-devtools目录下安装依赖包</p><pre><code class="shell">cd vue-devtoolsnpm install</code></pre><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>编译代码</p><pre><code class="bash">npm run build</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqksckz0bfj30vo0kcjvu.jpg" alt=""></p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>修改 <code>vue-devtools/shells/chrome/manifest.json</code> 文件，将 persistent改成 <code>true</code></p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqkqczgwjdj30zi0g4di1.jpg" alt=""></p><h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><h3 id="打开chrome，输入-chrome-extensions-进入到chrome扩展程序设置页面"><a href="#打开chrome，输入-chrome-extensions-进入到chrome扩展程序设置页面" class="headerlink" title="打开chrome，输入 chrome://extensions/ 进入到chrome扩展程序设置页面"></a>打开chrome，输入 <code>chrome://extensions/</code> 进入到chrome扩展程序设置页面</h3><p>打开右上角的 <code>开发者模式</code> </p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqkqim3oz3j30b2058aa4.jpg" alt=""></p><h3 id="点击-加载已解压的扩展程序-选择-vue-devtools-shells-chrome"><a href="#点击-加载已解压的扩展程序-选择-vue-devtools-shells-chrome" class="headerlink" title="点击 加载已解压的扩展程序 选择 vue-devtools/shells/chrome"></a>点击 <code>加载已解压的扩展程序</code> 选择 <code>vue-devtools/shells/chrome</code></h3><p>   <img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqkqmn6rp0j31480owdlm.jpg" alt=""></p><h3 id="注意：勾选-允许访问文件网址"><a href="#注意：勾选-允许访问文件网址" class="headerlink" title="注意：勾选 允许访问文件网址"></a>注意：勾选 <code>允许访问文件网址</code></h3><p>   <img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqks8mz3qxj318u05i0t0.jpg" alt=""></p><p>至此，vue-devtools已经安装完毕。enjoy it!</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqksb2n8lkj31kw115n6r.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vue-devtools 是一款基于chrome游览器的插件，用于调试vue应用，由于国内不能访问谷歌商店（要科学上网），所以安装比较麻烦，写个博客记录一下。&lt;/p&gt;
&lt;h2 id=&quot;第一步&quot;&gt;&lt;a href=&quot;#第一步&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="Vue" scheme="http://zc95.github.io/tags/Vue/"/>
    
      <category term="vue-devtools" scheme="http://zc95.github.io/tags/vue-devtools/"/>
    
  </entry>
  
  <entry>
    <title>我要开始学Vue啦</title>
    <link href="http://zc95.github.io/2018/04/17/vue-learning/"/>
    <id>http://zc95.github.io/2018/04/17/vue-learning/</id>
    <published>2018-04-17T15:02:21.000Z</published>
    <updated>2018-05-21T15:38:11.513Z</updated>
    
    <content type="html"><![CDATA[<p>emm…开始学习Vue啦 <a href="https://github.com/zc95/vue-learning" target="_blank" rel="external">https://github.com/zc95/vue-learning</a></p><p><img src="https://cn.vuejs.org/images/logo.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;emm…开始学习Vue啦 &lt;a href=&quot;https://github.com/zc95/vue-learning&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/zc95/vue-learning&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="汇总篇" scheme="http://zc95.github.io/categories/%E6%B1%87%E6%80%BB%E7%AF%87/"/>
    
    
      <category term="Vue" scheme="http://zc95.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>js的函数重载</title>
    <link href="http://zc95.github.io/2018/04/15/overloading/"/>
    <id>http://zc95.github.io/2018/04/15/overloading/</id>
    <published>2018-04-15T15:17:48.000Z</published>
    <updated>2018-04-16T12:52:48.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h2><p>函数重载，简单说，就是函数有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。</p><p>所以说，重载函数需要两点：同样的函数名，不同的函数参数。</p><h2 id="js到底有没有函数重载"><a href="#js到底有没有函数重载" class="headerlink" title="js到底有没有函数重载"></a>js到底有没有函数重载</h2><p>如果在我们在一个页面中定义了两个名字相同的函数，则该名字只属于后定义的函数，如下：</p><pre><code class="javascript">function add(num){    return num+1;}function add(num){    return num+2;}add(4);  //结果为6</code></pre><p>在上面的例子中，add()函数被定义了两次，然而，当我们调用他的时候，却直接调用了第二个函数，这说明在JavaScript中，后定义的函数会覆盖先定义的函数。</p><p>其实，在java或者.net中都是是存在重载的，那么js中呢？可以肯定的说，js中是不存在重载的，但是我们可以通过其他的方式来模拟重载。</p><h2 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h2><p>当我们在js中在调用一个函数的时候，我们经常会给这个函数传递一些参数，js把传入到这个函数的全部参数存储在一个叫做arguments的东西里面，<code>arguments</code>对象不是一个<code>Array</code> 。它类似于<code>Array</code>，可以使用[i]或者.length，为了代码的严谨度，我们可以用arguments的length属性来判断当前传入参数的个数是否与我们需要的数量一致。</p><pre><code class="javascript">function add(num1, num2){    // 根据arguments.length，对不同的值进行不同的操作　　switch(arguments.length) {　　　　case 0:　　　　　　/*没有传入任何参数时*/　　　　　　break;　　　　case 1:　　　　　　/*传入一个参数时*/　　　　　　break;　　　　case 2:　　　　　　/*传入两个参数时*/             break;      /*case N.....*/}}</code></pre><p>通过这个例子，我们可以看出，通过检查传入函数中参数的数量，JavaScript函数可以做出不同的反应，这可以间接达到重载的目的。</p><p>所以，JavaScript是可以模仿函数的重载的。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="arguments-类数组对象转为真正的数组"><a href="#arguments-类数组对象转为真正的数组" class="headerlink" title="arguments 类数组对象转为真正的数组"></a>arguments 类数组对象转为真正的数组</h3><pre><code>Array.prototype.slice.apply(arguments);Array.from(arguments);[...arguments];</code></pre><h3 id="callee"><a href="#callee" class="headerlink" title="callee"></a>callee</h3><p><code>arguments.callee</code> 属性包含当前正在执行的函数。<strong>callee</strong> 是 <code>arguments</code> 对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。这在函数的名称是未知时很有用，例如在没有名称的函数表达式（也称为匿名函数）内。</p><p>以一个求阶乘的方法为例：</p><pre><code class="javascript">function fact(n) { if (n &lt; 2) {  return n; } else {  return n * fact(n - 1); }}console.log(fact(5)); //5*4*3*2=120</code></pre><p>匿名函数中：</p><pre><code class="javascript">(function (n) { if (n &lt; 2) {  return n; } else {  return n * arguments.callee(n - 1); }})(5);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数的重载&quot;&gt;&lt;a href=&quot;#函数的重载&quot; class=&quot;headerlink&quot; title=&quot;函数的重载&quot;&gt;&lt;/a&gt;函数的重载&lt;/h2&gt;&lt;p&gt;函数重载，简单说，就是函数有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="javascript" scheme="http://zc95.github.io/tags/javascript/"/>
    
      <category term="函数重载" scheme="http://zc95.github.io/tags/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    
      <category term="arguments对象" scheme="http://zc95.github.io/tags/arguments%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Node.js构建TCP服务器和TCP客户端</title>
    <link href="http://zc95.github.io/2018/03/20/nodejs-TCP/"/>
    <id>http://zc95.github.io/2018/03/20/nodejs-TCP/</id>
    <published>2018-03-20T13:56:12.000Z</published>
    <updated>2018-04-15T15:19:58.967Z</updated>
    
    <content type="html"><![CDATA[<p>网络是通信互联网的基础，Node.js提供了net、http、dgram模块、分别用来实现TCP、HTTP、UDP的通信。上次的文章<a href="https://zc95.github.io/2018/03/19/nodejs-HTTP/">《Node.js构建HTTP服务器》</a>实现了HTTP的通信，这篇文章说一说TCP服务器和TCP客户端的构建。</p><h2 id="用Node-js创建TCP服务器"><a href="#用Node-js创建TCP服务器" class="headerlink" title="用Node.js创建TCP服务器"></a>用Node.js创建TCP服务器</h2><h3 id="构建TCP服务器"><a href="#构建TCP服务器" class="headerlink" title="构建TCP服务器"></a>构建TCP服务器</h3><p>为了使用Node.js创建TCP服务器，首先要使用require(“net”)来加载net模块，然后使用net模块的createServer方法就可以轻松地创建一个TCP服务器。</p><pre><code class="javascript">/** * 构建TCP客户端 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP服务器 */var server = net.createServer(function(socket){    console.log(&#39;someone connects&#39;);})/* 设置连接的服务器 */server.listen(8000, function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>运行这段代码并访问了<a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a>的话会看到控制台打印了”someone connects”，表明已经成功连接到这个创建的TCP服务器。</p><hr><blockquote><p>/<em> 设置连接的服务器 </em>/<br>server.listen(8000, function(){<br>​    console.log(“Creat server on <a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a>“);<br>})</p></blockquote><p>上面这段代码实际上触发的是server下的listening事件，等同于：</p><blockquote><p>/<em> 设置监听端口 </em>/</p><p>server.listen(8000);</p><p>/<em> 设置监听时的回调函数 </em>/</p><p>server.on(“listening”, function () {</p><p>​    console.log(“Creat server on <a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a>“);</p><p>})</p></blockquote><p>事实上，除了listening事件外，TCP服务器还支持以下事件：</p><ol><li>connection：当有新的连接创建时触发，回调函数的参数为socket连接对象。</li><li>close：TCP服务器关闭的时候触发，回调函数没有参数</li><li>error：TCP服务器发生错误的时候触发，回调函数的参数为error对象</li></ol><p>下列代码通过net.Server类来创建一个TCP服务器，并添加以上事件。</p><pre><code class="javascript"> /** * 通过net.Server类来创建一个TCP服务器 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 实例化一个服务器对象 */var server = new net.Server();/* 监听 connection 事件 */server.on(&quot;connection&quot;, function (socket) {    console.log(&quot;someone connects&quot;);});/* 设置监听端口 */server.listen(8000);/* 设置监听时的回调函数 */server.on(&quot;listening&quot;, function () {    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})/* 设置关闭时的回调函数 */server.on(&quot;close&quot;, function () {    console.log(&quot;server closed!&quot;);})/* 设置错误时的回调函数 */server.on(&quot;error&quot;, function (err) {    console.log(&quot;error!&quot;);})</code></pre><h3 id="查看服务器监听的地址"><a href="#查看服务器监听的地址" class="headerlink" title="查看服务器监听的地址"></a>查看服务器监听的地址</h3><p>当创建了一个TCP服务器后，可以通过server.address()方法来查看这个TCP服务器监听的地址，并返回一个JSON对象。这个对象的属性有：</p><ol><li>port：TCP服务器监听的端口号</li><li>family：说明TCP服务器监听的地址是 IPv6 还是 IPv4</li><li>address：TCP服务器监听的地址</li></ol><pre><code class="javascript">/** * 查看服务器监听的地址 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP服务器 */var server = net.createServer(function(socket){    console.log(&#39;someone connects&#39;);})/* 获取地址信息 */server.listen(8000,function(){    /* 获取地址信息，得到的是一个json { address: &#39;::&#39;, family: &#39;IPv6&#39;, port: 8000 } */    var address = server.address();    /* TCP服务器监听的端口号 */    console.log(&quot;the port of server is&quot;+ address.port);    /* TCP服务器监听的地址 */    console.log(&quot;the address of server is&quot;+ address.address);    /* 说明TCP服务器监听的地址是 IPv6 还是 IPv4 */    console.log(&quot;the family of server is&quot;+ address.family);})</code></pre><h3 id="连接服务器的客户端数量"><a href="#连接服务器的客户端数量" class="headerlink" title="连接服务器的客户端数量"></a>连接服务器的客户端数量</h3><p>创建一个TCP服务器后，可以通过server.getConnections()方法获取连接这个TCP服务器的客户端数量。除此之外，也可以通过maxConnections属性来设置这个服务器的最大连接数量，当连接数量超过最大值时，服务器将拒绝新的连接。</p><pre><code class="javascript">/** * 连接服务器的客户端数量 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP服务器 */var server = net.createServer(function(socket){    console.log(&#39;someone connects&#39;);    /* 设置最大连接数量 */    server.maxConnections=3;    server.getConnections(function(err,count){        console.log(&quot;the count of client is &quot;+count);    })})/* 获取监听端口 */server.listen(8000,function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>你可以打开多个网页输入localhost:8000来测试这段代码，也可以用Telnet命令 <code>telnet localhost 8000</code> 来连接这个TCP服务器（上一篇文章有提到如何用Homebrew安装Telnet：<a href="https://zc95.github.io/2018/03/20/Homebrew/">《Homebrew》</a>）。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fpkqytum6zj31kw0s7toa.jpg" alt=""></p><h3 id="服务器和客户端之间的通信"><a href="#服务器和客户端之间的通信" class="headerlink" title="服务器和客户端之间的通信"></a>服务器和客户端之间的通信</h3><p>利用socket.write()可以使TCP服务器发送数据给客户端；</p><p>socket对象可以用来获取客户端发出的流数据，每次接收到数据的时候触发data事件，通过监听这个事件就可以在回调函数中获取客户端发送的数据了。</p><pre><code class="javascript">/** * 发送和获取 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP服务器 */var server = net.createServer(function(socket){    /* 获取地址信息 */    var address = server.address();    var message = &quot;the server address is&quot;+JSON.stringify(address);    /* 发送数据 */    socket.write(message,function(){        var writeSize = socket.bytesWritten;        console.log(message + &quot;has send&quot;);        console.log(&quot;the size of message is&quot;+writeSize);    })    /* 监听data事件 */    socket.on(&#39;data&#39;,function(data){        console.log(data.toString());        var readSize = socket.bytesRead;        console.log(&quot;the size of data is&quot;+readSize);    })})/* 获取地址信息 */server.listen(8000,function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>下图中TCP服务器给客户端发送了字符串：</p><blockquote><p>the server address is{“address”:”::”,”family”:”IPv6”,”port”:8000}has send</p></blockquote><p>客户端给TCP服务器发送了字符串 <code>hello TCP!</code> 和字节数。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fpkr5446asj31kw0p5gvz.jpg" alt=""></p><h2 id="用Node-js创建TCP客户端"><a href="#用Node-js创建TCP客户端" class="headerlink" title="用Node.js创建TCP客户端"></a>用Node.js创建TCP客户端</h2><h3 id="构建TCP客户端"><a href="#构建TCP客户端" class="headerlink" title="构建TCP客户端"></a>构建TCP客户端</h3><p>上面说到用打开网页或者Telnet来访问TCP服务器，其实我们也可以用Node.js来构建一个TCP客户端，实现TCP客户端和TCP服务器的通信。</p><p>为了使用Node.js创建TCP客户端，首先要使用require(“net”)来加载net模块，然后创建一个连接TCP客户端的socket对象即可：</p><blockquote><p>/<em> 引入net模块 </em>/</p><p>var net = require(“net”);</p><p>/<em> 创建TCP客户端 </em>/</p><p>var client = net.Socket();</p></blockquote><p>创建完socket对象后，使用socket对象的connect方法就可以连接一个TCP服务器。</p><pre><code class="javascript">/** * 构建TCP客户端 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP客户端 */var client = net.Socket();/* 设置连接的服务器 */client.connect(8000, &#39;127.0.0.1&#39;, function () {    console.log(&quot;connect the server&quot;);    /* 向服务器发送数据 */    client.write(&quot;message from client&quot;);})/* 监听服务器传来的data数据 */client.on(&quot;data&quot;, function (data) {    console.log(&quot;the data of server is &quot; + data.toString());})/* 监听end事件 */client.on(&quot;end&quot;, function () {    console.log(&quot;data end&quot;);})</code></pre><h3 id="TCP客户端和TCP服务器的通信"><a href="#TCP客户端和TCP服务器的通信" class="headerlink" title="TCP客户端和TCP服务器的通信"></a>TCP客户端和TCP服务器的通信</h3><p>运行 <a href="#服务器和客户端之间的通信">这段代码</a> 之后再运行 <a href="#构建TCP客户端">这段代码</a> ，可以发现服务器已经接收到客户端的数据，客户端也已经接收到服务端的数据。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fpkso73cqdj31kw0o27bv.jpg" alt=""></p><h2 id="LINK"><a href="#LINK" class="headerlink" title="LINK"></a>LINK</h2><ol><li>本章github源码：<a href="https://github.com/zc95/nodeTest/tree/master/TCP" target="_blank" rel="external">https://github.com/zc95/nodeTest/tree/master/TCP</a></li><li>《Node.js构建HTTP服务器》：<a href="https://zc95.github.io/2018/03/19/nodejs-HTTP/">https://zc95.github.io/2018/03/19/nodejs-HTTP/</a></li><li>用Homebrew安装Telnet：<a href="https://zc95.github.io/2018/03/20/Homebrew/">https://zc95.github.io/2018/03/20/Homebrew/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络是通信互联网的基础，Node.js提供了net、http、dgram模块、分别用来实现TCP、HTTP、UDP的通信。上次的文章&lt;a href=&quot;https://zc95.github.io/2018/03/19/nodejs-HTTP/&quot;&gt;《Node.js构建HTTP
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="Node.js" scheme="http://zc95.github.io/tags/Node-js/"/>
    
      <category term="TCP" scheme="http://zc95.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Homebrew</title>
    <link href="http://zc95.github.io/2018/03/20/Homebrew/"/>
    <id>http://zc95.github.io/2018/03/20/Homebrew/</id>
    <published>2018-03-20T13:31:52.000Z</published>
    <updated>2018-03-21T14:58:14.483Z</updated>
    
    <content type="html"><![CDATA[<p>Homebrew简称brew，OSX上的软件包管理工具，在Mac终端可以通过brew安装、更新、卸载软件。</p><h2 id="Homebrew-能干什么"><a href="#Homebrew-能干什么" class="headerlink" title="Homebrew 能干什么?"></a>Homebrew 能干什么?</h2><p><a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew官网</a> 的title是这么说的：macOS 缺失的软件包管理器，意思就是使用 Homebrew 安装 Apple 没有预装但你需要的东西，比如high sierra 10.13中移除了telnet，只需要 <code>brew install telnet</code> 一个命令就行。</p><a id="more"></a><h2 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h2><p>一、进入<a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew官网</a>，按照官网提示在命令行执行ruby脚本（mac自带ruby），在终端运行以下命令：</p><pre><code class="bash">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p>二、按提示输入电脑密码，一路enter到底，直到出现下面的信息就说明安装成功。</p><pre><code class="bash">==&gt; Next steps:- Run `brew help` to get started- Further documentation:     https://docs.brew.sh</code></pre><p>三、运行命令 <code>brew help</code> 就可以了解一些brew常用的命令：</p><pre><code class="bash">Example usage:  brew search [TEXT|/REGEX/]  brew (info|home|options) [FORMULA...]  brew install FORMULA...  brew update  brew upgrade [FORMULA...]  brew uninstall FORMULA...  brew list [FORMULA...]Troubleshooting:  brew config  brew doctor  brew install -vd FORMULADevelopers:  brew create [URL [--no-fetch]]  brew edit [FORMULA...]  https://docs.brew.sh/Formula-CookbookFurther help:  man brew  brew help [COMMAND]  brew home</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Homebrew简称brew，OSX上的软件包管理工具，在Mac终端可以通过brew安装、更新、卸载软件。&lt;/p&gt;
&lt;h2 id=&quot;Homebrew-能干什么&quot;&gt;&lt;a href=&quot;#Homebrew-能干什么&quot; class=&quot;headerlink&quot; title=&quot;Homebrew 能干什么?&quot;&gt;&lt;/a&gt;Homebrew 能干什么?&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://brew.sh/index_zh-cn.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Homebrew官网&lt;/a&gt; 的title是这么说的：macOS 缺失的软件包管理器，意思就是使用 Homebrew 安装 Apple 没有预装但你需要的东西，比如high sierra 10.13中移除了telnet，只需要 &lt;code&gt;brew install telnet&lt;/code&gt; 一个命令就行。&lt;/p&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="Homebrew" scheme="http://zc95.github.io/tags/Homebrew/"/>
    
      <category term="brew" scheme="http://zc95.github.io/tags/brew/"/>
    
      <category term="telnet" scheme="http://zc95.github.io/tags/telnet/"/>
    
  </entry>
  
  <entry>
    <title>Node.js构建HTTP服务器</title>
    <link href="http://zc95.github.io/2018/03/19/nodejs-HTTP/"/>
    <id>http://zc95.github.io/2018/03/19/nodejs-HTTP/</id>
    <published>2018-03-19T12:29:42.000Z</published>
    <updated>2018-04-09T14:29:15.156Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js® is a JavaScript runtime built on <a href="https://developers.google.com/v8/" target="_blank" rel="external">Chrome’s V8 JavaScript engine</a>. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, <a href="https://www.npmjs.com/" target="_blank" rel="external">npm</a>, is the largest ecosystem of open source libraries in the world.</p><h2 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a>Node.js简介</h2><p><code>Node.js</code> 是一个基于 Google Chrome V8 引擎 的 JavaScript 运行环境。Node.js使用后多种先进的技术，其中包括 事件驱动、非阻塞 I/O 模型，使其轻量又高效，受到众多开发者的追捧。</p><p>简单的说，Node.js 就是运行在服务端的 JavaScript ，可以稳定地在各种平台下运行，包括Linux、Windows、Mac OS X、Sun Os 和FreeBSD等众多平台。</p><a id="more"></a><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><ol><li>点击 <a href="https://nodejs.org" target="_blank" rel="external">https://nodejs.org</a> 进入nodejs官网</li><li>有两个版本：LTS和Current，LTS是长期支持版本，成熟可靠</li><li>next到底</li><li>打开终端，输入 <code>node -v</code> ，回车，如果出现类似 <code>v6.11.4</code> 的版本号就说明安装成功</li></ol><h2 id="构建一个HTTP服务器"><a href="#构建一个HTTP服务器" class="headerlink" title="构建一个HTTP服务器"></a>构建一个HTTP服务器</h2><p>在如今web大行其道的时代，支撑无数网页运行的正是HTTP服务器。Node.js之所以受到大量web开发者的青睐，与Node.js有能力自己构建服务器是分不开的。</p><ol><li><p>在根目录下新建 <code>nodetest</code> 文件夹</p></li><li><p>在 <code>nodetest</code> 下新建 <code>HTTP</code> 文件夹</p></li><li><p>在 <code>HTTP</code> 文件夹下新建一个 <code>server.js</code> 的文件</p></li><li><p>拷贝粘贴这段代码，保存：</p><pre><code class="javascript">/** * 创建http服务器 *//* 引入http模块 */var http = require(&quot;http&quot;);/* 创建HTTP服务器 */var server = http.createServer(function(request, response) {    /* 设置相应的头部 */    response.writeHead(200, {        &quot;content-Type&quot; : &quot;text/plain&quot;    });    /* 设置相应的数据 */    response.write(&quot;Welcome to Nodejs&quot;);    response.end();});/* 设置服务器端口 */server.listen(8000, function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre></li><li><p>打开终端 输入 <code>cd nodetest/HTTP</code> </p></li><li><p>输入 <code>node server.js</code> ，返回 <code>Creat server on http://127.0.0.1:8000/</code></p></li><li><p>打开浏览器输入 <code>http://127.0.0.1:8000/</code> 或者 <code>http://localhost:8000</code> </p></li><li><p>Welcome to Nodejs</p></li></ol><h2 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块"></a>文件模块</h2><p>上面说到的HTTP服务器知识实现了将一串字符串发送给服务器。很明显，如果服务器只能发送一些字符串，那几乎是远远不够的，因此我们要做一些扩展，通过文件模块将文件读取并发送给服务器是一个不错的选择，在nodetest文件夹下新建 <code>fsModule.js</code> :</p><pre><code class="javascript">/** * fs模块 *//* 引入http模块 */var http = require(&quot;http&quot;);/* 引入fs模块 */var fs = require(&quot;fs&quot;);/* 创建HTTP服务器 */var server = http.createServer(function(request, response) {    /* 设置响应的头部 */    response.writeHead(200, {        &quot;content-Type&quot; : &quot;text/html&quot;    });    /* 读取文件数据 */    var data = fs.readFileSync(&quot;./index.html&quot;);    /* 设置响应的数据 */    response.write(data);    response.end();});/* 设置服务器端口 */server.listen(8000, function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>同时在同级目录中创建一个名为 <code>index.html</code> 的文件，写入以下代码：</p><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot; /&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;title&gt;fs module&lt;/title&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;fs文件模块&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>node fsModule.js 运行，在浏览器中打开 <code>http://localhost:8000</code> ，Node.js已经把index这个文件发送到客户端了；</p><p>需要提及的是，这里HTTP服务器在发送给浏览器的头部信息中将 content-type修改为了 <code>text/html</code> 。 content-type的人作用就是用来表示客户端或者服务器传输数据的类型，服务器或者客客户端通过这个值来做相应的解析。如果这个值改为原来的 <code>text/plain</code> ，浏览器将显示index.html的所有源代码，这显然不是我们想要的。</p><h2 id="HTTP服务器的路由控制"><a href="#HTTP服务器的路由控制" class="headerlink" title="HTTP服务器的路由控制"></a>HTTP服务器的路由控制</h2><p>上一节中的服务器虽然已经可以通过读取文件数据来发送给客户端了，但你并没有做任何的路由控制，在浏览器中输入任何URL都将返回同样的内容，简单来说，路由就是URL到函数的映射。</p><p>要做到路由控制，通过上面的学习可以预想到修改content-type就可以了，这里假定只需要处理html、js、css和图片文件，创建一个名为 <code>mime.js</code> 的文件：</p><pre><code class="javascript">module.exports = {    &quot;.html&quot; : &quot;text/html&quot;,    &quot;.css&quot; : &quot;text/css&quot;,    &quot;.js&quot; : &quot;text/javascript&quot;,    &quot;.gif&quot; : &quot;image/gif&quot;,    &quot;.ico&quot; : &quot;image/x-icon&quot;,    &quot;.jpeg&quot; : &quot;image/jpeg&quot;,    &quot;.jpg&quot; : &quot;image/jpeg&quot;,    &quot;.png&quot; : &quot;image/png&quot;,}</code></pre><p>创建一个名为 <code>fsModule2.js</code> 的文件：</p><pre><code class="javascript">/** * 这里通过路径处理判断来返回不同的资源，从而做到简单的路由控制 *//* 引入http模块 */var http = require(&quot;http&quot;);/* 引入fs模块 */var fs = require(&quot;fs&quot;);/* 引入url模块 */var url = require(&quot;url&quot;);/* 引入mime文件 */var mime = require(&quot;./mime.js&quot;);/* 引入path模块 */var path = require(&quot;path&quot;);/* 创建HTTP服务器 */var server = http.createServer(function(request, response) {    var filePath = &quot;.&quot;+url.parse(request.url).pathname;    if(filePath === &quot;./&quot;){        filePath = &#39;./index.html&#39;    }    /* 判断相应的文件是否存在 */    fs.exists(filePath,function(exists){        /* 存在则返回相应文件数据 */        if(exists){            var data = fs.readFileSync(filePath);            var contentType = mime[path.extname(filePath)];            response.writeHead(200,{                &quot;content-type&quot;: contentType            });            response.write(data);            response.end();        }else{            response.end(&quot;404&quot;);        }    })});/* 设置服务器端口 */server.listen(8000, function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>这里通过对路径处理判断来返回不同的资源，从而做到简单的路由控制。</p><h2 id="LINK"><a href="#LINK" class="headerlink" title="LINK"></a>LINK</h2><ol><li>本章github源码：<a href="https://github.com/zc95/nodeTest/tree/master/HTTP" target="_blank" rel="external">https://github.com/zc95/nodeTest/tree/master/HTTP</a></li><li>《Node.js构建TCP服务器和TCP客户端》：<a href="https://zc95.github.io/2018/03/20/nodejs-TCP/">https://zc95.github.io/2018/03/20/nodejs-TCP/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js® is a JavaScript runtime built on &lt;a href=&quot;https://developers.google.com/v8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Chrome’s V8 JavaScript engine&lt;/a&gt;. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, &lt;a href=&quot;https://www.npmjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;npm&lt;/a&gt;, is the largest ecosystem of open source libraries in the world.&lt;/p&gt;
&lt;h2 id=&quot;Node-js简介&quot;&gt;&lt;a href=&quot;#Node-js简介&quot; class=&quot;headerlink&quot; title=&quot;Node.js简介&quot;&gt;&lt;/a&gt;Node.js简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Node.js&lt;/code&gt; 是一个基于 Google Chrome V8 引擎 的 JavaScript 运行环境。Node.js使用后多种先进的技术，其中包括 事件驱动、非阻塞 I/O 模型，使其轻量又高效，受到众多开发者的追捧。&lt;/p&gt;
&lt;p&gt;简单的说，Node.js 就是运行在服务端的 JavaScript ，可以稳定地在各种平台下运行，包括Linux、Windows、Mac OS X、Sun Os 和FreeBSD等众多平台。&lt;/p&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="Node.js" scheme="http://zc95.github.io/tags/Node-js/"/>
    
      <category term="本地服务器" scheme="http://zc95.github.io/tags/%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门</title>
    <link href="http://zc95.github.io/2018/03/13/es6-webpack/"/>
    <id>http://zc95.github.io/2018/03/13/es6-webpack/</id>
    <published>2018-03-13T13:42:52.000Z</published>
    <updated>2018-03-20T13:32:31.633Z</updated>
    
    <content type="html"><![CDATA[<p>github：<a href="https://github.com/zc95/es6-webpack" target="_blank" rel="external">https://github.com/zc95/es6-webpack</a></p><h2 id="webpack搭建ES6环境"><a href="#webpack搭建ES6环境" class="headerlink" title="webpack搭建ES6环境"></a>webpack搭建ES6环境</h2><p>首先下载源码</p><pre><code class="shell">git clone https://github.com/zc95/es6-webpack.git</code></pre><p>然后安装</p><pre><code class="shell">cd es6-webpacknpm installnpm install webpack -gnpm install webpack-dev-server -g</code></pre><p>最后运行</p><pre><code class="shell">cd es6-webpacknpm start</code></pre><a id="more"></a><h2 id="es6基础"><a href="#es6基础" class="headerlink" title="es6基础"></a>es6基础</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><pre><code class="javascript">// ES5 中常量的写法Object.defineProperty(window, &quot;PI2&quot;, {    value: 3.1415926,    writable: false,})</code></pre><pre><code class="javascript">// ES6 的常量写法const PI = 3.1415926</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><pre><code class="javascript">// ES3,ES5var evens = [1, 2, 3, 4, 5];var odds = evens.map(function(v) {  return v + 1});  console.log(evens, odds);};</code></pre><pre><code class="javascript">// ES6let evens = [1, 2, 3, 4, 5];let odds = evens.map(v =&gt; v + 1);console.log(evens, odds);</code></pre><p><strong>this的指向</strong></p><pre><code class="javascript">// ES3,ES5中 this 的指向是 该函数被调用的对象  var factory = function() {    this.a = &#39;a&#39;;    this.b = &#39;b&#39;;    this.c = {      a: &#39;a+&#39;,      b: function() {        return this.a      }    }  }  console.log(new factory().c.b());};</code></pre><pre><code class="javascript">// ES6箭头函数中 this 的指向是 定义时this的指向var factory = function() {    this.a = &#39;a&#39;;    this.b = &#39;b&#39;;    this.c = {      a: &#39;a+&#39;,      b: () =&gt; {        return this.a      }    }  }  console.log(new factory().c.b());</code></pre><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p><strong>默认参数</strong></p><pre><code class="javascript">// ES5\ES3 默认参数的写法  function f(x, y, z) {    if (y === undefined) {      y = 7;    }    if (z === undefined) {      z = 42    }    return x + y + z  }  console.log(f(1, 3));</code></pre><pre><code class="javascript">// ES6 默认参数  function f(x, y = 7, z = 42) {    return x + y + z  }  console.log(f(1, 3));</code></pre><p><strong>可变参数</strong></p><pre><code class="javascript">// ES3,ES5 可变参数  function f() {    var a = Array.prototype.slice.call(arguments);    var sum = 0;    a.forEach(function(item) {      sum += item * 1;    })    return sum  }  console.log(f(1, 2, 3, 6));</code></pre><pre><code class="javascript">// ES6 可变参数function f(...a) {    var sum = 0;    a.forEach(item =&gt; {      sum += item * 1    });    return sum  }  console.log(f(1, 2, 3, 6));</code></pre><p><strong>合并数组</strong></p><pre><code class="javascript">// ES5 合并数组  var params = [&#39;hello&#39;, true, 7];  var other = [1, 2].concat(params);  console.log(other);</code></pre><pre><code class="javascript">// ES6 利用扩展运算符合并数组  var params = [&#39;hello&#39;, true, 7];  var other = [    1, 2, ...params  ];  console.log(other);</code></pre><h3 id="对象代理"><a href="#对象代理" class="headerlink" title="对象代理"></a>对象代理</h3><pre><code class="javascript">// ES3,ES5 数据保护  var Person = function() {    var data = {      name: &#39;es3&#39;,      sex: &#39;male&#39;,      age: 15    }    this.get = function(key) {      return data[key]    }    this.set = function(key, value) {      if (key !== &#39;sex&#39;) {        data[key] = value      }    }  }  // 声明一个实例  var person = new Person();  // 读取  console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)});  // 修改  person.set(&#39;name&#39;, &#39;es3-cname&#39;);  console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)});  person.set(&#39;sex&#39;, &#39;female&#39;);  console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)});</code></pre><pre><code class="javascript">// ES5  var Person = {    name: &#39;es5&#39;,    age: 15  };  Object.defineProperty(Person, &#39;sex&#39;, {    writable: false,    value: &#39;male&#39;  });  console.table({name: Person.name, age: Person.age, sex: Person.sex});  Person.name = &#39;es5-cname&#39;;  console.table({name: Person.name, age: Person.age, sex: Person.sex});  try {    Person.sex = &#39;female&#39;;    console.table({name: Person.name, age: Person.age, sex: Person.sex});  } catch (e) {    console.log(e);  }</code></pre><pre><code class="javascript">// ES6  let Person = {    name: &#39;es6&#39;,    sex: &#39;male&#39;,    age: 15  };  let person = new Proxy(Person, {    get(target, key) {      return target[key]    },    set(target,key,value){      if(key!==&#39;sex&#39;){        target[key]=value;      }    }  });  console.table({    name:person.name,    sex:person.sex,    age:person.age  });  try {    person.sex=&#39;female&#39;;  } catch (e) {    console.log(e);  } finally {  }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;github：&lt;a href=&quot;https://github.com/zc95/es6-webpack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/zc95/es6-webpack&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;webpack搭建ES6环境&quot;&gt;&lt;a href=&quot;#webpack搭建ES6环境&quot; class=&quot;headerlink&quot; title=&quot;webpack搭建ES6环境&quot;&gt;&lt;/a&gt;webpack搭建ES6环境&lt;/h2&gt;&lt;p&gt;首先下载源码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git clone https://github.com/zc95/es6-webpack.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;cd es6-webpack
npm install
npm install webpack -g
npm install webpack-dev-server -g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后运行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;cd es6-webpack
npm start
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="ES6" scheme="http://zc95.github.io/tags/ES6/"/>
    
      <category term="webpack" scheme="http://zc95.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>撸了一个canvas手写板</title>
    <link href="http://zc95.github.io/2018/03/08/canvasPalette/"/>
    <id>http://zc95.github.io/2018/03/08/canvasPalette/</id>
    <published>2018-03-08T15:15:11.000Z</published>
    <updated>2018-03-31T04:47:20.741Z</updated>
    
    <content type="html"><![CDATA[<p>用 canvas 写了一个手写板，功能：画笔粗细、橡皮擦大小、画笔颜色、清空画布、历史操作等</p><h2 id="canvas手写板"><a href="#canvas手写板" class="headerlink" title="canvas手写板"></a>canvas手写板</h2><ul><li><a href="https://zc95.github.io/demo/canvas.html">demo</a></li><li><a href="https://github.com/zc95/canvas" target="_blank" rel="external">github</a><a id="more"></a><h2 id="扫一扫"><a href="#扫一扫" class="headerlink" title="扫一扫"></a>扫一扫</h2></li></ul><p><img width="150" src="https://ws4.sinaimg.cn/large/006tNc79gy1fp5r4kgijtj307s07st9m.jpg"></p><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp5tb8a00yj31401z40vt.jpg" height="600"></p><hr><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp5tb8s4tgj31401z4wjo.jpg" height="600"></p><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp5tbmm3ytj31401z4wj1.jpg" height="600"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 canvas 写了一个手写板，功能：画笔粗细、橡皮擦大小、画笔颜色、清空画布、历史操作等&lt;/p&gt;
&lt;h2 id=&quot;canvas手写板&quot;&gt;&lt;a href=&quot;#canvas手写板&quot; class=&quot;headerlink&quot; title=&quot;canvas手写板&quot;&gt;&lt;/a&gt;canvas手写板&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zc95.github.io/demo/canvas.html&quot;&gt;demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zc95/canvas&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;
    
    </summary>
    
      <category term="demo" scheme="http://zc95.github.io/categories/demo/"/>
    
    
      <category term="canvas" scheme="http://zc95.github.io/tags/canvas/"/>
    
      <category term="material design" scheme="http://zc95.github.io/tags/material-design/"/>
    
  </entry>
  
  <entry>
    <title>自己写了个音乐播放器</title>
    <link href="http://zc95.github.io/2018/02/21/musicPlayer/"/>
    <id>http://zc95.github.io/2018/02/21/musicPlayer/</id>
    <published>2018-02-21T04:45:29.000Z</published>
    <updated>2018-03-31T04:48:24.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="material-design风格的音乐播放器"><a href="#material-design风格的音乐播放器" class="headerlink" title="material design风格的音乐播放器"></a>material design风格的音乐播放器</h2><ul><li><a href="https://zc95.github.io/demo/music.html">demo</a></li><li><a href="https://github.com/zc95/music" target="_blank" rel="external">github</a><a id="more"></a><h2 id="扫一扫"><a href="#扫一扫" class="headerlink" title="扫一扫"></a>扫一扫</h2></li></ul><p><img width="150" src="https://ws3.sinaimg.cn/large/006tNc79gy1fonxkcugj3j307s07sq2p.jpg"></p><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fony99p9rfj30u01hcmzd.jpg" height="600"></p><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fony8j721lj30u01hcwhv.jpg" height="600"></p><h2 id="HTML-5-audio标签"><a href="#HTML-5-audio标签" class="headerlink" title="HTML 5 audio标签"></a>HTML 5 audio标签</h2><h3 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h3><p> 标签定义声音，比如音乐或其他音频流，是 HTML 5 的新标签。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre><code class="html">&lt;audio src=&quot;https://music.163.com/song/media/outer/url?id=451703096.mp3&quot;&gt;您的浏览器不支持 audio 标签。&lt;/audio&gt;</code></pre><h3 id="提示和注释"><a href="#提示和注释" class="headerlink" title="提示和注释"></a>提示和注释</h3><p>可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_autoplay.asp" target="_blank" rel="external">autoplay</a></td><td>autoplay</td><td>如果出现该属性，则音频在就绪后马上播放。</td></tr><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_controls.asp" target="_blank" rel="external">controls</a></td><td>controls</td><td>如果出现该属性，则向用户显示控件，比如播放按钮。</td></tr><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_loop.asp" target="_blank" rel="external">loop</a></td><td>loop</td><td>如果出现该属性，则每当音频结束时重新开始播放。</td></tr><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_preload.asp" target="_blank" rel="external">preload</a></td><td>preload</td><td>如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td></tr><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_src.asp" target="_blank" rel="external">src</a></td><td><em>url</em></td><td>要播放的音频的 URL。</td></tr></tbody></table><h2 id="Javascript控制html5-Audio标签"><a href="#Javascript控制html5-Audio标签" class="headerlink" title="Javascript控制html5 Audio标签"></a>Javascript控制html5 Audio标签</h2><h3 id="javascript动态创建audio标签"><a href="#javascript动态创建audio标签" class="headerlink" title="javascript动态创建audio标签"></a>javascript动态创建audio标签</h3><pre><code class="javascript">var audio=document.creatElement(&quot;audio&quot;);audio.src=&quot;audio/source.ogg&quot;;//路径audio.play();</code></pre><p>or</p><pre><code class="javascript">audio=new Audio(&quot;audio/source.ogg&quot;);//路径audio.play();</code></pre><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>我们可以通过preload=”auto”来实现音频的自动加载，但是我们无法知道音频加载的进度</p><p>这时候可以用canplaythrough来完成</p><pre><code class="javascript">var audio = document.createElement(&quot;audio&quot;);audio.src = &quot;https://music.163.com/song/media/outer/url?id=451703096.mp3&quot;;audio.addEventListener(&quot;canplaythrough&quot;, function () {    alert(&#39;音频文件已经准备好，随时待命&#39;);}, false);</code></pre><p>第一次运行时间会长一些，第二次运行由于文件已经缓存到本地，所以会直接弹出提示框。</p><h3 id="javascript控制audio的播放，暂停，停止"><a href="#javascript控制audio的播放，暂停，停止" class="headerlink" title="javascript控制audio的播放，暂停，停止"></a>javascript控制audio的播放，暂停，停止</h3><pre><code class="javascript">function aPlay() {    audio.play();}function aPause() {    audio.pause();}function aStop() {    audio.currentTime = 0;    audio.pause();}function aSkip() {    audio.currentTime = 50;    audio.play(); }</code></pre><pre><code class="javascript">&lt;input type=&quot;button&quot; onclick=&quot;aPlay();&quot; value=&quot;播放音频&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;aPause();&quot; value=&quot;暂停音频&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;aStop();&quot; value=&quot;停止音频&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;aSkip();&quot; value=&quot;跳到第50秒&quot;&gt;</code></pre><h3 id="javascript控制audio的声音大小"><a href="#javascript控制audio的声音大小" class="headerlink" title="javascript控制audio的声音大小"></a>javascript控制audio的声音大小</h3><blockquote><p>audio.volume = 0;//表示静音  </p><p>audio.volume = 1; //表示声音最大</p><p>audio.volume //返回当前音量，声音值在0-1之间</p></blockquote><h3 id="javascript控制audio的快进，快退，以及显示进度与时长"><a href="#javascript控制audio的快进，快退，以及显示进度与时长" class="headerlink" title="javascript控制audio的快进，快退，以及显示进度与时长"></a>javascript控制audio的快进，快退，以及显示进度与时长</h3><blockquote><p>audio.currentTime //控制audio的进度</p><p>audio.duration //返回当前音量的总时长</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;material-design风格的音乐播放器&quot;&gt;&lt;a href=&quot;#material-design风格的音乐播放器&quot; class=&quot;headerlink&quot; title=&quot;material design风格的音乐播放器&quot;&gt;&lt;/a&gt;material design风格的音乐播放器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zc95.github.io/demo/music.html&quot;&gt;demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zc95/music&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;
    
    </summary>
    
      <category term="demo" scheme="http://zc95.github.io/categories/demo/"/>
    
    
      <category term="material design" scheme="http://zc95.github.io/tags/material-design/"/>
    
  </entry>
  
  <entry>
    <title>教你下载会员歌曲</title>
    <link href="http://zc95.github.io/2018/02/19/musicLink/"/>
    <id>http://zc95.github.io/2018/02/19/musicLink/</id>
    <published>2018-02-19T15:19:04.000Z</published>
    <updated>2018-03-31T04:48:47.851Z</updated>
    
    <content type="html"><![CDATA[<p>教你找歌曲的外链（要会员的歌曲都能下载🤪）</p><h2 id="什么是歌曲的外链？"><a href="#什么是歌曲的外链？" class="headerlink" title="什么是歌曲的外链？"></a>什么是歌曲的外链？</h2><p>我们手机里的歌曲都是下载好的mp3文件，比如说散就散.mp3，</p><p>而外链就比如 <a href="https://music.163.com/song/media/outer/url?id=523251118.mp3" target="_blank" rel="external">https://music.163.com/song/media/outer/url?id=523251118.mp3</a> 这样链接的形式。</p><a id="more"></a><h2 id="怎么免费下载会员歌曲？"><a href="#怎么免费下载会员歌曲？" class="headerlink" title="怎么免费下载会员歌曲？"></a>怎么免费下载会员歌曲？</h2><p>你应该注意到了《说散就散》在qq音乐和网易云都是要vip才能下载</p><p><img style="height:400px; display:inline-block;" src="https://ws4.sinaimg.cn/large/006tNc79gy1fom4irp01wj30nq1600x0.jpg"></p><p><img style="height:400px; display:inline-block;" src="https://ws1.sinaimg.cn/large/006tNc79gy1fom4m03u1bj30no15y77v.jpg"></p><p>这里以网易云音乐的网页版为例说一下”破解“的方法</p><p>这个外链下载会员歌曲的方法也是最近撸一个播放器的时候发现的 <a href="https://zc95.github.io/demo/music">https://zc95.github.io/demo/music</a> （还在改进，下次再说吧 ，逃。。。）</p><h2 id="废话少说，开始了"><a href="#废话少说，开始了" class="headerlink" title="废话少说，开始了"></a>废话少说，开始了</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>打开你电脑上的浏览器，输入 <a href="http://music.163.com" target="_blank" rel="external">http://music.163.com</a> ，网易云音乐官网，输入 “说散就散” 搜索，点第一个要钱的原唱！</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>到了 <a href="http://music.163.com/#/song?id=523251118" target="_blank" rel="external">http://music.163.com/#/song?id=523251118</a> 这个页面</p><ol><li>这个什么 <code>生成外链播放器</code> 不用管，就是个iframe（一般用来博客里），点了提示没版权，放弃。。。</li><li>还有下载按钮，点了提示下载PC端和app，肯定还是要会员。。。放弃</li><li><strong>重点是url，有个?id = xxxxx ，原来百度云网页版的每首歌都有自己的id标识</strong></li></ol><p><img style="height:400px;" src="https://ws2.sinaimg.cn/large/006tNc79gy1fom543cxz3j317i0tgq8q.jpg"></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>从url得到这首歌的id是 <code>523251118</code></p><p>所以这首歌的外链就是 <a href="https://music.163.com/song/media/outer/url?id=523251118.mp3" target="_blank" rel="external">https://music.163.com/song/media/outer/url?id=523251118.mp3</a> ，之后找到别的歌，把这个链接的id替换了就行，除了那种网易云没播放版权的，所有的都可以。</p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>打开电脑里的浏览器，输入 <a href="https://music.163.com/song/media/outer/url?id=523251118.mp3" target="_blank" rel="external">https://music.163.com/song/media/outer/url?id=523251118.mp3</a> 回车，这时候url被解析成好长的一段，不用管它，有上面的链接就足够了，点html5 video标签上的下载按钮就行啦（如下），移动端和Safari的video应该是没有下载按钮的。。。</p><video controls name="media"><source src="https://music.163.com/song/media/outer/url?id=523251118.mp3" type="audio/mpeg"></video><h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>如果是安卓机的就直接把这首歌导入到手机里去，qq音乐、网易云都会自动加到列表里去。</p><p>如果是iphone，，，那就没啥吊用了。。。。</p><hr><p>最后说一下，有很多方法下载这种会员歌曲，，发现这种方法是因为最近在手撸一个音乐播放器，需要用到这样的链接<a href="https://zc95.github.io/demo/music">https://zc95.github.io/demo/music</a> </p><p>不然才不费这么大劲。。毕竟我有破解版😂😂😂</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fom5ymxc3aj31ik11egs4.jpg" alt="https://ws1.sinaimg.cn/large/006tNc79gy1fom5ymxc3aj31ik11egs4.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;教你找歌曲的外链（要会员的歌曲都能下载🤪）&lt;/p&gt;
&lt;h2 id=&quot;什么是歌曲的外链？&quot;&gt;&lt;a href=&quot;#什么是歌曲的外链？&quot; class=&quot;headerlink&quot; title=&quot;什么是歌曲的外链？&quot;&gt;&lt;/a&gt;什么是歌曲的外链？&lt;/h2&gt;&lt;p&gt;我们手机里的歌曲都是下载好的mp3文件，比如说散就散.mp3，&lt;/p&gt;
&lt;p&gt;而外链就比如 &lt;a href=&quot;https://music.163.com/song/media/outer/url?id=523251118.mp3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://music.163.com/song/media/outer/url?id=523251118.mp3&lt;/a&gt; 这样链接的形式。&lt;/p&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="歌曲" scheme="http://zc95.github.io/tags/%E6%AD%8C%E6%9B%B2/"/>
    
  </entry>
  
  <entry>
    <title>Rich Text Format</title>
    <link href="http://zc95.github.io/2018/02/06/RTF/"/>
    <id>http://zc95.github.io/2018/02/06/RTF/</id>
    <published>2018-02-06T15:20:53.000Z</published>
    <updated>2018-03-31T04:49:02.246Z</updated>
    
    <content type="html"><![CDATA[<p>自己写的一个移动端的富文本编辑器</p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><ul><li><a href="https://htmlpreview.github.io/?https://github.com/zc95/RTF/blob/master/index.html" target="_blank" rel="external">demo</a></li><li><a href="https://github.com/zc95/RTF" target="_blank" rel="external">github</a><a id="more"></a></li></ul><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fo74tsp0mij31401z4aeo.jpg" style="height:500px;"></p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fo74ugdi9qj31401z4q72.jpg" style="height:500px;"><br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo74v4k9udj31401z40wu.jpg" style="height:500px;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己写的一个移动端的富文本编辑器&lt;/p&gt;
&lt;h2 id=&quot;Link&quot;&gt;&lt;a href=&quot;#Link&quot; class=&quot;headerlink&quot; title=&quot;Link&quot;&gt;&lt;/a&gt;Link&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://htmlpreview.github.io/?https://github.com/zc95/RTF/blob/master/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zc95/RTF&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="html" scheme="http://zc95.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>一行代码实现星级评分</title>
    <link href="http://zc95.github.io/2018/01/23/star-rating/"/>
    <id>http://zc95.github.io/2018/01/23/star-rating/</id>
    <published>2018-01-23T13:03:13.000Z</published>
    <updated>2018-01-30T15:23:57.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fnqvphubb8j30lu0dodhh.jpg" alt=""></p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><ul><li><a href="https://htmlpreview.github.io/?https://github.com/zc95/star-rating/blob/master/index.html" target="_blank" rel="external">demo</a></li><li><a href="https://github.com/zc95/star-rating" target="_blank" rel="external">github</a></li></ul><a id="more"></a><h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><pre><code class="css">.score_wrapper {      display:inline-block;      font-size: 45px;      cursor: pointer;      color: #dc2020;      -webkit-user-select:none;      -moz-user-select:none;      -ms-user-select:none;      user-select:none;    }</code></pre><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><pre><code class="html">&lt;div class=&quot;score_wrapper&quot;&gt;&lt;/div&gt;</code></pre><h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><pre><code class="javascript">    $(function () {      ScoreInit(3); //初始化，参数是0～5的数字，代表星数，传空默认0颗星    })    //点击    function ScoreInit(e) {      Score((e == null) ? 0 : e); //传空默认0颗星      $(&quot;.score_wrapper&quot;).bind(&#39;click&#39;, function (e) {        var eachWidth = $(&quot;.score_wrapper&quot;).width() / 5; //计算出每个星星的长度        var X = e.pageX - $(this).offset().left; //距离父容器的偏移距离        var score = Math.floor(X / eachWidth) + 1; //分数        Score((getScore() == score) ? 0 : score); //取消评分      })    }    //评分    function Score(rate) {      $(&quot;.score_wrapper&quot;).html(&quot;★★★★★☆☆☆☆☆&quot;.slice(5 - rate, 10 - rate));    }    //获取评分    function getScore() {      var str = $(&quot;.score_wrapper&quot;).html(), num = 0;      for (var i = 0; i &lt; str.length; i++) {        if (str[i] == &quot;★&quot;) {          num++        }      }      return num;    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1fnqvphubb8j30lu0dodhh.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Link&quot;&gt;&lt;a href=&quot;#Link&quot; class=&quot;headerlink&quot; title=&quot;Link&quot;&gt;&lt;/a&gt;Link&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://htmlpreview.github.io/?https://github.com/zc95/star-rating/blob/master/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zc95/star-rating&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="html" scheme="http://zc95.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>水平垂直居中</title>
    <link href="http://zc95.github.io/2018/01/10/centerAndmiddle/"/>
    <id>http://zc95.github.io/2018/01/10/centerAndmiddle/</id>
    <published>2018-01-10T13:17:24.000Z</published>
    <updated>2018-01-10T14:26:16.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="水平垂直居中（已知宽高）"><a href="#水平垂直居中（已知宽高）" class="headerlink" title="水平垂直居中（已知宽高）"></a>水平垂直居中（已知宽高）</h2><p>方法很多，这里就说一个不常见的</p><pre><code class="Html">&lt;div class=&quot;father&quot;&gt;  &lt;div class=&quot;son&quot;&gt;    &lt;p&gt;zc95.github.io&lt;/p&gt;    &lt;p&gt;zc95.github.io&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.father {  position: relative;  width: 300px;  height: 300px;  border: 1px solid black;}.son {  position: absolute;  width: 60px;  height: 60px;  top: 0;  left: 0;  bottom: 0;  right: 0;  margin: auto;  border: 1px solid gray;}</code></pre><a id="more"></a><hr><h2 id="水平垂直居中（宽高不确定-伪元素）"><a href="#水平垂直居中（宽高不确定-伪元素）" class="headerlink" title="水平垂直居中（宽高不确定/伪元素）"></a>水平垂直居中（宽高不确定/伪元素）</h2><p>用伪元素和 inline-block / vertical-align 可以实现水平垂直居中</p><pre><code class="html">&lt;div class=&quot;father&quot;&gt;  &lt;div class=&quot;son&quot;&gt;    &lt;p&gt;zc95.github.io&lt;/p&gt;    &lt;p&gt;zc95.github.io&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.father {  position:fixed;  top:0;  right:0;  left:0;  bottom:0;  text-align: center;  border: 1px solid black;}.father:before {  content: &#39;&#39;;  display: inline-block;  height: 100%;  vertical-align: middle;  margin-right: -0.25em; /*去空隙*/}.son {  display: inline-block;  vertical-align: middle;  border: 1px solid gray;}</code></pre><hr><h2 id="水平垂直居中（宽高不确定-flex）"><a href="#水平垂直居中（宽高不确定-flex）" class="headerlink" title="水平垂直居中（宽高不确定/flex）"></a>水平垂直居中（宽高不确定/flex）</h2><p>css弹性布局（flex）</p><pre><code class="html">&lt;div class=&quot;father&quot;&gt;  &lt;div class=&quot;son&quot; style=&quot;display:inline-block;&quot;&gt;    &lt;p&gt;zc95.github.io&lt;/p&gt;    &lt;p&gt;zc95.github.io&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.father {  height: 300px;  width: 100%;  display: flex;  align-items: center; /*定义body的元素垂直居中*/  justify-content: center; /*定义body的里的元素水平居中*/}.son{  border:1px solid gray;}</code></pre><hr><h2 id="水平垂直居中（宽高不确定-transform）"><a href="#水平垂直居中（宽高不确定-transform）" class="headerlink" title="水平垂直居中（宽高不确定/transform）"></a>水平垂直居中（宽高不确定/transform）</h2><p>CSS3的transform，通过设置div的transform: translate(-50%,-50%)，使得div向上平移（translate）自身高度的一半(50%)、自身宽度的一半(50%)</p><pre><code class="html">&lt;div class=&quot;son&quot;&gt;  &lt;p&gt;zc95.github.io&lt;/p&gt;  &lt;p&gt;zc95.github.io&lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="css">.son {  position: absolute;  top: 50%;  left: 50%;  -webkit-transform: translate(-50%,-50%);  -moz-transform: translate(-50%,-50%);  -ms-transform: translate(-50%,-50%);  transform: translate(-50%,-50%);  border: 1px solid gray;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;水平垂直居中（已知宽高）&quot;&gt;&lt;a href=&quot;#水平垂直居中（已知宽高）&quot; class=&quot;headerlink&quot; title=&quot;水平垂直居中（已知宽高）&quot;&gt;&lt;/a&gt;水平垂直居中（已知宽高）&lt;/h2&gt;&lt;p&gt;方法很多，这里就说一个不常见的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Html&quot;&gt;&amp;lt;div class=&amp;quot;father&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;son&amp;quot;&amp;gt;
    &amp;lt;p&amp;gt;zc95.github.io&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;zc95.github.io&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.father {
  position: relative;
  width: 300px;
  height: 300px;
  border: 1px solid black;
}

.son {
  position: absolute;
  width: 60px;
  height: 60px;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  margin: auto;
  border: 1px solid gray;
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="css" scheme="http://zc95.github.io/tags/css/"/>
    
      <category term="水平垂直居中" scheme="http://zc95.github.io/tags/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>ToDo 待办事宜app</title>
    <link href="http://zc95.github.io/2018/01/07/ToDo/"/>
    <id>http://zc95.github.io/2018/01/07/ToDo/</id>
    <published>2018-01-07T10:29:58.000Z</published>
    <updated>2018-01-07T12:54:37.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo"></a>ToDo</h2><p>最近做事情总是丢三落四，老忘记一些重要的事情，就突发奇想写了这个 <code>ToDo</code> 待办事宜的app。</p><ol><li><a href="https://htmlpreview.github.io/?https://github.com/zc95/ToDo/blob/master/index.html#" target="_blank" rel="external">项目地址</a></li><li><a href="https://github.com/zc95/ToDo" target="_blank" rel="external">github地址</a></li></ol><p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;display:inline-block;" src="https://ws2.sinaimg.cn/large/006tNc79gy1fn8bgdbyhbj30xr1o04b6.jpg" height="500px;"><br><img style="box-shadow:1px 1px 10px #888888;display:inline-block;" src="https://ws4.sinaimg.cn/large/006tNc79gy1fn8bo7m0uqj30xr1o0tgz.jpg" height="500px;"><br></p><a id="more"></a><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ol><li>可以添加待办事项到首页中，数据都是保存在本地localStorage的，只要不是手动删除或者换了设备，数据是永久保存的</li><li>点击事项可以将待办事项的状态改为 <code>选中</code> 和 <code>未选中</code> ，每次改变状态都会保存到localStorage，每天的开始都可以点 <code>重置所有状态</code> 的按钮来设置所有的待办事项为未选中</li><li>可以删除已添加的待办事项或者彻底删除所有本地localStorage数据</li></ol><p>可以复制项目链接在自己的浏览器中打开，然后添加到桌面，方便使用；<br><a href="https://htmlpreview.github.io/?https://github.com/zc95/ToDo/blob/master/index.html" target="_blank" rel="external">https://htmlpreview.github.io/?https://github.com/zc95/ToDo/blob/master/index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ToDo&quot;&gt;&lt;a href=&quot;#ToDo&quot; class=&quot;headerlink&quot; title=&quot;ToDo&quot;&gt;&lt;/a&gt;ToDo&lt;/h2&gt;&lt;p&gt;最近做事情总是丢三落四，老忘记一些重要的事情，就突发奇想写了这个 &lt;code&gt;ToDo&lt;/code&gt; 待办事宜的app。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://htmlpreview.github.io/?https://github.com/zc95/ToDo/blob/master/index.html#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;项目地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zc95/ToDo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github地址&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;text-align:center;&quot;&gt;&lt;br&gt;&lt;img style=&quot;box-shadow:1px 1px 10px #888888;display:inline-block;&quot; src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fn8bgdbyhbj30xr1o04b6.jpg&quot; height=&quot;500px;&quot;&gt;&lt;br&gt;&lt;img style=&quot;box-shadow:1px 1px 10px #888888;display:inline-block;&quot; src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fn8bo7m0uqj30xr1o0tgz.jpg&quot; height=&quot;500px;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="demo" scheme="http://zc95.github.io/categories/demo/"/>
    
    
      <category term="localStorage" scheme="http://zc95.github.io/tags/localStorage/"/>
    
  </entry>
  
  <entry>
    <title>VMware服务器虚拟化</title>
    <link href="http://zc95.github.io/2017/12/26/VMware/"/>
    <id>http://zc95.github.io/2017/12/26/VMware/</id>
    <published>2017-12-26T12:49:24.000Z</published>
    <updated>2017-12-26T13:10:59.660Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="https://ws2.sinaimg.cn/large/006tNc79gy1fmucwl7r2aj31hc0u0dng.jpg" width="90%;"><br></p><p>今天去机房打了一天酱油，听到了看到了一些没接触过的东西，做个简单的整理。</p><h2 id="VMware服务器虚拟化"><a href="#VMware服务器虚拟化" class="headerlink" title="VMware服务器虚拟化"></a>VMware服务器虚拟化</h2><p><a href="https://www.vmware.com/cn/solutions/virtualization.html" target="_blank" rel="external">VMware官网</a></p><p>大多数服务器的容量利用率不足 15%，这不仅导致了服务器数量剧增，还增加了复杂性。实现服务器虚拟化后，多个操作系统可以作为虚拟机在单台物理服务器上运行，并且每个操作系统都可以访问底层服务器的计算资源，从而解决效率低下问题。接下来将服务器集群聚合为一项整合资源，这可以提高整体效率并降低成本。服务器虚拟化还可以加快工作负载部署速度、提高应用性能以及改善可用性。</p><a id="more"></a><h3 id="虚拟化的优势"><a href="#虚拟化的优势" class="headerlink" title="虚拟化的优势"></a>虚拟化的优势</h3><p>虚拟化可以提高 IT 部门的敏捷性、灵活性和可扩展性，同时大幅节约成本。工作负载的部署速度更快、性能和可用性得到提升、运维实现自动化，所有这一切不仅简化了 IT 管理，还降低了拥有成本和运维成本。其他优势包括：</p><ol><li>降低资金成本和运维成本。</li><li>最大限度地减少或消除停机。</li><li>提高 IT 部门的工作效率、效益、敏捷性和响应能力。</li><li>更快地调配应用和资源。</li><li>支持业务连续性与灾难恢复。</li><li>简化数据中心管理。</li><li>构建真正的软件定义的数据中心</li></ol><h3 id="VMware-vSphere-client"><a href="#VMware-vSphere-client" class="headerlink" title="VMware vSphere client"></a>VMware vSphere client</h3><p>用来连接<a href="https://www.baidu.com/s?wd=VMware&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3rARvrjnvm19bPHfsnA790ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHT4P16dPHm3rjcdnW0drHnsPs" target="_blank" rel="external">VMware</a> ESXi主机和vCenter server，业内最完整、 最强健的虚拟化平台。创建资源池来管理计算、 网络和存储容量与易用性，并提供最高水平的服务，每个应用程序工作负载以最低的总成本。VSphere — — 取决于世界上要求最苛刻的数据中心虚拟化您业务关键型应用程序为空前的灵活性和可靠性。</p><h2 id="UPS电源"><a href="#UPS电源" class="headerlink" title="UPS电源"></a>UPS电源</h2><p><a href="https://baike.baidu.com/item/不间断电源" target="_blank" rel="external">百度百科</a></p><p>UPS电源一般指不间断电源。</p><p><a href="https://baike.baidu.com/item/UPS" target="_blank" rel="external">UPS</a>（Uninterruptible Power System/Uninterruptible Power Supply），即不间断<a href="https://baike.baidu.com/item/%E7%94%B5%E6%BA%90" target="_blank" rel="external">电源</a>，是将<a href="https://baike.baidu.com/item/%E8%93%84%E7%94%B5%E6%B1%A0" target="_blank" rel="external">蓄电池</a>（多为铅酸免维护蓄电池）与主机相连接，通过主机逆变器等模块电路将直流电转换成市电的系统设备。主要用于给单台<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="external">计算机</a>、计算机网络系统或其它<a href="https://baike.baidu.com/item/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E8%AE%BE%E5%A4%87" target="_blank" rel="external">电力电子设备</a>如电磁阀、压力变送器等提供稳定、不间断的电力供应。当市电输入正常时，UPS 将市电稳压后供应给<a href="https://baike.baidu.com/item/%E8%B4%9F%E8%BD%BD" target="_blank" rel="external">负载</a>使用，此时的UPS就是一台交流式电<a href="https://baike.baidu.com/item/%E7%A8%B3%E5%8E%8B%E5%99%A8" target="_blank" rel="external">稳压器</a>，同时它还向机内电池充电；当市电中断（事故停电）时， UPS 立即将电池的直流电能，通过逆变器切换转换的<a href="https://baike.baidu.com/item/%E6%96%B9%E6%B3%95" target="_blank" rel="external">方法</a>向负载继续供应220V<a href="https://baike.baidu.com/item/%E4%BA%A4%E6%B5%81%E7%94%B5" target="_blank" rel="external">交流电</a>，使负载维持正常工作并保护负载软、<a href="https://baike.baidu.com/item/%E7%A1%AC%E4%BB%B6" target="_blank" rel="external">硬件</a>不受损坏。UPS 设备通常对电压过高或电压过低都能提供保护。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><strong>UPS</strong>是针对中国电网环境和<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7" target="_blank" rel="external">网络监控</a>及<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="external">网络系统</a>、<a href="https://baike.baidu.com/item/%E5%8C%BB%E7%96%97" target="_blank" rel="external">医疗</a>系统等对<a href="https://baike.baidu.com/item/%E7%94%B5%E6%BA%90" target="_blank" rel="external">电源</a>的可靠性要求，克服中、大型<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="external">计算机</a>网络系统集中供电所造成的供电电网环境日益恶劣的问题，以全新的数字技术研制出的第三代工频纯在线式智能型UPS。直流电源，是维持电路中形成稳恒电流的装置。如干电池、蓄电池、<a href="https://baike.baidu.com/item/%E7%9B%B4%E6%B5%81%E5%8F%91%E7%94%B5%E6%9C%BA" target="_blank" rel="external">直流发电机</a>等。</li><li><strong>UPS</strong>和<a href="https://baike.baidu.com/item/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%BA%90" target="_blank" rel="external">直流电源</a>是企业重要的供电保障设备，传统的维护管理包括：①日常巡检外观，定期更换电池、<a href="https://baike.baidu.com/item/%E6%BB%A4%E6%B3%A2%E7%94%B5%E5%AE%B9" target="_blank" rel="external">滤波电容</a>、<a href="https://baike.baidu.com/item/%E9%A3%8E%E6%9C%BA" target="_blank" rel="external">风机</a>等易损件，大修时做电池活化等；②改造或采用换代设备，使用高级工具测试电池性能。这种管理方式企业投入成本高，维护人员工作量大，不易实时掌握设备运行状态和关键数据，设备事故预防能力低。实施在线维护管理可避免传统方式的不足之处，获得良好效益。</li><li><strong>UPS</strong>的中文意思为“不间断电源”，是英语“Uninterruptible Power System/Uninterruptible Power Supply”的缩写，它可以保障计算机系统在停电之后继续工作一段时间以使用户能够紧急<a href="https://baike.baidu.com/item/%E5%AD%98%E7%9B%98" target="_blank" rel="external">存盘</a>，使用户不致因停电而影响工作或丢失<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE" target="_blank" rel="external">数据</a>。</li></ol><hr><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p><a href="https://baike.baidu.com/item/cisco交换机" target="_blank" rel="external">百度百科</a></p><p>交换机（Switch）意为“<a href="https://baike.baidu.com/item/%E5%BC%80%E5%85%B3/2275072" target="_blank" rel="external">开关</a>”是一种用于电（光）信号转发的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87" target="_blank" rel="external">网络设备</a>。它可以为接入交换机的任意两个<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E8%8A%82%E7%82%B9" target="_blank" rel="external">网络节点</a>提供独享的电信号通路。最常见的交换机是<a href="https://baike.baidu.com/item/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA" target="_blank" rel="external">以太网交换机</a>。其他常见的还有电话语音交换机、<a href="https://baike.baidu.com/item/%E5%85%89%E7%BA%A4%E4%BA%A4%E6%8D%A2%E6%9C%BA" target="_blank" rel="external">光纤交换机</a>等。</p><p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="https://ws1.sinaimg.cn/large/006tNc79gy1fmudmq5dhvj31hc1han99.jpg" width="90%;"><br></p><p>图片上是 <code>Cisco Catalyst 4500-E Series</code> ，<a href="https://www.cisco.com/c/zh_cn/products/switches/catalyst-4500-x-series-switches/index.html?POSITION=SEM&amp;COUNTRY_SITE=cn&amp;CAMPAIGN=EN-04+Switches&amp;CREATIVE=APJC_GMP_EN-04_CN-Switches%2bSwitches%7cModel-45E&amp;REFERRING_SITE=Baidu&amp;KEYWORD=catalyst+4500E&amp;CCID=cc000010&amp;DTID=psebdu000360&amp;gclid=CMD8q-zEp9gCFVLZvAodLsEBXg&amp;gclsrc=ds" target="_blank" rel="external">Cisco Catalyst 4500-X 系列交换机</a></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>交换（switching）</strong>是按照通信两端传输信息的需要，用人工或设备自动完成的方法，把要传输的信息送到符合要求的相应路由上的技术的统称。根据工作位置的不同，可以分为<a href="https://baike.baidu.com/item/%E5%B9%BF%E5%9F%9F%E7%BD%91" target="_blank" rel="external">广域网</a>交换机和<a href="https://baike.baidu.com/item/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA" target="_blank" rel="external">局域网交换机</a>。广义的<strong>交换机（switch）</strong>就是一种在通信系统中完成信息交换功能的设备。</p><p>在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="external">计算机网络系统</a>中，交换概念的提出改进了共享工作模式。我们以前介绍过的HUB集线器就是一种共享设备，HUB本身不能识别目的地址，当同一局域网内的A主机给B主机传输数据时，<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85" target="_blank" rel="external">数据包</a>在以HUB为架构的网络上是以广播方式传输的，由每一台终端通过验证数据包头的地址信息来确定是否接收。也就是说，在这种工作方式下，同一时刻网络上只能传输一组<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%B8%A7" target="_blank" rel="external">数据帧</a>的通讯，如果发生碰撞还得重试。这种方式就是共享<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%B8%A6%E5%AE%BD" target="_blank" rel="external">网络带宽</a>。</p><hr><h2 id="hub"><a href="#hub" class="headerlink" title="hub"></a>hub</h2><p><a href="https://baike.baidu.com/item/HUB" target="_blank" rel="external">百度百科</a></p><p>HUB是一个多端口的<a href="https://baike.baidu.com/item/%E8%BD%AC%E5%8F%91%E5%99%A8" target="_blank" rel="external">转发器</a>，在以HUB为中心设备时，即使网络中某条线路产生了故障，并不影响其它线路的工作。所以HUB在<a href="https://baike.baidu.com/item/%E5%B1%80%E5%9F%9F%E7%BD%91" target="_blank" rel="external">局域网</a>中得到了广泛的应用。大多数的时候它用在星型与<a href="https://baike.baidu.com/item/%E6%A0%91%E5%9E%8B%E7%BD%91%E7%BB%9C" target="_blank" rel="external">树型网络</a>拓扑结构中，以RJ45接口与各主机相连（也有<a href="https://baike.baidu.com/item/BNC%E6%8E%A5%E5%8F%A3" target="_blank" rel="external">BNC接口</a>），HUB按照不同的说法有很多种类。 HUB按照对输入信号的处理方式上，可以分为无源HUB、有源HUB、智能HUB。</p><hr><h2 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h2><p><a href="https://baike.baidu.com/item/磁盘阵列" target="_blank" rel="external">百度百科</a></p><p>磁盘阵列（Redundant Arrays of Independent Disks，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。</p><p>磁盘阵列是由很多价格较便宜的<a href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98" target="_blank" rel="external">磁盘</a>，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。利用这项技术，将数据切割成许多区段，分别存放在各个硬盘上。</p><p>磁盘阵列还能利用同位检查（Parity Check）的观念，在<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84" target="_blank" rel="external">数组</a>中任意一个<a href="https://baike.baidu.com/item/%E7%A1%AC%E7%9B%98%E6%95%85%E9%9A%9C" target="_blank" rel="external">硬盘故障</a>时，仍可读出数据，在数据重构时，将数据经计算后重新置入新硬盘中。</p><hr><h2 id="堡垒机"><a href="#堡垒机" class="headerlink" title="堡垒机"></a>堡垒机</h2><p><a href="https://baike.baidu.com/item/堡垒机" target="_blank" rel="external">百度百科</a></p><p>堡垒机，即在一个特定的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83" target="_blank" rel="external">网络环境</a>下，为了保障网络和数据不受来自外部和内部用户的入侵和破坏，而运用各种技术手段实时收集和监控网络环境中每一个组成部分的系统状态、安全事件、网络活动，以便集中<a href="https://baike.baidu.com/item/%E6%8A%A5%E8%AD%A6" target="_blank" rel="external">报警</a>、及时处理及<a href="https://baike.baidu.com/item/%E5%AE%A1%E8%AE%A1/2140835" target="_blank" rel="external">审计</a>定责。</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>随着企事业单位IT系统的不断发展，网络规模和设备数量迅速扩大，日趋复杂的IT系统与不同背景的运维人员的行为给信息系统安全带来较大风险，主要表现在：</p><ol><li>多个用户使用同一个账号。这种情况主要出现在同一工作组中，由于工作需要，同时系统管理账号唯一，因此只能多用户共享同一账号。如果发生安全事故，不仅难以定位账号的实际使用者和责任人，而且无法对账号的使用范围进行有效控制，存在较大安全风险和隐患。</li></ol><ol><li><p>一个用户使用多个账号。目前，一个维护人员使用多个账号是较为普遍的情况，用户需要记忆多套口令同时在多套主机系统、网络设备之间切换，降低工作效率，增加工作复杂度。如下图所示：</p><p style="text-align:center;"><br><img style="box-shadow:1px 1px 10px #888888;" src="https://ws2.sinaimg.cn/large/006tNc79gy1fmuei2zoarj306405faa3.jpg" width="50%;"><br></p></li><li><p>缺少统一的权限管理平台，权限管理日趋繁重和无序；而且维护人员的权限大多是粗放管理，无法基于最小权限分配原则的用户权限管理，难以实现更细粒度的命令级权限控制，系统安全性无法充分保证。</p></li><li>无法制定统一的访问审计策略，审计粒度粗。各网络设备、主机系统、数据库是分别单独审计记录访问行为，由于没有统一审计策略，并且各系统自身审计日志内容深浅不一，难以及时通过系统自身审计发现违规操作行为和追查取证。</li><li>传统的网络安全审计系统无法对维护人员经常使用的SSH、RDP等加密、图形操作协议进行内容审计。</li></ol><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><h4 id="单点登录功能"><a href="#单点登录功能" class="headerlink" title="单点登录功能"></a>单点登录功能</h4><p>支持对X11、linux、unix、数据库、网络设备、安全设备等一系列授权账号进行密码的自动化周期更改，简化密码管理，让使用者无需记忆众多系统密码，即可实现自动登录目标设备，便捷安全。[1]<a href=""> </a></p><h4 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h4><p>设备支持统一账户管理策略，能够实现对所有服务器、网络设备、安全设备等账号进行集中管理，完成对账号整个生命周期的监控，并且可以对设备进行特殊角色设置如：<a href="https://baike.baidu.com/item/%E5%AE%A1%E8%AE%A1/2140835" target="_blank" rel="external">审计</a>巡检员、<a href="https://baike.baidu.com/item/%E8%BF%90%E7%BB%B4" target="_blank" rel="external">运维</a>操作员、<a href="https://baike.baidu.com/item/%E8%AE%BE%E5%A4%87" target="_blank" rel="external">设备</a>管理员等自定义设置，以满足审计需求</p><h4 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h4><p>设备提供统一的认证接口，对用户进行认证，支持身份认证模式包括 动态口令、静态密码、硬件key 、生物特征等多种认证方式，设备具有灵活的定制接口，可以与其他第三方认证服务器之间结合；安全的认证模式，有效提高了认证的安全性和可靠性。</p><h4 id="资源授权"><a href="#资源授权" class="headerlink" title="资源授权"></a>资源授权</h4><p>设备提供基于用户、目标设备、时间、协议类型<a href="https://baike.baidu.com/item/IP/224599" target="_blank" rel="external">IP</a>、行为等要素实现细粒度的操作授权，最大限度保护用户资源的安全</p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>设备支持对不同用户进行不同策略的制定，细粒度的访问控制能够最大限度的保护用户资源的安全，严防非法、越权访问事件的发生。</p><h4 id="操作审计"><a href="#操作审计" class="headerlink" title="操作审计"></a>操作审计</h4><p>设备能够对<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="external">字符串</a>、<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2/773307" target="_blank" rel="external">图形</a>、<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93" target="_blank" rel="external">文件传输</a>、<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="external">数据库</a>等全程操作行为审计；通过设备录像方式实时监控运维人员对操作系统、安全设备、网络设备、数据库等进行的各种操作，对违规行为进行事中控制。对终端指令信息能够进行精确搜索，进行录像精确定位。[2]<a href=""> </a></p>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;text-align:center;&quot;&gt;&lt;br&gt;&lt;img style=&quot;box-shadow:1px 1px 10px #888888;&quot; src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fmucwl7r2aj31hc0u0dng.jpg&quot; width=&quot;90%;&quot;&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;今天去机房打了一天酱油，听到了看到了一些没接触过的东西，做个简单的整理。&lt;/p&gt;
&lt;h2 id=&quot;VMware服务器虚拟化&quot;&gt;&lt;a href=&quot;#VMware服务器虚拟化&quot; class=&quot;headerlink&quot; title=&quot;VMware服务器虚拟化&quot;&gt;&lt;/a&gt;VMware服务器虚拟化&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.vmware.com/cn/solutions/virtualization.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VMware官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大多数服务器的容量利用率不足 15%，这不仅导致了服务器数量剧增，还增加了复杂性。实现服务器虚拟化后，多个操作系统可以作为虚拟机在单台物理服务器上运行，并且每个操作系统都可以访问底层服务器的计算资源，从而解决效率低下问题。接下来将服务器集群聚合为一项整合资源，这可以提高整体效率并降低成本。服务器虚拟化还可以加快工作负载部署速度、提高应用性能以及改善可用性。&lt;/p&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="VMware" scheme="http://zc95.github.io/tags/VMware/"/>
    
      <category term="服务器虚拟化" scheme="http://zc95.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="堡垒机" scheme="http://zc95.github.io/tags/%E5%A0%A1%E5%9E%92%E6%9C%BA/"/>
    
      <category term="磁盘阵列" scheme="http://zc95.github.io/tags/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/"/>
    
      <category term="交换机" scheme="http://zc95.github.io/tags/%E4%BA%A4%E6%8D%A2%E6%9C%BA/"/>
    
  </entry>
  
</feed>
