<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张成的学习笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zc95.github.io/"/>
  <updated>2018-09-02T05:00:42.270Z</updated>
  <id>http://zc95.github.io/</id>
  
  <author>
    <name>张成</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>weex踩坑第一天</title>
    <link href="http://zc95.github.io/2018/09/02/weex-day1/"/>
    <id>http://zc95.github.io/2018/09/02/weex-day1/</id>
    <published>2018-09-02T04:58:58.000Z</published>
    <updated>2018-09-02T05:00:42.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Weex-？"><a href="#什么是-Weex-？" class="headerlink" title="什么是 Weex ？"></a>什么是 Weex ？</h2><blockquote><p>Weex 是一个使用 Web 开发体验来开发高性能原生应用的框架。</p></blockquote><p>Weex 致力于使开发者能基于当代先进的 Web 开发技术，使用同一套代码来构建 Android、iOS 和 Web 应用。具体来讲，在集成了 WeexSDK 之后，你可以使用 JavaScript 和现代流行的前端框架来开发移动应用。</p><p>Weex 的结构是解耦的，渲染引擎与语法层是分开的，也不依赖任何特定的前端框架，目前主要支持 Vue.js 和 Rax 这两个前端框架。</p><p>Weex 的另一个主要目标是跟进当代先进的 Web 开发和原生开发的技术，使生产力和性能共存。在开发 Weex 页面就像开发普通网页一样；在渲染 Weex 页面时和渲染原生页面一样。</p><h2 id="weex与vue的异同"><a href="#weex与vue的异同" class="headerlink" title="weex与vue的异同"></a>weex与vue的异同</h2><ol><li>不推荐使用vue-router，weex编译出的页面不再是一个SPA（单页面应用），而是多页应用，如果组件层级嵌套过深或者路由过多很容易造成性能问题</li><li>weex中使用vuex和在vue中类似，但是weex是多页应用，多个页面之间的store是不同的，不能跨页面使用</li></ol><h2 id="css知识点，为了适配三端有很多约束"><a href="#css知识点，为了适配三端有很多约束" class="headerlink" title="css知识点，为了适配三端有很多约束"></a>css知识点，为了适配三端有很多约束</h2><ol><li><p>weex中所有样式都是自带scoped，不存在全局污染，强制只对本页有效</p></li><li><p>不支持百分比布局，用px比较合适，默认750px是100%宽度，会根据不同手机自动适配</p></li><li><p>npm start之后在浏览器中预览的效果并不正确，因为weex构建的是原生应用，只有在真机或者Android Studio/Xcode 上看到的才是最终效果</p></li><li><p>不支持类似 border: 1px solid #ccc; 的组合写法，拆分成：</p><blockquote><p>border-width border-style border-color</p></blockquote></li><li><p>支持flexbox:  flex-direction justify-content align-items flex</p></li><li><p>支持position定位，但是不支持z-index,元素层级按照先后顺序，越靠后层级越高</p></li><li><p>伪类只支持active。有个特例就是input和textaraea，支持focus，enabled，disabled来设置样式</p></li></ol><h2 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h2><ol><li>所有的能看到文字都必须放在 <code>text</code> 组件中</li><li>尽量避免使用 <code>a</code> 标签，用了之后只能在native端运行，在web端会打开一堆代码</li><li><code>div</code> 中不能放置文字</li></ol><h2 id="使用字体图标"><a href="#使用字体图标" class="headerlink" title="使用字体图标"></a>使用字体图标</h2><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fuv2p3q7nzj31k00xegrz.jpg" alt=""></p><h3 id="src-index-vue"><a href="#src-index-vue" class="headerlink" title="src/index.vue"></a>src/index.vue</h3><pre><code class="javascript">export default {  name: &quot;App&quot;,  beforeCreate() {    const domModule = weex.requireModule(&quot;dom&quot;);    domModule.addRule(&quot;fontFace&quot;, {      fontFamily: &quot;iconfont&quot;,      src: &quot;url(&#39;http://at.alicdn.com/t/font_544044_k9kgix8mzs.ttf&#39;)&quot;    })  }}</code></pre><pre><code class="css">.iconfont{  font-family: iconfont;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-Weex-？&quot;&gt;&lt;a href=&quot;#什么是-Weex-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Weex ？&quot;&gt;&lt;/a&gt;什么是 Weex ？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Weex 是一个使用 Web 开发体验来开发高性能
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="weex" scheme="http://zc95.github.io/tags/weex/"/>
    
  </entry>
  
  <entry>
    <title>阿里的面试邀请</title>
    <link href="http://zc95.github.io/2018/09/01/ali/"/>
    <id>http://zc95.github.io/2018/09/01/ali/</id>
    <published>2018-09-01T15:19:52.000Z</published>
    <updated>2018-09-01T15:29:15.534Z</updated>
    
    <content type="html"><![CDATA[<p>昨天收到阿里的面试邀请，第一感受就是大厂也这么缺人？饥不择食嘛哈哈，不过也可能是爬虫群发之类的东西，没有想太多（深知自己欠缺太多太多…）。<br>今天上海的朋友回苏州，聊了很久，果然大都市用的技术都先进，什么weex，react native，只能说自己压根没有接触过，也只是偶尔听说。。<br>还是赶紧学习吧！无论是RN，还是weex，都要开始学起来了。</p><p>附上面试邀请勉励自己一下哈哈，加油！！<br><img src="https://i.loli.net/2018/09/01/5b8aae86e2e7e.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天收到阿里的面试邀请，第一感受就是大厂也这么缺人？饥不择食嘛哈哈，不过也可能是爬虫群发之类的东西，没有想太多（深知自己欠缺太多太多…）。&lt;br&gt;今天上海的朋友回苏州，聊了很久，果然大都市用的技术都先进，什么weex，react native，只能说自己压根没有接触过，也只
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="html" scheme="http://zc95.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>qrcode和Websocket实现在线支付</title>
    <link href="http://zc95.github.io/2018/08/16/qrcodeAndWebsocket/"/>
    <id>http://zc95.github.io/2018/08/16/qrcodeAndWebsocket/</id>
    <published>2018-08-16T12:22:23.000Z</published>
    <updated>2018-08-16T12:25:39.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>收营员选择收款方式（现金/支付宝/微信），如果是支付宝/微信，服务端会传给前端一个交易码，前端用 <strong>qrcode</strong> 生成二维码给客户扫并且支付，<strong>websocket</strong> 建立持久的连接直到收到服务端返回的true，前端提示交易成功。</p><h2 id="HTML5-WebSocket"><a href="#HTML5-WebSocket" class="headerlink" title="HTML5 WebSocket"></a>HTML5 WebSocket</h2><p>1.简介</p><p>我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ </p><p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 </p><p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 </p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p><p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p><p>2.使用</p><p><a href="http://jsbin.com/muqamiqimu/edit?js,console" target="_blank" rel="external">http://jsbin.com/muqamiqimu/edit?js,console</a></p><pre><code class="JS">var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);ws.onopen = function(evt) {   console.log(&quot;Connection open ...&quot;);   ws.send(&quot;Hello WebSockets!&quot;);};ws.onmessage = function(evt) {  console.log( &quot;Received Message: &quot; + evt.data);  ws.close();};ws.onclose = function(evt) {  console.log(&quot;Connection closed.&quot;);};</code></pre><h2 id="qrcode-vue"><a href="#qrcode-vue" class="headerlink" title="qrcode-vue"></a>qrcode-vue</h2><p><a href="https://www.npmjs.com/package/qrcode-vue" target="_blank" rel="external">https://www.npmjs.com/package/qrcode-vue</a></p><p>1.安装</p><blockquote><p>npm install –save qrcode.vue</p></blockquote><p>2.使用</p><pre><code class="vue">&lt;template&gt;  &lt;div&gt;    &lt;qrcode-vue       :size=&quot;size&quot;       :value=&quot;value&quot;       :logo=&quot;logo&quot;       :bgColor=&quot;bgColor&quot;       :fgColor=&quot;fgColor&quot;    &gt;&lt;/qrcode-vue&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="vue">&lt;script&gt;  import qrcodeVue from &#39;../src/qrcode-vue&#39;  export default {    data () {      return {        size: 128,        bgColor: &#39;#fff&#39;,        fgColor: &#39;#000&#39;,        value: &#39;https://github.com/l-ll/qrcode-vue&#39;,        logo: &#39;https://avatars3.githubusercontent.com/u/7104141?v=3&amp;s=80&#39;      }    },    components: {      qrcodeVue    }  }&lt;/script&gt;</code></pre><h2 id="在线支付场景实例"><a href="#在线支付场景实例" class="headerlink" title="在线支付场景实例"></a>在线支付场景实例</h2><pre><code class="vue">&lt;style lang=&quot;less&quot;&gt;    @import &#39;../../styles/common.less&#39;;    .pay-template {        .title {            font-size: 18px;            font-weight: 700;        }        .orderInfo {            .payType {                width: 200px            }            canvas {                border-radius: 4px;            }        }        .footer {            text-align: right;            .submit {                margin-left: 5px;            }        }    }&lt;/style&gt;&lt;template&gt;    &lt;div class=&quot;pay-template&quot;&gt;        &lt;Spin size=&quot;large&quot; fix v-if=&quot;spinShow&quot;&gt;&lt;/Spin&gt;        &lt;p slot=&quot;header&quot;&gt;            &lt;span class=&quot;title&quot;&gt;付款 {{orderInfo.orderNo}}&lt;/span&gt;        &lt;/p&gt;        &lt;div class=&quot;orderInfo&quot;&gt;            &lt;p&gt;订单类型：{{orderInfo.orderType|orderType}}&lt;/p&gt;            &lt;p&gt;订单金额：{{orderInfo.totalAmount|money}}&lt;/p&gt;            &lt;p&gt;优惠金额：{{orderInfo.totalAmount - orderInfo.finalAmount|money}}&lt;/p&gt;            &lt;p&gt;实付金额：                &lt;span&gt;{{orderInfo.finalAmount|money}}&lt;/span&gt;            &lt;/p&gt;            &lt;p&gt;支付方式：                &lt;Select class=&quot;payType&quot; v-model=&quot;orderInfo.payType&quot;&gt;                    &lt;Option value=&quot;CASH&quot;&gt;现金&lt;/Option&gt;                    &lt;Option value=&quot;WECHAT&quot;&gt;微信&lt;/Option&gt;                    &lt;Option value=&quot;ALIPAY&quot;&gt;支付宝&lt;/Option&gt;                &lt;/Select&gt;            &lt;/p&gt;            &lt;p style=&quot;text-align: center&quot; v-if=&quot;orderInfo.payType!=&#39;CASH&#39; &amp;&amp; message!==&#39;&#39;&quot;&gt;{{message}}&lt;/p&gt;            &lt;qr-code-vue v-if=&quot;orderInfo.payType!=&#39;CASH&#39;&amp;&amp;message===&#39;&#39;&amp;&amp;qrCodeValue!==&#39;&#39;&quot; style=&quot;text-align: center;&quot;                         :value=&quot;qrCodeValue&quot; size=&quot;150&quot; level=&quot;H&quot;&gt;&lt;/qr-code-vue&gt;        &lt;/div&gt;        &lt;div class=&quot;footer&quot; slot=&quot;footer&quot;&gt;            &lt;Button type=&quot;ghost&quot; @click=&quot;$emit(&#39;emitCloseDialog&#39;)&quot;&gt;取消&lt;/Button&gt;            &lt;Button class=&quot;submit&quot; v-if=&quot;orderInfo.payType==&#39;CASH&#39;&quot; type=&quot;primary&quot;                    @click=&quot;handleSureOrder&quot;&gt;                确定            &lt;/Button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import {        getQrCode,        sureOrder    } from &#39;../../api/retail&#39;    import QrCodeVue from &#39;qrcode.vue&#39;    export default {        props: [&#39;orderInfo&#39;, &#39;orderShow&#39;],        data() {            return {                message: &#39;&#39;,                qrCodeValue: &#39;&#39;,                spinShow: false            }        },        components: {            QrCodeVue        },        watch: {            &#39;orderInfo.payType&#39;(type) {                this.makeQrCode(type)            },            orderShow(flag) {                if (flag) {                    this.webSocketInit()                } else {                    this.webSocketClose()                }            }        },        methods: {            makeQrCode(type) {                let _this = this                if (type !== &#39;CASH&#39;) {                    _this.spinShow = true                    return new Promise((resolve, reject) =&gt; {                        getQrCode({                            orderId: _this.orderInfo.id,                            payType: type                        }).then(response =&gt; {                            _this.spinShow = false                            if (response.status === 200) {                                _this.qrCodeValue = response.data                                _this.message = &#39;&#39;                            } else {                                _this.message = response.message                            }                            resolve(response)                        }).catch(error =&gt; {                            _this.qrCodeValue = &#39;&#39;                            _this.message = &#39;&#39;                            _this.spinShow = false                            reject(error)                        })                    })                }            },            handleSureOrder() {                let _this = this                _this.spinShow = true                return new Promise((resolve, reject) =&gt; {                    sureOrder({                        orderNo: _this.orderInfo.orderNo,                        id: _this.orderInfo.id,                        payType: _this.orderInfo.payType                    }).then(response =&gt; {                        _this.spinShow = false                        if (response.status &amp;&amp; response.status === 200) {                            _this.$Notice.success({                                title: &#39;付款成功通知&#39;,                                desc: &#39;订单&#39; + _this.orderInfo.orderNo + &#39;付款成功&#39;,                                duration: 3                            })                            _this.$emit(&#39;emitCloseDialog&#39;)                            _this.$store.commit(&#39;RELOAD&#39;)                        } else {                            _this.$Notice.error({                                title: response.message,                                desc: &#39;订单&#39; + _this.orderInfo.orderNo + &#39;付款失败&#39;,                                duration: 3                            })                        }                        resolve(response)                    }).catch(error =&gt; {                        _this.spinShow = false                        reject(error)                    })                })            },            webSocketInit() {                if (&#39;WebSocket&#39; in window) {                    this.websock = new WebSocket(&quot;ws://xxxxxxxxxxxxxxxxxxxx&quot;)                    this.websock.onopen = this.webSocketOnOpen                    this.websock.onmessage = this.webSocketOnMessage                    this.websock.onerror = this.webSocketOnError                    this.websock.onclose = this.webSocketClose                } else {                    alert(&#39;Not support websocket&#39;)                }            },            webSocketOnOpen(event) {                console.log(&#39;websocket open&#39;)            },            webSocketOnMessage(event) {                if (event.data) {                    this.$Notice.success({                        title: &#39;付款成功通知&#39;,                        desc: &#39;订单&#39; + this.orderInfo.orderNo + &#39;付款成功&#39;,                        duration: 3                    })                    this.$emit(&#39;emitCloseDialog&#39;)                    this.$store.commit(&#39;reloadOrder&#39;)                }            },            webSocketOnError(event) {                this.$Message.error(&quot;websocket 连接失败&quot;)            },            webSocketClose(event) {                console.log(&#39;websocket close&#39;)            }        }    }&lt;/script&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;收营员选择收款方式（现金/支付宝/微信），如果是支付宝/微信，服务端会传给前端一个交易码，前端用 &lt;strong&gt;qrcode&lt;/stron
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="qrcode" scheme="http://zc95.github.io/tags/qrcode/"/>
    
      <category term="Websocket" scheme="http://zc95.github.io/tags/Websocket/"/>
    
      <category term="微信支付宝支付" scheme="http://zc95.github.io/tags/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript性能优化之函数去抖（debounce）和函数节流（throttle）</title>
    <link href="http://zc95.github.io/2018/08/16/debounceAndThrottle/"/>
    <id>http://zc95.github.io/2018/08/16/debounceAndThrottle/</id>
    <published>2018-08-16T12:22:03.000Z</published>
    <updated>2018-08-16T12:24:35.251Z</updated>
    
    <content type="html"><![CDATA[<p>以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿或者服务器压力大甚至浏览器崩溃。</p><ol><li>window对象的resize、scroll事件</li><li>拖拽时的mousemove事件</li><li>射击游戏中的mousedown、keydown事件</li><li>文字输入、自动完成的keyup、onchange事件</li></ol><h2 id="函数去抖（debounce）和函数节流（throttle）"><a href="#函数去抖（debounce）和函数节流（throttle）" class="headerlink" title="函数去抖（debounce）和函数节流（throttle）"></a>函数去抖（debounce）和函数节流（throttle）</h2><ol><li><strong>函数去抖 debounce：</strong>如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。也就是说当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。</li><li><strong>函数节流 throttle</strong>：如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</li></ol><h2 id="远程搜索的实际场景"><a href="#远程搜索的实际场景" class="headerlink" title="远程搜索的实际场景"></a>远程搜索的实际场景</h2><p>当我们用 <strong>onkeyup</strong> 或者 <strong>onchange</strong> 事件来监听某个输入框的时候，每按下键盘后弹起都会调用接口来查询数据，所以我们输入一个中文可能需要调用四五次这样子，而事实上我们只需要在停下来的时候查询一次就行，因此这种场景下用函数去抖（debounce）更合适。</p><pre><code class="javascript">getRecently() {    this.debounce(this.getRecentlyFn, 600)},getRecentlyFn() {    let _this = this    return new Promise((resolve, reject) = &gt;{        queryRecently({            cardId: _this.recently        }).then(response = &gt;{            _this.autoInfo = response resolve(response)        }).        catch(error = &gt;{            reject(error)        })    })},debounce(fn, delay) {    clearTimeout(fn.timeid) fn.timeid = setTimeout(function() {        fn()    },    delay)}</code></pre><p>关于另一个函数节流 throttle，目前暂时还没遇到适用的场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿或者服务器压力大甚至浏览器崩溃。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;window对象的resize、scroll事件&lt;/li&gt;
&lt;li&gt;拖拽时的mousemove事件&lt;/li&gt;
&lt;li&gt;射击游戏中
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="性能优化" scheme="http://zc95.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="函数去抖 debounce" scheme="http://zc95.github.io/tags/%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96-debounce/"/>
    
      <category term="函数节流 throttle" scheme="http://zc95.github.io/tags/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81-throttle/"/>
    
  </entry>
  
  <entry>
    <title>美团、支付宝、微信扫码支付</title>
    <link href="http://zc95.github.io/2018/08/10/alipay/"/>
    <id>http://zc95.github.io/2018/08/10/alipay/</id>
    <published>2018-08-10T15:54:01.000Z</published>
    <updated>2018-08-10T15:56:38.302Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fu51nh65fkj30vi0uawgz.jpg" alt=""></p><pre><code class="vue">&lt;template&gt;    &lt;div&gt;        &lt;div class=&quot;orderInfo&quot;&gt;            &lt;p&gt;支付方式：                &lt;Select v-model=&quot;orderInfo.payType&quot;&gt;                    &lt;Option value=&quot;CASH&quot;&gt;现金&lt;/Option&gt;                    &lt;Option value=&quot;WECHAT&quot;&gt;微信&lt;/Option&gt;                    &lt;Option value=&quot;ALIPAY&quot;&gt;支付宝&lt;/Option&gt;                &lt;/Select&gt;            &lt;/p&gt;            &lt;div v-if=&quot;orderInfo.payType!=&#39;CASH&#39;&quot;&gt;                &lt;p v-show=&quot;authCode==&#39;&#39;&quot;&gt;等待扫码&lt;/p&gt;                &lt;p v-show=&quot;authCode!==&#39;&#39;&quot;&gt;正在扫码&lt;/p&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div slot=&quot;footer&quot;&gt;            &lt;Button type=&quot;ghost&quot;&gt;取消&lt;/Button&gt;            &lt;Button v-if=&quot;orderInfo.payType==&#39;CASH&#39;&quot; type=&quot;primary&quot; @click=&quot;handleSureOrder&quot;&gt;                确定            &lt;/Button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        props: [&#39;orderInfo&#39;, &#39;orderShow&#39;],        data() {            return {                spinShow: false,                authCode: &#39;&#39;,            }        },        watch: {            &#39;orderInfo.payType&#39;(type) {                let _this = this;                window.onkeyup = function (e) {                    if (type !== &#39;CASH&#39; &amp;&amp; _this.orderShow) {                        _this.doKeyup(e)                    }                }            },            authCode() {                setTimeout(() =&gt; {                    this.authCode = &#39;&#39;                }, 1200)            }        },        methods: {            doKeyup(e) {                let keyCode = e.keyCode                let keyValue = e.key                if (keyCode &gt;= 48 &amp;&amp; keyCode &lt;= 57) {                    this.authCode += keyValue                } else if (keyCode === 13 &amp;&amp; this.authCode !== &#39;&#39;) {                    this.handleSureOrder()                    this.authCode = &#39;&#39;                }            },            handleSureOrder() {                // ...            }        }    }&lt;/script&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNbRwgy1fu51nh65fkj30vi0uawgz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;vue&quot;&gt;&amp;lt;template&amp;gt;
    &amp;lt;
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="html" scheme="http://zc95.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>如何使用js调用摄像头拍照</title>
    <link href="http://zc95.github.io/2018/07/28/mediaDevices/"/>
    <id>http://zc95.github.io/2018/07/28/mediaDevices/</id>
    <published>2018-07-28T14:55:59.000Z</published>
    <updated>2018-07-28T15:34:19.163Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftpzysab74j30pc0hamzw.jpg" alt="https://ws3.sinaimg.cn/large/006tNc79gy1ftpzysab74j30pc0hamzw.jpg"></p><h2 id="MediaDevices-getUserMedia"><a href="#MediaDevices-getUserMedia" class="headerlink" title="MediaDevices.getUserMedia()"></a>MediaDevices.getUserMedia()</h2><p>MediaDevices.getUserMedia() 会提示用户给予使用媒体输入的许可，媒体输入会产生一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaStream" target="_blank" rel="external"><code>MediaStream</code></a>，里面包含了请求的媒体类型的轨道。此流可以包含一个视频轨道（来自硬件或者虚拟视频源，比如相机、视频采集设备和屏幕共享服务等等）、一个音频轨道（同样来自硬件或虚拟音频源，比如麦克风、A/D转换器等等），也可能是其它轨道类型。</p><p>它返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external"><code>Promise</code></a> 对象，成功后会<code>resolve</code>回调一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaStream" target="_blank" rel="external"><code>MediaStream</code></a> 对象。若用户拒绝了使用权限，或者需要的媒体源不可用，<code>promise</code>会<code>reject</code>回调一个  <code>PermissionDeniedError</code> 或者 <code>NotFoundError</code> 。</p><blockquote><p>返回的promise对象可能既不会resolve也不会reject，因为用户不是必须选择允许或拒绝。 </p></blockquote><p>通常你可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/mediaDevices" target="_blank" rel="external"><code>navigator.mediaDevices</code></a> 来获取 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices" target="_blank" rel="external"><code>MediaDevices</code></a> ，例如： </p><pre><code class="javascript">navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {  /* 使用这个stream stream */}).catch(function(err) {  /* 处理error */});</code></pre><h2 id="关于参数-constraints"><a href="#关于参数-constraints" class="headerlink" title="关于参数 constraints"></a>关于参数 constraints</h2><blockquote><p>同时请求音频和视频</p><p>{ audio: true, video: true }</p><p>使用1280x720的摄像头分辨率</p><p>{ audio: true, video: { width: 1280, height: 720 } }</p><p>在移动设备优先使用前置摄像头 </p><p>{ audio: true, video: { facingMode: “user” } }</p><p>强制使用后置摄像头 </p><p>{ audio: true, video: { facingMode: { exact: “environment” } } }</p></blockquote><h2 id="vue项目实战"><a href="#vue项目实战" class="headerlink" title="vue项目实战"></a>vue项目实战</h2><pre><code class="html">&lt;Modal v-model=&quot;photoDialog&quot;&gt;  &lt;p slot=&quot;header&quot; style=&quot;text-align:left&quot;&gt;    &lt;Icon type=&quot;android-camera&quot;&gt;&lt;/Icon&gt;    &lt;span&gt;打卡&lt;/span&gt;&lt;/p&gt;  &lt;div style=&quot;text-align:center&quot;&gt;    &lt;Spin size=&quot;large&quot; fix v-if=&quot;spinShow&quot;&gt;&lt;/Spin&gt;    &lt;video v-show=&quot;!took&quot; ref=&quot;video&quot; width=&quot;320&quot; height=&quot;240&quot; autoplay&gt;&lt;/video&gt;    &lt;canvas v-show=&quot;took&quot; ref=&quot;canvas&quot; width=&quot;320&quot; height=&quot;240&quot;&gt;&lt;/canvas&gt;  &lt;/div&gt;  &lt;div slot=&quot;footer&quot; style=&quot;text-align: right&quot;&gt;    &lt;span v-if=&quot;!took&quot; @click=&quot;takePhoto&quot; style=&quot;margin: 3px 0; display: inline; margin-left: 10px;&quot;&gt;&lt;Button type=&quot;primary&quot;&gt;拍照&lt;/Button&gt;&lt;/span&gt;    &lt;span v-if=&quot;took&quot; @click=&quot;initCamera&quot; style=&quot;margin: 3px 0; display: inline; margin-left: 10px;&quot;&gt;&lt;Button&gt;重拍&lt;/Button&gt;&lt;/span&gt;    &lt;span v-if=&quot;took&quot; @click=&quot;&quot; style=&quot;margin: 3px 0; display: inline; margin-left: 10px;&quot;&gt;&lt;Button type=&quot;primary&quot;&gt;提交&lt;/Button&gt;&lt;/span&gt;  &lt;/div&gt;&lt;/Modal&gt;</code></pre><pre><code class="javascript">export default {    data() {      return {        photoDialog:        false spinShow:        false,        took: false,        stream: null,        took: false,        attendance: {          content: &#39;&#39;        }      }    },    watch: {        photoDialog(val, oldVal) {            if (!val) {                this.stream.getVideoTracks()[0].stop(); //监听弹窗状态来关闭摄像头            }        },    },    methods: {      ClockIn() {        this.photoDialog = true;        this.initCamera()      },      initCamera() {        let _this = this;        _this.spinShow = true;        _this.took = false;        if (navigator.mediaDevices.getUserMedia) {          navigator.mediaDevices.getUserMedia({            &#39;video&#39;: true          }).then(function(stream) {            _this.stream = stream;            _this.$refs.video.src = window.URL.createObjectURL(stream);            setTimeout(function() {              _this.spinShow = false;            },            800)          }).          catch(function(err) {            console.log(err);          });        }      },      takePhoto() {        var context = this.$refs.canvas.getContext(&#39;2d&#39;);        context.drawImage(this.$refs.video, 0, 0, 320, 240);        this.attendance.content = this.$refs.canvas.toDataURL(&#39;image/jpeg&#39;);        this.stream.getVideoTracks()[0].stop();        this.took = true      },    }  }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1ftpzysab74j30pc0hamzw.jpg&quot; alt=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1ftpzysab74j30pc
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="html" scheme="http://zc95.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>Material Page</title>
    <link href="http://zc95.github.io/2018/06/11/material-page/"/>
    <id>http://zc95.github.io/2018/06/11/material-page/</id>
    <published>2018-06-11T11:55:03.000Z</published>
    <updated>2018-06-11T12:01:19.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Material-Page"><a href="#Material-Page" class="headerlink" title="Material Page"></a>Material Page</h1><blockquote><p>Nature, Pure</p><p>原质，纯粹</p></blockquote><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fs33tk274xj31kw0zkwnc.jpg" alt=""></p><p><code>Material Page</code> 是一个客制化上网首页</p><p>基于 Material Design &amp; vuetifyjs &amp; Vue.js</p><p>集成搜索，网站收藏和分类，TODO</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>demo：<a href="https://zc95.github.io/demo/material-page/index.html">https://zc95.github.io/demo/material-page/index.html</a></p><p>github：<a href="https://github.com/zc95/material-page" target="_blank" rel="external">https://github.com/zc95/material-page</a></p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>搜索：Google + Bing + 百度</li><li>网站：可自定义网站列表</li><li>TODO: 简单的 Todo 列表</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code class="bash"># install dependenciesnpm install# serve with hot reload at localhost:8080npm run dev# build for production with minificationnpm run build</code></pre><p>For a detailed explanation on how things work, check out the <a href="http://vuejs-templates.github.io/webpack/" target="_blank" rel="external">guide</a> and <a href="http://vuejs.github.io/vue-loader" target="_blank" rel="external">docs for vue-loader</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Material-Page&quot;&gt;&lt;a href=&quot;#Material-Page&quot; class=&quot;headerlink&quot; title=&quot;Material Page&quot;&gt;&lt;/a&gt;Material Page&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Nature, Pure&lt;
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="html" scheme="http://zc95.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>如何把你的demo打包成一个app</title>
    <link href="http://zc95.github.io/2018/05/27/package-app/"/>
    <id>http://zc95.github.io/2018/05/27/package-app/</id>
    <published>2018-05-27T06:52:16.000Z</published>
    <updated>2018-05-27T06:57:11.539Z</updated>
    
    <content type="html"><![CDATA[<p>如何将你的html代码打包成一个app？那就是HBuilder，无论是只有一个页面的小demo，还是一个完整的vue项目，都可以变成原生app。</p><h2 id="准备好项目"><a href="#准备好项目" class="headerlink" title="准备好项目"></a>准备好项目</h2><p>新建一个文件夹，里面放入你的文件，我这里以一个页面为例，里面就写了一句页面跳转到博客的js语句。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1frpw12tluuj30q4098q3s.jpg" alt=""></p><p>如果是Vue项目，npm run build之后找到dist文件夹打开就行。</p><h2 id="下载HBuilder"><a href="#下载HBuilder" class="headerlink" title="下载HBuilder"></a>下载HBuilder</h2><p>进入 <a href="http://www.dcloud.io/" target="_blank" rel="external">官网</a> 下载就行</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1frpvthekeij31kw0yntjp.jpg" alt=""></p><h2 id="打开目录"><a href="#打开目录" class="headerlink" title="打开目录"></a>打开目录</h2><p>点击 <code>文件/打开目录…</code> 选择你刚刚的项目。</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1frpw550z5dj30t60go0u9.jpg" alt=""></p><h2 id="转换成移动app"><a href="#转换成移动app" class="headerlink" title="转换成移动app"></a>转换成移动app</h2><p>右击刚刚打开的项目选择 <code>转换成移动app</code> ，此时，项目前的W图标变成了A，然后文件夹里就多了一个manifest文件，我们可以在这里配置app的名字、图标、载入动画、入口页面、是否全屏或者一些更高的权限（摄像头，阿里支付等）</p><p>注意上传图标的时候，尽量选择1024 <em> 1024的图标，如果是ios则必须1024 </em> 1024，然后点击<strong>自动生成所有图标并替换</strong></p><h2 id="开始打包"><a href="#开始打包" class="headerlink" title="开始打包"></a>开始打包</h2><p>选择 <code>发行/云打包-打原生安装包</code> ，然后按提示操作就行。</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1frpwdrizdwj31dk0deaec.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如何将你的html代码打包成一个app？那就是HBuilder，无论是只有一个页面的小demo，还是一个完整的vue项目，都可以变成原生app。&lt;/p&gt;
&lt;h2 id=&quot;准备好项目&quot;&gt;&lt;a href=&quot;#准备好项目&quot; class=&quot;headerlink&quot; title=&quot;准备
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="app" scheme="http://zc95.github.io/tags/app/"/>
    
  </entry>
  
  <entry>
    <title>本地开启的localhost服务器如何在移动设备访问</title>
    <link href="http://zc95.github.io/2018/05/26/mobilewatchlocalhost/"/>
    <id>http://zc95.github.io/2018/05/26/mobilewatchlocalhost/</id>
    <published>2018-05-26T03:36:42.000Z</published>
    <updated>2018-06-05T13:25:17.981Z</updated>
    
    <content type="html"><![CDATA[<p>当vue-cli为我们开启了一个本地服务器如：<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a>，我们该怎么在手机或平板上查看呢。</p><p>1.找到 <code>config/index.js</code> ，将红色方框内原来的localhost改成0.0.0.0，表示底层的TCP bind IP结构体被置为全0，就允许监听本机全部网卡。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1frokw2zi7aj30oi08mmyq.jpg" alt=""></p><p>2.新建命令 ifconfig（Windows用户是ipconfig），找到本机ip地址</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1frol1xh200j30iy0dawgk.jpg" alt=""></p><p>3.打开浏览器把localhost换成刚刚的ip <a href="http://192.168.2.238:8080" target="_blank" rel="external">http://192.168.2.238:8080</a>，发现仍然可以访问</p><p>4.打开草料二维码粘贴生成二维码，手机微信扫一扫就好啦</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1frol5bjp2zj31kw0t8tdi.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当vue-cli为我们开启了一个本地服务器如：&lt;a href=&quot;http://localhost:8080&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:8080&lt;/a&gt;，我们该怎么在手机或平板上查看呢。&lt;/p&gt;
&lt;p&gt;1
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="localhost" scheme="http://zc95.github.io/tags/localhost/"/>
    
      <category term="ifconfig" scheme="http://zc95.github.io/tags/ifconfig/"/>
    
  </entry>
  
  <entry>
    <title>我的第一个vue项目[饿了么app]</title>
    <link href="http://zc95.github.io/2018/05/25/vue-sell/"/>
    <id>http://zc95.github.io/2018/05/25/vue-sell/</id>
    <published>2018-05-25T14:00:24.000Z</published>
    <updated>2018-06-06T16:26:49.281Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个饿了么外卖app开发笔记，记录我的第一个vue项目的开发过程。</p><p>暂时还没做完就不上图了。。。</p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p>github地址：<a href="https://github.com/zc95/vue-sell" target="_blank" rel="external">https://github.com/zc95/vue-sell</a></p><p>手机预览：<a href="https://zc95.github.io/demo/vue-sell/">https://zc95.github.io/demo/vue-sell/</a></p><p>二维码：<img width="100" src="https://ws2.sinaimg.cn/large/006tKfTcgy1frppuj5pfvj307s07sq2p.jpg"></p><h2 id="vue-cli脚手架-搭建基本代码框架"><a href="#vue-cli脚手架-搭建基本代码框架" class="headerlink" title="vue-cli脚手架 搭建基本代码框架"></a>vue-cli脚手架 搭建基本代码框架</h2><blockquote><p>全局安装vue-cli</p><p>$ npm install hexo-cli -g</p><p>创建一个基于webpack模版的新项目，基本配置看下图</p><p>$ vue init webpack vue-sell</p><p>安装依赖，开启localhost本地服务器</p><p>$ cd vue-sell</p><p>$ npm run dev</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1frnx9rccizj30iy0doq4i.jpg" alt=""></p><h2 id="引入准备好的字体图标"><a href="#引入准备好的字体图标" class="headerlink" title="引入准备好的字体图标"></a>引入准备好的字体图标</h2><p>慕课准备好了图标，这一步就省略了，可以去 <a href="https://icomoon.io/app/#/select" target="_blank" rel="external">icomoon.io</a> 自己打包图标</p><h2 id="mock数据（模拟后台数据）"><a href="#mock数据（模拟后台数据）" class="headerlink" title="mock数据（模拟后台数据）"></a>mock数据（模拟后台数据）</h2><p>1.将准备好的 <code>data.json</code> 模拟数据文件放到根目录下</p><p>2.打开<code>build/webpack.dev.conf.js</code> 文件编写数据接口</p><pre><code class="javascript">const appData = require(&#39;../data.json&#39;)const seller = appData.sellerconst goods = appData.goodsconst ratings = appData.ratingsbefore(app) {      app.get(&#39;/api/seller&#39;, function (req, res) {        res.json({          errno: 0,          data: seller        })      });      app.get(&#39;/api/goods&#39;, function (req, res) {        res.json({          errno: 0,          data: goods        })      });      app.get(&#39;/api/ratings&#39;, function (req, res) {        res.json({          errno: 0,          data: ratings        })      });    }</code></pre><p>3.浏览器中打开 <a href="http://localhost:8080/api/seller" target="_blank" rel="external">http://localhost:8080/api/seller</a> 查看数据是否能正常访问，我们可以安装谷歌插件 <code>JSONView</code> 让数据格式化，然后依次查看goods ratings数据是否正常。</p><h2 id="重置css样式"><a href="#重置css样式" class="headerlink" title="重置css样式"></a>重置css样式</h2><p>引入reset.css即可</p><h2 id="CSS预处理器-stylus-的安装"><a href="#CSS预处理器-stylus-的安装" class="headerlink" title="CSS预处理器 stylus 的安装"></a>CSS预处理器 stylus 的安装</h2><p>1.在 <code>package.json</code> 文件中写入依赖</p><blockquote><p>“stylus”: “^0.54.5”,</p><p>“stylus-loader”: “^3.0.1”,</p></blockquote><p>然后安装依赖，mac用户需要加sudo，win不需要</p><blockquote><p>sudo npm install</p><p>npm run dev</p></blockquote><h2 id="头部组件的命名问题"><a href="#头部组件的命名问题" class="headerlink" title="头部组件的命名问题"></a>头部组件的命名问题</h2><p>因为 header 是html5的一个原生的标签，组件名字和它有冲突。</p><pre><code class="javascript">[Vue warn]: Do not use built-in or reserved HTML elements as component id: header</code></pre><p>修改后：</p><pre><code class="html">&lt;v-header&gt;&lt;/v-header&gt;&lt;script&gt;import header from &#39;./components/header/header.vue&#39;export default {  components:{    &#39;v-header&#39;:header  }}&lt;/script&gt;</code></pre><h2 id="ESLint规范"><a href="#ESLint规范" class="headerlink" title="ESLint规范"></a>ESLint规范</h2><p>ESLint是一种代码检测工具，空格、分号各种报错。。。当然我们可以在配置里面注释它，但是有良好的代码习惯还是很重要的，一个个解决吧～</p><blockquote><p>Missing space before value for key ‘v-header’ </p><p>‘v-header’:header</p><p>缺少空格，改：</p><p>‘v-header’: header</p><p>Extra semicolon</p><p>有无用的分号，删掉</p></blockquote><p>好麻烦，还是直接在 <code>build/webpack.base.conf.js</code> 禁止检测吧</p><blockquote><p>//…(config.dev.useEslint ? [createLintingRule()] : []),</p></blockquote><p>重启服务器，世界都清净了。。。</p><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p><strong>App.vue</strong></p><pre><code class="vue">&lt;template&gt;  &lt;div&gt;    &lt;v-header :seller=&quot;seller&quot;&gt;&lt;/v-header&gt;    &lt;div class=&quot;tab border-1px&quot;&gt;      &lt;div class=&quot;tab-item&quot;&gt;        &lt;router-link to=&quot;/goods&quot;&gt;商品&lt;/router-link&gt;      &lt;/div&gt;      &lt;div class=&quot;tab-item&quot;&gt;        &lt;router-link to=&quot;/ratings&quot;&gt;评论&lt;/router-link&gt;      &lt;/div&gt;      &lt;div class=&quot;tab-item&quot;&gt;        &lt;router-link to=&quot;/seller&quot;&gt;商家&lt;/router-link&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;keep-alive&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p><strong>components/router/index.js</strong></p><pre><code class="javascript">import Vue from &#39;vue&#39;;import Router from &#39;vue-router&#39;;import goods from &#39;components/goods/goods&#39;;import ratings from &#39;components/ratings/ratings&#39;;import seller from &#39;components/seller/seller&#39;;Vue.use(Router);const routes = [{  path: &#39;/&#39;,  redirect: &#39;/goods&#39;}, {  path: &#39;/goods&#39;,  component: goods}, {  path: &#39;/ratings&#39;,  component: ratings}, {  path: &#39;/seller&#39;,  component: seller}];export default new Router({    linkActiveClass: &#39;active&#39;,    routes});</code></pre><h2 id="本地开启的服务如果在手机上调试"><a href="#本地开启的服务如果在手机上调试" class="headerlink" title="本地开启的服务如果在手机上调试"></a>本地开启的服务如果在手机上调试</h2><p>可以看我的另外一篇文章：<a href="https://zc95.github.io/2018/05/26/mobilewatchlocalhost/">https://zc95.github.io/2018/05/26/mobilewatchlocalhost/</a></p><h2 id="路径优化之resolve"><a href="#路径优化之resolve" class="headerlink" title="路径优化之resolve"></a>路径优化之resolve</h2><p><strong>resolve.extensions</strong></p><p>在webpack.base.conf.js中，我们可以看到resolve配置，其中的extengsions是一个数组，如下所示：</p><pre><code class="javascript">extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;],</code></pre><p>通过这样的配置，我们在组件中过着路由中应用组件时，就可以更为方便的应用，比如：</p><pre><code class="javascript">import header from &quot;components/header/header&quot;;</code></pre><p>即header.vue这个组件我们不需要添加.vue后缀就可以引用到了</p><p><strong>resolve.alias</strong></p><p>我们引入组件的时候路径是相对于当前页面的。 但是如果嵌套等更为复杂，那么写起来会比较麻烦。但是如果我们通过这样的配置：</p><pre><code class="javascript">alias: {      &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39;,      &#39;@&#39;: resolve(&#39;src&#39;),      &#39;src&#39;: path.resolve(__dirname, &#39;../src&#39;),      &#39;common&#39;: path.resolve(__dirname, &#39;../src/common&#39;),      &#39;components&#39;: path.resolve(__dirname, &#39;../src/components&#39;)    }</code></pre><p>这样我们引入组件的时候就不用考虑路径的问题，直接从 src common components 这几层往下找就行</p><h2 id="npm-run-build-打包之后的项目打开后一片空白？"><a href="#npm-run-build-打包之后的项目打开后一片空白？" class="headerlink" title="npm run build 打包之后的项目打开后一片空白？"></a>npm run build 打包之后的项目打开后一片空白？</h2><p>npm run build之后打开 <code>dist/index.html</code> 文件，发现一片空白。这是因为打包配置的路径有问题，我们找到 <code>config/ndex.js</code> 这个文件的 <code>build</code> 部分将 <code>assetsPublicPath</code> 的空值改为 <code>./</code></p><pre><code class="javascript">// Paths    assetsRoot: path.resolve(__dirname, &#39;../dist&#39;),    assetsSubDirectory: &#39;static&#39;,    assetsPublicPath: &#39;./&#39;,</code></pre><p>再次打包，ok了</p><h2 id="npm-run-build-打包之后的项目访问不到数据？"><a href="#npm-run-build-打包之后的项目访问不到数据？" class="headerlink" title="npm run build 打包之后的项目访问不到数据？"></a>npm run build 打包之后的项目访问不到数据？</h2><p>我们的数据都是mock的假数据，是存在根目录下的data.json文件，再通过模拟接口调用数据，打包的时候并不会打包这些。</p><p>通过判断是开发环境还是生产环境来解决：</p><pre><code class="javascript">const ERR_OK = 0;const debug = process.env.NODE_ENV !== &#39;production&#39;;export default {  ...,created() {    const url = debug ? &#39;/api/seller&#39; : &#39;https://zc95.github.io/demo/vue-sell/api/seller.json&#39;;    this.$http.get(url + &#39;?id=&#39; + this.seller.id).then((response) =&gt; {      response = response.body;      if(response.errno===ERR_OK){        this.seller = response.data;      }    });  },  ...}</code></pre><h2 id="CSS-Sticky-footer布局"><a href="#CSS-Sticky-footer布局" class="headerlink" title="CSS Sticky footer布局"></a>CSS Sticky footer布局</h2><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1frppm47qg0j318g0xcaq1.jpg" alt=""></p><pre><code class="html">&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;content-wrapper&gt;       &lt;div class=&quot;content&quot;&gt;内容区域，可随机长度&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;close&quot;&gt;&lt;div&gt;&lt;div class =&quot;close&quot;&gt;关闭图标&lt;/div&gt;始终再底部.</code></pre><pre><code class="css">.container{//总容器为全屏，所以高度为100％  positon: fiexd;  top:0;  left:0;  height:100%;  overflow: auto;//如果内容太长，会显示滚动条查看其余内容。 }.content-wrapper{  min-height: 100%;//如果内容不够长时，也保证内容有全屏长度}.content{  margin-top: 50px;//向上和屏幕顶部保持50px间距  padding-bottom: 50px;//保证内容content区域的底部有50px的空白}.close{   margin: -64px;//让关闭按钮向content－wrapper里面伸入50px，正好把内容区的50px空白补上；}</code></pre><h2 id="Vue路由切换时的左滑和右滑效果"><a href="#Vue路由切换时的左滑和右滑效果" class="headerlink" title="Vue路由切换时的左滑和右滑效果"></a>Vue路由切换时的左滑和右滑效果</h2><p><strong>CSS部分</strong></p><p>我们要实现的是左右切换的效果，所以要定义两种动画（左滑和右滑）</p><pre><code class="css">.transitionBody{  transition: all 0.15s ease; /*定义动画的时间和过渡效果*/}.transitionLeft-enter,.transitionRight-leave-active {    -webkit-transform: translate(100%, 0);    transform: translate(100%, 0);        /*当左滑进入右滑进入过渡动画*/}.transitionLeft-leave-active,.transitionRight-enter {    -webkit-transform: translate(-100%, 0);      transform: translate(-100%, 0);  }</code></pre><p><strong>HTML部分</strong></p><p>这里的 <code>keep-alive</code> 是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM，我们要把它也包裹在transition标签内，否则页面将重新渲染，切换的动画也会卡顿</p><pre><code class="html">&lt;transition :name=&quot;transitionName&quot;&gt;    &lt;keep-alive&gt;            &lt;router-view class=&quot;transitionBody&quot;&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;&lt;/transition&gt;</code></pre><p><strong>JS部分</strong></p><p>在Vue组件中，data必须是一个函数，将对象 {transitionName: ‘transitionLeft’} 挂载到Vue实例中，然后我们可以监听路由的 <code>to</code> 和 <code>from</code> 来判断此时应该左滑还是右滑，来动态切换transition的name值。</p><pre><code class="javascript">export default {  data() {      return {        transitionName: &#39;transitionLeft&#39;      };  },  watch: {      &#39;$route&#39; (to, from) {        const arr = [&#39;/goods&#39;,&#39;/ratings&#39;,&#39;/seller&#39;];      const compare = arr.indexOf(to.path)&gt;arr.indexOf(from.path);      this.transitionName = compare ? &#39;transitionLeft&#39; : &#39;transitionRight&#39;;    }    }    }</code></pre><h2 id="解决vue的变量在setTimeout内部效果失效方法"><a href="#解决vue的变量在setTimeout内部效果失效方法" class="headerlink" title="解决vue的变量在setTimeout内部效果失效方法"></a>解决vue的变量在setTimeout内部效果失效方法</h2><p>定义一个self暂存this就行啦</p><pre><code class="javascript">var self=this; this.progressShow=true;setTimeout(function(){    self.progressShow=false},3000);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个饿了么外卖app开发笔记，记录我的第一个vue项目的开发过程。&lt;/p&gt;
&lt;p&gt;暂时还没做完就不上图了。。。&lt;/p&gt;
&lt;h2 id=&quot;Link&quot;&gt;&lt;a href=&quot;#Link&quot; class=&quot;headerlink&quot; title=&quot;Link&quot;&gt;&lt;/a&gt;Link&lt;/h2&gt;
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="webpack" scheme="http://zc95.github.io/tags/webpack/"/>
    
      <category term="Vue" scheme="http://zc95.github.io/tags/Vue/"/>
    
      <category term="mock模拟数据" scheme="http://zc95.github.io/tags/mock%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE/"/>
    
      <category term="vue-cli" scheme="http://zc95.github.io/tags/vue-cli/"/>
    
      <category term="饿了么vue项目" scheme="http://zc95.github.io/tags/%E9%A5%BF%E4%BA%86%E4%B9%88vue%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>vue-todo</title>
    <link href="http://zc95.github.io/2018/04/27/vue-todo/"/>
    <id>http://zc95.github.io/2018/04/27/vue-todo/</id>
    <published>2018-04-26T16:12:01.000Z</published>
    <updated>2018-05-21T15:38:25.650Z</updated>
    
    <content type="html"><![CDATA[<p>这几天看了点vue，感觉很棒，把之前的todo翻出来用vue写了一下，瞬间少了三分之二的代码😂</p><h2 id="demo-amp-源码"><a href="#demo-amp-源码" class="headerlink" title="demo &amp; 源码"></a>demo &amp; 源码</h2><p>demo：<a href="https://zc95.github.io/demo/vue-todo">https://zc95.github.io/demo/vue-todo</a></p><p>github：<a href="https://github.com/zc95/ToDo/blob/master/vue-todo.html" target="_blank" rel="external">https://github.com/zc95/ToDo/blob/master/vue-todo.html</a></p><p>扫描二维码，在移动设备上查看：<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqqisjlidij307s07sq2p.jpg" alt=""></p><h2 id="demo对比（前面是vue写的）："><a href="#demo对比（前面是vue写的）：" class="headerlink" title="demo对比（前面是vue写的）："></a>demo对比（前面是vue写的）：</h2><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqqicqtlihj31bw18ugr0.jpg" alt=""></p><h2 id="代码量对比"><a href="#代码量对比" class="headerlink" title="代码量对比"></a>代码量对比</h2><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqqifc1djgj31kw0xg4k3.jpg" alt=""></p><h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><pre><code class="css">let todoStorage = {      save: function (todos) {        localStorage.setItem(&#39;vueTodoStorage&#39;, JSON.stringify(todos))      }    }    let app = new Vue({      el: &#39;#app&#39;,      data: {        todos: localStorage.vueTodoStorage ? JSON.parse(localStorage.vueTodoStorage) : [],        inputValue: &quot;&quot;      },      watch: {        todos: {          handler: function (items) {            todoStorage.save(items);          },          deep: true        }      },      methods: {        add() {          mdui.prompt(&#39;add a todo&#39;,            function (value) {              if(value.trim()==&quot;&quot;){                mdui.snackbar({ message: &quot;Can&#39;t be empty!&quot; });                return false;              }              app.todos.push({ text: value, completed: false });              mdui.snackbar({ message: &#39;A todo has been added.&#39; });            }          );        },        removeTodo(index) {          this.todos.splice(index, 1);          mdui.snackbar({ message: &#39;A todo has been removed.&#39; });        },        deleteAll() {          mdui.confirm(&#39;Are you sure you remove all todo?&#39;, function () {            app.todos = [];            mdui.snackbar({ message: &#39;All todo have been removed.&#39; });          });        },        resetAll() {          mdui.confirm(&#39;Are you sure you reset all todo?&#39;, function () {            app.todos.forEach(element =&gt; {              element.completed = false;            });            mdui.snackbar({ message: &#39;All todo have been reset.&#39; });          });        }      }    })</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天看了点vue，感觉很棒，把之前的todo翻出来用vue写了一下，瞬间少了三分之二的代码😂&lt;/p&gt;
&lt;h2 id=&quot;demo-amp-源码&quot;&gt;&lt;a href=&quot;#demo-amp-源码&quot; class=&quot;headerlink&quot; title=&quot;demo &amp;amp; 源码&quot;
      
    
    </summary>
    
      <category term="demo" scheme="http://zc95.github.io/categories/demo/"/>
    
    
      <category term="material design" scheme="http://zc95.github.io/tags/material-design/"/>
    
      <category term="Vue" scheme="http://zc95.github.io/tags/Vue/"/>
    
      <category term="todo" scheme="http://zc95.github.io/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>vue-devtools的安装</title>
    <link href="http://zc95.github.io/2018/04/22/vue-devtools/"/>
    <id>http://zc95.github.io/2018/04/22/vue-devtools/</id>
    <published>2018-04-21T17:22:45.000Z</published>
    <updated>2018-04-21T17:25:53.079Z</updated>
    
    <content type="html"><![CDATA[<p>vue-devtools 是一款基于chrome游览器的插件，用于调试vue应用，由于国内不能访问谷歌商店（要科学上网），所以安装比较麻烦，写个博客记录一下。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>将vue-devtools clone到本地</p><pre><code class="bash">git clone https://github.com/vuejs/vue-devtools.git</code></pre><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>在vue-devtools目录下安装依赖包</p><pre><code class="shell">cd vue-devtoolsnpm install</code></pre><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>编译代码</p><pre><code class="bash">npm run build</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqksckz0bfj30vo0kcjvu.jpg" alt=""></p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>修改 <code>vue-devtools/shells/chrome/manifest.json</code> 文件，将 persistent改成 <code>true</code></p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqkqczgwjdj30zi0g4di1.jpg" alt=""></p><h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><h3 id="打开chrome，输入-chrome-extensions-进入到chrome扩展程序设置页面"><a href="#打开chrome，输入-chrome-extensions-进入到chrome扩展程序设置页面" class="headerlink" title="打开chrome，输入 chrome://extensions/ 进入到chrome扩展程序设置页面"></a>打开chrome，输入 <code>chrome://extensions/</code> 进入到chrome扩展程序设置页面</h3><p>打开右上角的 <code>开发者模式</code> </p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqkqim3oz3j30b2058aa4.jpg" alt=""></p><h3 id="点击-加载已解压的扩展程序-选择-vue-devtools-shells-chrome"><a href="#点击-加载已解压的扩展程序-选择-vue-devtools-shells-chrome" class="headerlink" title="点击 加载已解压的扩展程序 选择 vue-devtools/shells/chrome"></a>点击 <code>加载已解压的扩展程序</code> 选择 <code>vue-devtools/shells/chrome</code></h3><p>   <img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqkqmn6rp0j31480owdlm.jpg" alt=""></p><h3 id="注意：勾选-允许访问文件网址"><a href="#注意：勾选-允许访问文件网址" class="headerlink" title="注意：勾选 允许访问文件网址"></a>注意：勾选 <code>允许访问文件网址</code></h3><p>   <img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqks8mz3qxj318u05i0t0.jpg" alt=""></p><p>至此，vue-devtools已经安装完毕。enjoy it!</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqksb2n8lkj31kw115n6r.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vue-devtools 是一款基于chrome游览器的插件，用于调试vue应用，由于国内不能访问谷歌商店（要科学上网），所以安装比较麻烦，写个博客记录一下。&lt;/p&gt;
&lt;h2 id=&quot;第一步&quot;&gt;&lt;a href=&quot;#第一步&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="Vue" scheme="http://zc95.github.io/tags/Vue/"/>
    
      <category term="vue-devtools" scheme="http://zc95.github.io/tags/vue-devtools/"/>
    
  </entry>
  
  <entry>
    <title>js的函数重载</title>
    <link href="http://zc95.github.io/2018/04/15/overloading/"/>
    <id>http://zc95.github.io/2018/04/15/overloading/</id>
    <published>2018-04-15T15:17:48.000Z</published>
    <updated>2018-04-16T12:52:48.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h2><p>函数重载，简单说，就是函数有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。</p><p>所以说，重载函数需要两点：同样的函数名，不同的函数参数。</p><h2 id="js到底有没有函数重载"><a href="#js到底有没有函数重载" class="headerlink" title="js到底有没有函数重载"></a>js到底有没有函数重载</h2><p>如果在我们在一个页面中定义了两个名字相同的函数，则该名字只属于后定义的函数，如下：</p><pre><code class="javascript">function add(num){    return num+1;}function add(num){    return num+2;}add(4);  //结果为6</code></pre><p>在上面的例子中，add()函数被定义了两次，然而，当我们调用他的时候，却直接调用了第二个函数，这说明在JavaScript中，后定义的函数会覆盖先定义的函数。</p><p>其实，在java或者.net中都是是存在重载的，那么js中呢？可以肯定的说，js中是不存在重载的，但是我们可以通过其他的方式来模拟重载。</p><h2 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h2><p>当我们在js中在调用一个函数的时候，我们经常会给这个函数传递一些参数，js把传入到这个函数的全部参数存储在一个叫做arguments的东西里面，<code>arguments</code>对象不是一个<code>Array</code> 。它类似于<code>Array</code>，可以使用[i]或者.length，为了代码的严谨度，我们可以用arguments的length属性来判断当前传入参数的个数是否与我们需要的数量一致。</p><pre><code class="javascript">function add(num1, num2){    // 根据arguments.length，对不同的值进行不同的操作　　switch(arguments.length) {　　　　case 0:　　　　　　/*没有传入任何参数时*/　　　　　　break;　　　　case 1:　　　　　　/*传入一个参数时*/　　　　　　break;　　　　case 2:　　　　　　/*传入两个参数时*/             break;      /*case N.....*/}}</code></pre><p>通过这个例子，我们可以看出，通过检查传入函数中参数的数量，JavaScript函数可以做出不同的反应，这可以间接达到重载的目的。</p><p>所以，JavaScript是可以模仿函数的重载的。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="arguments-类数组对象转为真正的数组"><a href="#arguments-类数组对象转为真正的数组" class="headerlink" title="arguments 类数组对象转为真正的数组"></a>arguments 类数组对象转为真正的数组</h3><pre><code>Array.prototype.slice.apply(arguments);Array.from(arguments);[...arguments];</code></pre><h3 id="callee"><a href="#callee" class="headerlink" title="callee"></a>callee</h3><p><code>arguments.callee</code> 属性包含当前正在执行的函数。<strong>callee</strong> 是 <code>arguments</code> 对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。这在函数的名称是未知时很有用，例如在没有名称的函数表达式（也称为匿名函数）内。</p><p>以一个求阶乘的方法为例：</p><pre><code class="javascript">function fact(n) { if (n &lt; 2) {  return n; } else {  return n * fact(n - 1); }}console.log(fact(5)); //5*4*3*2=120</code></pre><p>匿名函数中：</p><pre><code class="javascript">(function (n) { if (n &lt; 2) {  return n; } else {  return n * arguments.callee(n - 1); }})(5);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数的重载&quot;&gt;&lt;a href=&quot;#函数的重载&quot; class=&quot;headerlink&quot; title=&quot;函数的重载&quot;&gt;&lt;/a&gt;函数的重载&lt;/h2&gt;&lt;p&gt;函数重载，简单说，就是函数有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="javascript" scheme="http://zc95.github.io/tags/javascript/"/>
    
      <category term="函数重载" scheme="http://zc95.github.io/tags/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    
      <category term="arguments对象" scheme="http://zc95.github.io/tags/arguments%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Node.js构建TCP服务器和TCP客户端</title>
    <link href="http://zc95.github.io/2018/03/20/nodejs-TCP/"/>
    <id>http://zc95.github.io/2018/03/20/nodejs-TCP/</id>
    <published>2018-03-20T13:56:12.000Z</published>
    <updated>2018-04-15T15:19:58.967Z</updated>
    
    <content type="html"><![CDATA[<p>网络是通信互联网的基础，Node.js提供了net、http、dgram模块、分别用来实现TCP、HTTP、UDP的通信。上次的文章<a href="https://zc95.github.io/2018/03/19/nodejs-HTTP/">《Node.js构建HTTP服务器》</a>实现了HTTP的通信，这篇文章说一说TCP服务器和TCP客户端的构建。</p><h2 id="用Node-js创建TCP服务器"><a href="#用Node-js创建TCP服务器" class="headerlink" title="用Node.js创建TCP服务器"></a>用Node.js创建TCP服务器</h2><h3 id="构建TCP服务器"><a href="#构建TCP服务器" class="headerlink" title="构建TCP服务器"></a>构建TCP服务器</h3><p>为了使用Node.js创建TCP服务器，首先要使用require(“net”)来加载net模块，然后使用net模块的createServer方法就可以轻松地创建一个TCP服务器。</p><pre><code class="javascript">/** * 构建TCP客户端 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP服务器 */var server = net.createServer(function(socket){    console.log(&#39;someone connects&#39;);})/* 设置连接的服务器 */server.listen(8000, function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>运行这段代码并访问了<a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a>的话会看到控制台打印了”someone connects”，表明已经成功连接到这个创建的TCP服务器。</p><hr><blockquote><p>/<em> 设置连接的服务器 </em>/<br>server.listen(8000, function(){<br>​    console.log(“Creat server on <a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a>“);<br>})</p></blockquote><p>上面这段代码实际上触发的是server下的listening事件，等同于：</p><blockquote><p>/<em> 设置监听端口 </em>/</p><p>server.listen(8000);</p><p>/<em> 设置监听时的回调函数 </em>/</p><p>server.on(“listening”, function () {</p><p>​    console.log(“Creat server on <a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a>“);</p><p>})</p></blockquote><p>事实上，除了listening事件外，TCP服务器还支持以下事件：</p><ol><li>connection：当有新的连接创建时触发，回调函数的参数为socket连接对象。</li><li>close：TCP服务器关闭的时候触发，回调函数没有参数</li><li>error：TCP服务器发生错误的时候触发，回调函数的参数为error对象</li></ol><p>下列代码通过net.Server类来创建一个TCP服务器，并添加以上事件。</p><pre><code class="javascript"> /** * 通过net.Server类来创建一个TCP服务器 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 实例化一个服务器对象 */var server = new net.Server();/* 监听 connection 事件 */server.on(&quot;connection&quot;, function (socket) {    console.log(&quot;someone connects&quot;);});/* 设置监听端口 */server.listen(8000);/* 设置监听时的回调函数 */server.on(&quot;listening&quot;, function () {    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})/* 设置关闭时的回调函数 */server.on(&quot;close&quot;, function () {    console.log(&quot;server closed!&quot;);})/* 设置错误时的回调函数 */server.on(&quot;error&quot;, function (err) {    console.log(&quot;error!&quot;);})</code></pre><h3 id="查看服务器监听的地址"><a href="#查看服务器监听的地址" class="headerlink" title="查看服务器监听的地址"></a>查看服务器监听的地址</h3><p>当创建了一个TCP服务器后，可以通过server.address()方法来查看这个TCP服务器监听的地址，并返回一个JSON对象。这个对象的属性有：</p><ol><li>port：TCP服务器监听的端口号</li><li>family：说明TCP服务器监听的地址是 IPv6 还是 IPv4</li><li>address：TCP服务器监听的地址</li></ol><pre><code class="javascript">/** * 查看服务器监听的地址 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP服务器 */var server = net.createServer(function(socket){    console.log(&#39;someone connects&#39;);})/* 获取地址信息 */server.listen(8000,function(){    /* 获取地址信息，得到的是一个json { address: &#39;::&#39;, family: &#39;IPv6&#39;, port: 8000 } */    var address = server.address();    /* TCP服务器监听的端口号 */    console.log(&quot;the port of server is&quot;+ address.port);    /* TCP服务器监听的地址 */    console.log(&quot;the address of server is&quot;+ address.address);    /* 说明TCP服务器监听的地址是 IPv6 还是 IPv4 */    console.log(&quot;the family of server is&quot;+ address.family);})</code></pre><h3 id="连接服务器的客户端数量"><a href="#连接服务器的客户端数量" class="headerlink" title="连接服务器的客户端数量"></a>连接服务器的客户端数量</h3><p>创建一个TCP服务器后，可以通过server.getConnections()方法获取连接这个TCP服务器的客户端数量。除此之外，也可以通过maxConnections属性来设置这个服务器的最大连接数量，当连接数量超过最大值时，服务器将拒绝新的连接。</p><pre><code class="javascript">/** * 连接服务器的客户端数量 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP服务器 */var server = net.createServer(function(socket){    console.log(&#39;someone connects&#39;);    /* 设置最大连接数量 */    server.maxConnections=3;    server.getConnections(function(err,count){        console.log(&quot;the count of client is &quot;+count);    })})/* 获取监听端口 */server.listen(8000,function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>你可以打开多个网页输入localhost:8000来测试这段代码，也可以用Telnet命令 <code>telnet localhost 8000</code> 来连接这个TCP服务器（上一篇文章有提到如何用Homebrew安装Telnet：<a href="https://zc95.github.io/2018/03/20/Homebrew/">《Homebrew》</a>）。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fpkqytum6zj31kw0s7toa.jpg" alt=""></p><h3 id="服务器和客户端之间的通信"><a href="#服务器和客户端之间的通信" class="headerlink" title="服务器和客户端之间的通信"></a>服务器和客户端之间的通信</h3><p>利用socket.write()可以使TCP服务器发送数据给客户端；</p><p>socket对象可以用来获取客户端发出的流数据，每次接收到数据的时候触发data事件，通过监听这个事件就可以在回调函数中获取客户端发送的数据了。</p><pre><code class="javascript">/** * 发送和获取 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP服务器 */var server = net.createServer(function(socket){    /* 获取地址信息 */    var address = server.address();    var message = &quot;the server address is&quot;+JSON.stringify(address);    /* 发送数据 */    socket.write(message,function(){        var writeSize = socket.bytesWritten;        console.log(message + &quot;has send&quot;);        console.log(&quot;the size of message is&quot;+writeSize);    })    /* 监听data事件 */    socket.on(&#39;data&#39;,function(data){        console.log(data.toString());        var readSize = socket.bytesRead;        console.log(&quot;the size of data is&quot;+readSize);    })})/* 获取地址信息 */server.listen(8000,function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>下图中TCP服务器给客户端发送了字符串：</p><blockquote><p>the server address is{“address”:”::”,”family”:”IPv6”,”port”:8000}has send</p></blockquote><p>客户端给TCP服务器发送了字符串 <code>hello TCP!</code> 和字节数。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fpkr5446asj31kw0p5gvz.jpg" alt=""></p><h2 id="用Node-js创建TCP客户端"><a href="#用Node-js创建TCP客户端" class="headerlink" title="用Node.js创建TCP客户端"></a>用Node.js创建TCP客户端</h2><h3 id="构建TCP客户端"><a href="#构建TCP客户端" class="headerlink" title="构建TCP客户端"></a>构建TCP客户端</h3><p>上面说到用打开网页或者Telnet来访问TCP服务器，其实我们也可以用Node.js来构建一个TCP客户端，实现TCP客户端和TCP服务器的通信。</p><p>为了使用Node.js创建TCP客户端，首先要使用require(“net”)来加载net模块，然后创建一个连接TCP客户端的socket对象即可：</p><blockquote><p>/<em> 引入net模块 </em>/</p><p>var net = require(“net”);</p><p>/<em> 创建TCP客户端 </em>/</p><p>var client = net.Socket();</p></blockquote><p>创建完socket对象后，使用socket对象的connect方法就可以连接一个TCP服务器。</p><pre><code class="javascript">/** * 构建TCP客户端 *//* 引入net模块 */var net = require(&quot;net&quot;);/* 创建TCP客户端 */var client = net.Socket();/* 设置连接的服务器 */client.connect(8000, &#39;127.0.0.1&#39;, function () {    console.log(&quot;connect the server&quot;);    /* 向服务器发送数据 */    client.write(&quot;message from client&quot;);})/* 监听服务器传来的data数据 */client.on(&quot;data&quot;, function (data) {    console.log(&quot;the data of server is &quot; + data.toString());})/* 监听end事件 */client.on(&quot;end&quot;, function () {    console.log(&quot;data end&quot;);})</code></pre><h3 id="TCP客户端和TCP服务器的通信"><a href="#TCP客户端和TCP服务器的通信" class="headerlink" title="TCP客户端和TCP服务器的通信"></a>TCP客户端和TCP服务器的通信</h3><p>运行 <a href="#服务器和客户端之间的通信">这段代码</a> 之后再运行 <a href="#构建TCP客户端">这段代码</a> ，可以发现服务器已经接收到客户端的数据，客户端也已经接收到服务端的数据。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fpkso73cqdj31kw0o27bv.jpg" alt=""></p><h2 id="LINK"><a href="#LINK" class="headerlink" title="LINK"></a>LINK</h2><ol><li>本章github源码：<a href="https://github.com/zc95/nodeTest/tree/master/TCP" target="_blank" rel="external">https://github.com/zc95/nodeTest/tree/master/TCP</a></li><li>《Node.js构建HTTP服务器》：<a href="https://zc95.github.io/2018/03/19/nodejs-HTTP/">https://zc95.github.io/2018/03/19/nodejs-HTTP/</a></li><li>用Homebrew安装Telnet：<a href="https://zc95.github.io/2018/03/20/Homebrew/">https://zc95.github.io/2018/03/20/Homebrew/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络是通信互联网的基础，Node.js提供了net、http、dgram模块、分别用来实现TCP、HTTP、UDP的通信。上次的文章&lt;a href=&quot;https://zc95.github.io/2018/03/19/nodejs-HTTP/&quot;&gt;《Node.js构建HTTP
      
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="Node.js" scheme="http://zc95.github.io/tags/Node-js/"/>
    
      <category term="TCP" scheme="http://zc95.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Homebrew</title>
    <link href="http://zc95.github.io/2018/03/20/Homebrew/"/>
    <id>http://zc95.github.io/2018/03/20/Homebrew/</id>
    <published>2018-03-20T13:31:52.000Z</published>
    <updated>2018-03-21T14:58:14.483Z</updated>
    
    <content type="html"><![CDATA[<p>Homebrew简称brew，OSX上的软件包管理工具，在Mac终端可以通过brew安装、更新、卸载软件。</p><h2 id="Homebrew-能干什么"><a href="#Homebrew-能干什么" class="headerlink" title="Homebrew 能干什么?"></a>Homebrew 能干什么?</h2><p><a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew官网</a> 的title是这么说的：macOS 缺失的软件包管理器，意思就是使用 Homebrew 安装 Apple 没有预装但你需要的东西，比如high sierra 10.13中移除了telnet，只需要 <code>brew install telnet</code> 一个命令就行。</p><a id="more"></a><h2 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h2><p>一、进入<a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew官网</a>，按照官网提示在命令行执行ruby脚本（mac自带ruby），在终端运行以下命令：</p><pre><code class="bash">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p>二、按提示输入电脑密码，一路enter到底，直到出现下面的信息就说明安装成功。</p><pre><code class="bash">==&gt; Next steps:- Run `brew help` to get started- Further documentation:     https://docs.brew.sh</code></pre><p>三、运行命令 <code>brew help</code> 就可以了解一些brew常用的命令：</p><pre><code class="bash">Example usage:  brew search [TEXT|/REGEX/]  brew (info|home|options) [FORMULA...]  brew install FORMULA...  brew update  brew upgrade [FORMULA...]  brew uninstall FORMULA...  brew list [FORMULA...]Troubleshooting:  brew config  brew doctor  brew install -vd FORMULADevelopers:  brew create [URL [--no-fetch]]  brew edit [FORMULA...]  https://docs.brew.sh/Formula-CookbookFurther help:  man brew  brew help [COMMAND]  brew home</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Homebrew简称brew，OSX上的软件包管理工具，在Mac终端可以通过brew安装、更新、卸载软件。&lt;/p&gt;
&lt;h2 id=&quot;Homebrew-能干什么&quot;&gt;&lt;a href=&quot;#Homebrew-能干什么&quot; class=&quot;headerlink&quot; title=&quot;Homebrew 能干什么?&quot;&gt;&lt;/a&gt;Homebrew 能干什么?&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://brew.sh/index_zh-cn.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Homebrew官网&lt;/a&gt; 的title是这么说的：macOS 缺失的软件包管理器，意思就是使用 Homebrew 安装 Apple 没有预装但你需要的东西，比如high sierra 10.13中移除了telnet，只需要 &lt;code&gt;brew install telnet&lt;/code&gt; 一个命令就行。&lt;/p&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="Homebrew" scheme="http://zc95.github.io/tags/Homebrew/"/>
    
      <category term="brew" scheme="http://zc95.github.io/tags/brew/"/>
    
      <category term="telnet" scheme="http://zc95.github.io/tags/telnet/"/>
    
  </entry>
  
  <entry>
    <title>Node.js构建HTTP服务器</title>
    <link href="http://zc95.github.io/2018/03/19/nodejs-HTTP/"/>
    <id>http://zc95.github.io/2018/03/19/nodejs-HTTP/</id>
    <published>2018-03-19T12:29:42.000Z</published>
    <updated>2018-04-09T14:29:15.156Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js® is a JavaScript runtime built on <a href="https://developers.google.com/v8/" target="_blank" rel="external">Chrome’s V8 JavaScript engine</a>. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, <a href="https://www.npmjs.com/" target="_blank" rel="external">npm</a>, is the largest ecosystem of open source libraries in the world.</p><h2 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a>Node.js简介</h2><p><code>Node.js</code> 是一个基于 Google Chrome V8 引擎 的 JavaScript 运行环境。Node.js使用后多种先进的技术，其中包括 事件驱动、非阻塞 I/O 模型，使其轻量又高效，受到众多开发者的追捧。</p><p>简单的说，Node.js 就是运行在服务端的 JavaScript ，可以稳定地在各种平台下运行，包括Linux、Windows、Mac OS X、Sun Os 和FreeBSD等众多平台。</p><a id="more"></a><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><ol><li>点击 <a href="https://nodejs.org" target="_blank" rel="external">https://nodejs.org</a> 进入nodejs官网</li><li>有两个版本：LTS和Current，LTS是长期支持版本，成熟可靠</li><li>next到底</li><li>打开终端，输入 <code>node -v</code> ，回车，如果出现类似 <code>v6.11.4</code> 的版本号就说明安装成功</li></ol><h2 id="构建一个HTTP服务器"><a href="#构建一个HTTP服务器" class="headerlink" title="构建一个HTTP服务器"></a>构建一个HTTP服务器</h2><p>在如今web大行其道的时代，支撑无数网页运行的正是HTTP服务器。Node.js之所以受到大量web开发者的青睐，与Node.js有能力自己构建服务器是分不开的。</p><ol><li><p>在根目录下新建 <code>nodetest</code> 文件夹</p></li><li><p>在 <code>nodetest</code> 下新建 <code>HTTP</code> 文件夹</p></li><li><p>在 <code>HTTP</code> 文件夹下新建一个 <code>server.js</code> 的文件</p></li><li><p>拷贝粘贴这段代码，保存：</p><pre><code class="javascript">/** * 创建http服务器 *//* 引入http模块 */var http = require(&quot;http&quot;);/* 创建HTTP服务器 */var server = http.createServer(function(request, response) {    /* 设置相应的头部 */    response.writeHead(200, {        &quot;content-Type&quot; : &quot;text/plain&quot;    });    /* 设置相应的数据 */    response.write(&quot;Welcome to Nodejs&quot;);    response.end();});/* 设置服务器端口 */server.listen(8000, function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre></li><li><p>打开终端 输入 <code>cd nodetest/HTTP</code> </p></li><li><p>输入 <code>node server.js</code> ，返回 <code>Creat server on http://127.0.0.1:8000/</code></p></li><li><p>打开浏览器输入 <code>http://127.0.0.1:8000/</code> 或者 <code>http://localhost:8000</code> </p></li><li><p>Welcome to Nodejs</p></li></ol><h2 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块"></a>文件模块</h2><p>上面说到的HTTP服务器知识实现了将一串字符串发送给服务器。很明显，如果服务器只能发送一些字符串，那几乎是远远不够的，因此我们要做一些扩展，通过文件模块将文件读取并发送给服务器是一个不错的选择，在nodetest文件夹下新建 <code>fsModule.js</code> :</p><pre><code class="javascript">/** * fs模块 *//* 引入http模块 */var http = require(&quot;http&quot;);/* 引入fs模块 */var fs = require(&quot;fs&quot;);/* 创建HTTP服务器 */var server = http.createServer(function(request, response) {    /* 设置响应的头部 */    response.writeHead(200, {        &quot;content-Type&quot; : &quot;text/html&quot;    });    /* 读取文件数据 */    var data = fs.readFileSync(&quot;./index.html&quot;);    /* 设置响应的数据 */    response.write(data);    response.end();});/* 设置服务器端口 */server.listen(8000, function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>同时在同级目录中创建一个名为 <code>index.html</code> 的文件，写入以下代码：</p><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot; /&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;title&gt;fs module&lt;/title&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;fs文件模块&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>node fsModule.js 运行，在浏览器中打开 <code>http://localhost:8000</code> ，Node.js已经把index这个文件发送到客户端了；</p><p>需要提及的是，这里HTTP服务器在发送给浏览器的头部信息中将 content-type修改为了 <code>text/html</code> 。 content-type的人作用就是用来表示客户端或者服务器传输数据的类型，服务器或者客客户端通过这个值来做相应的解析。如果这个值改为原来的 <code>text/plain</code> ，浏览器将显示index.html的所有源代码，这显然不是我们想要的。</p><h2 id="HTTP服务器的路由控制"><a href="#HTTP服务器的路由控制" class="headerlink" title="HTTP服务器的路由控制"></a>HTTP服务器的路由控制</h2><p>上一节中的服务器虽然已经可以通过读取文件数据来发送给客户端了，但你并没有做任何的路由控制，在浏览器中输入任何URL都将返回同样的内容，简单来说，路由就是URL到函数的映射。</p><p>要做到路由控制，通过上面的学习可以预想到修改content-type就可以了，这里假定只需要处理html、js、css和图片文件，创建一个名为 <code>mime.js</code> 的文件：</p><pre><code class="javascript">module.exports = {    &quot;.html&quot; : &quot;text/html&quot;,    &quot;.css&quot; : &quot;text/css&quot;,    &quot;.js&quot; : &quot;text/javascript&quot;,    &quot;.gif&quot; : &quot;image/gif&quot;,    &quot;.ico&quot; : &quot;image/x-icon&quot;,    &quot;.jpeg&quot; : &quot;image/jpeg&quot;,    &quot;.jpg&quot; : &quot;image/jpeg&quot;,    &quot;.png&quot; : &quot;image/png&quot;,}</code></pre><p>创建一个名为 <code>fsModule2.js</code> 的文件：</p><pre><code class="javascript">/** * 这里通过路径处理判断来返回不同的资源，从而做到简单的路由控制 *//* 引入http模块 */var http = require(&quot;http&quot;);/* 引入fs模块 */var fs = require(&quot;fs&quot;);/* 引入url模块 */var url = require(&quot;url&quot;);/* 引入mime文件 */var mime = require(&quot;./mime.js&quot;);/* 引入path模块 */var path = require(&quot;path&quot;);/* 创建HTTP服务器 */var server = http.createServer(function(request, response) {    var filePath = &quot;.&quot;+url.parse(request.url).pathname;    if(filePath === &quot;./&quot;){        filePath = &#39;./index.html&#39;    }    /* 判断相应的文件是否存在 */    fs.exists(filePath,function(exists){        /* 存在则返回相应文件数据 */        if(exists){            var data = fs.readFileSync(filePath);            var contentType = mime[path.extname(filePath)];            response.writeHead(200,{                &quot;content-type&quot;: contentType            });            response.write(data);            response.end();        }else{            response.end(&quot;404&quot;);        }    })});/* 设置服务器端口 */server.listen(8000, function(){    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;);})</code></pre><p>这里通过对路径处理判断来返回不同的资源，从而做到简单的路由控制。</p><h2 id="LINK"><a href="#LINK" class="headerlink" title="LINK"></a>LINK</h2><ol><li>本章github源码：<a href="https://github.com/zc95/nodeTest/tree/master/HTTP" target="_blank" rel="external">https://github.com/zc95/nodeTest/tree/master/HTTP</a></li><li>《Node.js构建TCP服务器和TCP客户端》：<a href="https://zc95.github.io/2018/03/20/nodejs-TCP/">https://zc95.github.io/2018/03/20/nodejs-TCP/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js® is a JavaScript runtime built on &lt;a href=&quot;https://developers.google.com/v8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Chrome’s V8 JavaScript engine&lt;/a&gt;. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, &lt;a href=&quot;https://www.npmjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;npm&lt;/a&gt;, is the largest ecosystem of open source libraries in the world.&lt;/p&gt;
&lt;h2 id=&quot;Node-js简介&quot;&gt;&lt;a href=&quot;#Node-js简介&quot; class=&quot;headerlink&quot; title=&quot;Node.js简介&quot;&gt;&lt;/a&gt;Node.js简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Node.js&lt;/code&gt; 是一个基于 Google Chrome V8 引擎 的 JavaScript 运行环境。Node.js使用后多种先进的技术，其中包括 事件驱动、非阻塞 I/O 模型，使其轻量又高效，受到众多开发者的追捧。&lt;/p&gt;
&lt;p&gt;简单的说，Node.js 就是运行在服务端的 JavaScript ，可以稳定地在各种平台下运行，包括Linux、Windows、Mac OS X、Sun Os 和FreeBSD等众多平台。&lt;/p&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="Node.js" scheme="http://zc95.github.io/tags/Node-js/"/>
    
      <category term="本地服务器" scheme="http://zc95.github.io/tags/%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门</title>
    <link href="http://zc95.github.io/2018/03/13/es6-webpack/"/>
    <id>http://zc95.github.io/2018/03/13/es6-webpack/</id>
    <published>2018-03-13T13:42:52.000Z</published>
    <updated>2018-03-20T13:32:31.633Z</updated>
    
    <content type="html"><![CDATA[<p>github：<a href="https://github.com/zc95/es6-webpack" target="_blank" rel="external">https://github.com/zc95/es6-webpack</a></p><h2 id="webpack搭建ES6环境"><a href="#webpack搭建ES6环境" class="headerlink" title="webpack搭建ES6环境"></a>webpack搭建ES6环境</h2><p>首先下载源码</p><pre><code class="shell">git clone https://github.com/zc95/es6-webpack.git</code></pre><p>然后安装</p><pre><code class="shell">cd es6-webpacknpm installnpm install webpack -gnpm install webpack-dev-server -g</code></pre><p>最后运行</p><pre><code class="shell">cd es6-webpacknpm start</code></pre><a id="more"></a><h2 id="es6基础"><a href="#es6基础" class="headerlink" title="es6基础"></a>es6基础</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><pre><code class="javascript">// ES5 中常量的写法Object.defineProperty(window, &quot;PI2&quot;, {    value: 3.1415926,    writable: false,})</code></pre><pre><code class="javascript">// ES6 的常量写法const PI = 3.1415926</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><pre><code class="javascript">// ES3,ES5var evens = [1, 2, 3, 4, 5];var odds = evens.map(function(v) {  return v + 1});  console.log(evens, odds);};</code></pre><pre><code class="javascript">// ES6let evens = [1, 2, 3, 4, 5];let odds = evens.map(v =&gt; v + 1);console.log(evens, odds);</code></pre><p><strong>this的指向</strong></p><pre><code class="javascript">// ES3,ES5中 this 的指向是 该函数被调用的对象  var factory = function() {    this.a = &#39;a&#39;;    this.b = &#39;b&#39;;    this.c = {      a: &#39;a+&#39;,      b: function() {        return this.a      }    }  }  console.log(new factory().c.b());};</code></pre><pre><code class="javascript">// ES6箭头函数中 this 的指向是 定义时this的指向var factory = function() {    this.a = &#39;a&#39;;    this.b = &#39;b&#39;;    this.c = {      a: &#39;a+&#39;,      b: () =&gt; {        return this.a      }    }  }  console.log(new factory().c.b());</code></pre><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p><strong>默认参数</strong></p><pre><code class="javascript">// ES5\ES3 默认参数的写法  function f(x, y, z) {    if (y === undefined) {      y = 7;    }    if (z === undefined) {      z = 42    }    return x + y + z  }  console.log(f(1, 3));</code></pre><pre><code class="javascript">// ES6 默认参数  function f(x, y = 7, z = 42) {    return x + y + z  }  console.log(f(1, 3));</code></pre><p><strong>可变参数</strong></p><pre><code class="javascript">// ES3,ES5 可变参数  function f() {    var a = Array.prototype.slice.call(arguments);    var sum = 0;    a.forEach(function(item) {      sum += item * 1;    })    return sum  }  console.log(f(1, 2, 3, 6));</code></pre><pre><code class="javascript">// ES6 可变参数function f(...a) {    var sum = 0;    a.forEach(item =&gt; {      sum += item * 1    });    return sum  }  console.log(f(1, 2, 3, 6));</code></pre><p><strong>合并数组</strong></p><pre><code class="javascript">// ES5 合并数组  var params = [&#39;hello&#39;, true, 7];  var other = [1, 2].concat(params);  console.log(other);</code></pre><pre><code class="javascript">// ES6 利用扩展运算符合并数组  var params = [&#39;hello&#39;, true, 7];  var other = [    1, 2, ...params  ];  console.log(other);</code></pre><h3 id="对象代理"><a href="#对象代理" class="headerlink" title="对象代理"></a>对象代理</h3><pre><code class="javascript">// ES3,ES5 数据保护  var Person = function() {    var data = {      name: &#39;es3&#39;,      sex: &#39;male&#39;,      age: 15    }    this.get = function(key) {      return data[key]    }    this.set = function(key, value) {      if (key !== &#39;sex&#39;) {        data[key] = value      }    }  }  // 声明一个实例  var person = new Person();  // 读取  console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)});  // 修改  person.set(&#39;name&#39;, &#39;es3-cname&#39;);  console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)});  person.set(&#39;sex&#39;, &#39;female&#39;);  console.table({name: person.get(&#39;name&#39;), sex: person.get(&#39;sex&#39;), age: person.get(&#39;age&#39;)});</code></pre><pre><code class="javascript">// ES5  var Person = {    name: &#39;es5&#39;,    age: 15  };  Object.defineProperty(Person, &#39;sex&#39;, {    writable: false,    value: &#39;male&#39;  });  console.table({name: Person.name, age: Person.age, sex: Person.sex});  Person.name = &#39;es5-cname&#39;;  console.table({name: Person.name, age: Person.age, sex: Person.sex});  try {    Person.sex = &#39;female&#39;;    console.table({name: Person.name, age: Person.age, sex: Person.sex});  } catch (e) {    console.log(e);  }</code></pre><pre><code class="javascript">// ES6  let Person = {    name: &#39;es6&#39;,    sex: &#39;male&#39;,    age: 15  };  let person = new Proxy(Person, {    get(target, key) {      return target[key]    },    set(target,key,value){      if(key!==&#39;sex&#39;){        target[key]=value;      }    }  });  console.table({    name:person.name,    sex:person.sex,    age:person.age  });  try {    person.sex=&#39;female&#39;;  } catch (e) {    console.log(e);  } finally {  }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;github：&lt;a href=&quot;https://github.com/zc95/es6-webpack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/zc95/es6-webpack&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;webpack搭建ES6环境&quot;&gt;&lt;a href=&quot;#webpack搭建ES6环境&quot; class=&quot;headerlink&quot; title=&quot;webpack搭建ES6环境&quot;&gt;&lt;/a&gt;webpack搭建ES6环境&lt;/h2&gt;&lt;p&gt;首先下载源码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git clone https://github.com/zc95/es6-webpack.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;cd es6-webpack
npm install
npm install webpack -g
npm install webpack-dev-server -g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后运行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;cd es6-webpack
npm start
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="ES6" scheme="http://zc95.github.io/tags/ES6/"/>
    
      <category term="webpack" scheme="http://zc95.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>撸了一个canvas手写板</title>
    <link href="http://zc95.github.io/2018/03/08/canvasPalette/"/>
    <id>http://zc95.github.io/2018/03/08/canvasPalette/</id>
    <published>2018-03-08T15:15:11.000Z</published>
    <updated>2018-03-31T04:47:20.741Z</updated>
    
    <content type="html"><![CDATA[<p>用 canvas 写了一个手写板，功能：画笔粗细、橡皮擦大小、画笔颜色、清空画布、历史操作等</p><h2 id="canvas手写板"><a href="#canvas手写板" class="headerlink" title="canvas手写板"></a>canvas手写板</h2><ul><li><a href="https://zc95.github.io/demo/canvas.html">demo</a></li><li><a href="https://github.com/zc95/canvas" target="_blank" rel="external">github</a><a id="more"></a><h2 id="扫一扫"><a href="#扫一扫" class="headerlink" title="扫一扫"></a>扫一扫</h2></li></ul><p><img width="150" src="https://ws4.sinaimg.cn/large/006tNc79gy1fp5r4kgijtj307s07st9m.jpg"></p><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp5tb8a00yj31401z40vt.jpg" height="600"></p><hr><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp5tb8s4tgj31401z4wjo.jpg" height="600"></p><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp5tbmm3ytj31401z4wj1.jpg" height="600"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 canvas 写了一个手写板，功能：画笔粗细、橡皮擦大小、画笔颜色、清空画布、历史操作等&lt;/p&gt;
&lt;h2 id=&quot;canvas手写板&quot;&gt;&lt;a href=&quot;#canvas手写板&quot; class=&quot;headerlink&quot; title=&quot;canvas手写板&quot;&gt;&lt;/a&gt;canvas手写板&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zc95.github.io/demo/canvas.html&quot;&gt;demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zc95/canvas&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;
    
    </summary>
    
      <category term="demo" scheme="http://zc95.github.io/categories/demo/"/>
    
    
      <category term="canvas" scheme="http://zc95.github.io/tags/canvas/"/>
    
      <category term="material design" scheme="http://zc95.github.io/tags/material-design/"/>
    
  </entry>
  
  <entry>
    <title>自己写了个音乐播放器</title>
    <link href="http://zc95.github.io/2018/02/21/musicPlayer/"/>
    <id>http://zc95.github.io/2018/02/21/musicPlayer/</id>
    <published>2018-02-21T04:45:29.000Z</published>
    <updated>2018-03-31T04:48:24.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="material-design风格的音乐播放器"><a href="#material-design风格的音乐播放器" class="headerlink" title="material design风格的音乐播放器"></a>material design风格的音乐播放器</h2><ul><li><a href="https://zc95.github.io/demo/music.html">demo</a></li><li><a href="https://github.com/zc95/music" target="_blank" rel="external">github</a><a id="more"></a><h2 id="扫一扫"><a href="#扫一扫" class="headerlink" title="扫一扫"></a>扫一扫</h2></li></ul><p><img width="150" src="https://ws3.sinaimg.cn/large/006tNc79gy1fonxkcugj3j307s07sq2p.jpg"></p><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fony99p9rfj30u01hcmzd.jpg" height="600"></p><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fony8j721lj30u01hcwhv.jpg" height="600"></p><h2 id="HTML-5-audio标签"><a href="#HTML-5-audio标签" class="headerlink" title="HTML 5 audio标签"></a>HTML 5 audio标签</h2><h3 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h3><p> 标签定义声音，比如音乐或其他音频流，是 HTML 5 的新标签。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre><code class="html">&lt;audio src=&quot;https://music.163.com/song/media/outer/url?id=451703096.mp3&quot;&gt;您的浏览器不支持 audio 标签。&lt;/audio&gt;</code></pre><h3 id="提示和注释"><a href="#提示和注释" class="headerlink" title="提示和注释"></a>提示和注释</h3><p>可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_autoplay.asp" target="_blank" rel="external">autoplay</a></td><td>autoplay</td><td>如果出现该属性，则音频在就绪后马上播放。</td></tr><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_controls.asp" target="_blank" rel="external">controls</a></td><td>controls</td><td>如果出现该属性，则向用户显示控件，比如播放按钮。</td></tr><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_loop.asp" target="_blank" rel="external">loop</a></td><td>loop</td><td>如果出现该属性，则每当音频结束时重新开始播放。</td></tr><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_preload.asp" target="_blank" rel="external">preload</a></td><td>preload</td><td>如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td></tr><tr><td><a href="http://www.w3school.com.cn/html5/att_audio_src.asp" target="_blank" rel="external">src</a></td><td><em>url</em></td><td>要播放的音频的 URL。</td></tr></tbody></table><h2 id="Javascript控制html5-Audio标签"><a href="#Javascript控制html5-Audio标签" class="headerlink" title="Javascript控制html5 Audio标签"></a>Javascript控制html5 Audio标签</h2><h3 id="javascript动态创建audio标签"><a href="#javascript动态创建audio标签" class="headerlink" title="javascript动态创建audio标签"></a>javascript动态创建audio标签</h3><pre><code class="javascript">var audio=document.creatElement(&quot;audio&quot;);audio.src=&quot;audio/source.ogg&quot;;//路径audio.play();</code></pre><p>or</p><pre><code class="javascript">audio=new Audio(&quot;audio/source.ogg&quot;);//路径audio.play();</code></pre><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>我们可以通过preload=”auto”来实现音频的自动加载，但是我们无法知道音频加载的进度</p><p>这时候可以用canplaythrough来完成</p><pre><code class="javascript">var audio = document.createElement(&quot;audio&quot;);audio.src = &quot;https://music.163.com/song/media/outer/url?id=451703096.mp3&quot;;audio.addEventListener(&quot;canplaythrough&quot;, function () {    alert(&#39;音频文件已经准备好，随时待命&#39;);}, false);</code></pre><p>第一次运行时间会长一些，第二次运行由于文件已经缓存到本地，所以会直接弹出提示框。</p><h3 id="javascript控制audio的播放，暂停，停止"><a href="#javascript控制audio的播放，暂停，停止" class="headerlink" title="javascript控制audio的播放，暂停，停止"></a>javascript控制audio的播放，暂停，停止</h3><pre><code class="javascript">function aPlay() {    audio.play();}function aPause() {    audio.pause();}function aStop() {    audio.currentTime = 0;    audio.pause();}function aSkip() {    audio.currentTime = 50;    audio.play(); }</code></pre><pre><code class="javascript">&lt;input type=&quot;button&quot; onclick=&quot;aPlay();&quot; value=&quot;播放音频&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;aPause();&quot; value=&quot;暂停音频&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;aStop();&quot; value=&quot;停止音频&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;aSkip();&quot; value=&quot;跳到第50秒&quot;&gt;</code></pre><h3 id="javascript控制audio的声音大小"><a href="#javascript控制audio的声音大小" class="headerlink" title="javascript控制audio的声音大小"></a>javascript控制audio的声音大小</h3><blockquote><p>audio.volume = 0;//表示静音  </p><p>audio.volume = 1; //表示声音最大</p><p>audio.volume //返回当前音量，声音值在0-1之间</p></blockquote><h3 id="javascript控制audio的快进，快退，以及显示进度与时长"><a href="#javascript控制audio的快进，快退，以及显示进度与时长" class="headerlink" title="javascript控制audio的快进，快退，以及显示进度与时长"></a>javascript控制audio的快进，快退，以及显示进度与时长</h3><blockquote><p>audio.currentTime //控制audio的进度</p><p>audio.duration //返回当前音量的总时长</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;material-design风格的音乐播放器&quot;&gt;&lt;a href=&quot;#material-design风格的音乐播放器&quot; class=&quot;headerlink&quot; title=&quot;material design风格的音乐播放器&quot;&gt;&lt;/a&gt;material design风格的音乐播放器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zc95.github.io/demo/music.html&quot;&gt;demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zc95/music&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;
    
    </summary>
    
      <category term="demo" scheme="http://zc95.github.io/categories/demo/"/>
    
    
      <category term="material design" scheme="http://zc95.github.io/tags/material-design/"/>
    
  </entry>
  
  <entry>
    <title>教你下载会员歌曲</title>
    <link href="http://zc95.github.io/2018/02/19/musicLink/"/>
    <id>http://zc95.github.io/2018/02/19/musicLink/</id>
    <published>2018-02-19T15:19:04.000Z</published>
    <updated>2018-03-31T04:48:47.851Z</updated>
    
    <content type="html"><![CDATA[<p>教你找歌曲的外链（要会员的歌曲都能下载🤪）</p><h2 id="什么是歌曲的外链？"><a href="#什么是歌曲的外链？" class="headerlink" title="什么是歌曲的外链？"></a>什么是歌曲的外链？</h2><p>我们手机里的歌曲都是下载好的mp3文件，比如说散就散.mp3，</p><p>而外链就比如 <a href="https://music.163.com/song/media/outer/url?id=523251118.mp3" target="_blank" rel="external">https://music.163.com/song/media/outer/url?id=523251118.mp3</a> 这样链接的形式。</p><a id="more"></a><h2 id="怎么免费下载会员歌曲？"><a href="#怎么免费下载会员歌曲？" class="headerlink" title="怎么免费下载会员歌曲？"></a>怎么免费下载会员歌曲？</h2><p>你应该注意到了《说散就散》在qq音乐和网易云都是要vip才能下载</p><p><img style="height:400px; display:inline-block;" src="https://ws4.sinaimg.cn/large/006tNc79gy1fom4irp01wj30nq1600x0.jpg"></p><p><img style="height:400px; display:inline-block;" src="https://ws1.sinaimg.cn/large/006tNc79gy1fom4m03u1bj30no15y77v.jpg"></p><p>这里以网易云音乐的网页版为例说一下”破解“的方法</p><p>这个外链下载会员歌曲的方法也是最近撸一个播放器的时候发现的 <a href="https://zc95.github.io/demo/music">https://zc95.github.io/demo/music</a> （还在改进，下次再说吧 ，逃。。。）</p><h2 id="废话少说，开始了"><a href="#废话少说，开始了" class="headerlink" title="废话少说，开始了"></a>废话少说，开始了</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>打开你电脑上的浏览器，输入 <a href="http://music.163.com" target="_blank" rel="external">http://music.163.com</a> ，网易云音乐官网，输入 “说散就散” 搜索，点第一个要钱的原唱！</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>到了 <a href="http://music.163.com/#/song?id=523251118" target="_blank" rel="external">http://music.163.com/#/song?id=523251118</a> 这个页面</p><ol><li>这个什么 <code>生成外链播放器</code> 不用管，就是个iframe（一般用来博客里），点了提示没版权，放弃。。。</li><li>还有下载按钮，点了提示下载PC端和app，肯定还是要会员。。。放弃</li><li><strong>重点是url，有个?id = xxxxx ，原来百度云网页版的每首歌都有自己的id标识</strong></li></ol><p><img style="height:400px;" src="https://ws2.sinaimg.cn/large/006tNc79gy1fom543cxz3j317i0tgq8q.jpg"></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>从url得到这首歌的id是 <code>523251118</code></p><p>所以这首歌的外链就是 <a href="https://music.163.com/song/media/outer/url?id=523251118.mp3" target="_blank" rel="external">https://music.163.com/song/media/outer/url?id=523251118.mp3</a> ，之后找到别的歌，把这个链接的id替换了就行，除了那种网易云没播放版权的，所有的都可以。</p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>打开电脑里的浏览器，输入 <a href="https://music.163.com/song/media/outer/url?id=523251118.mp3" target="_blank" rel="external">https://music.163.com/song/media/outer/url?id=523251118.mp3</a> 回车，这时候url被解析成好长的一段，不用管它，有上面的链接就足够了，点html5 video标签上的下载按钮就行啦（如下），移动端和Safari的video应该是没有下载按钮的。。。</p><video controls name="media"><source src="https://music.163.com/song/media/outer/url?id=523251118.mp3" type="audio/mpeg"></video><h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>如果是安卓机的就直接把这首歌导入到手机里去，qq音乐、网易云都会自动加到列表里去。</p><p>如果是iphone，，，那就没啥吊用了。。。。</p><hr><p>最后说一下，有很多方法下载这种会员歌曲，，发现这种方法是因为最近在手撸一个音乐播放器，需要用到这样的链接<a href="https://zc95.github.io/demo/music">https://zc95.github.io/demo/music</a> </p><p>不然才不费这么大劲。。毕竟我有破解版😂😂😂</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fom5ymxc3aj31ik11egs4.jpg" alt="https://ws1.sinaimg.cn/large/006tNc79gy1fom5ymxc3aj31ik11egs4.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;教你找歌曲的外链（要会员的歌曲都能下载🤪）&lt;/p&gt;
&lt;h2 id=&quot;什么是歌曲的外链？&quot;&gt;&lt;a href=&quot;#什么是歌曲的外链？&quot; class=&quot;headerlink&quot; title=&quot;什么是歌曲的外链？&quot;&gt;&lt;/a&gt;什么是歌曲的外链？&lt;/h2&gt;&lt;p&gt;我们手机里的歌曲都是下载好的mp3文件，比如说散就散.mp3，&lt;/p&gt;
&lt;p&gt;而外链就比如 &lt;a href=&quot;https://music.163.com/song/media/outer/url?id=523251118.mp3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://music.163.com/song/media/outer/url?id=523251118.mp3&lt;/a&gt; 这样链接的形式。&lt;/p&gt;
    
    </summary>
    
      <category term="技术篇" scheme="http://zc95.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="歌曲" scheme="http://zc95.github.io/tags/%E6%AD%8C%E6%9B%B2/"/>
    
  </entry>
  
</feed>
